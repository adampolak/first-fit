--- a/original.py
+++ b/original.py
@@ -1,49 +1,190 @@
 # EVOLVE-BLOCK-START
 
 def construct_intervals():
   """
   Construct a sequence of intervals of real line,
   in the order in which they are presented to FirstFit,
   so that it maximizes the number of colors used by FirstFit
   divided by the maximum number of intervals that cover a single point
 
   The initial implementation uses the construction from
   Figure 4 in https://arxiv.org/abs/1506.00192
 
   Returns:
     intervals: list of tuples, each tuple (l, r) represents an open interval from l to r
   """
 
-  T = [(0, 1)]
-  for _ in range(4):
-    lo = min(l for l, r in T)
-    hi = max(r for l, r in T)
-    delta = hi - lo
-    S = []
-    for start in (2, 6, 10, 14):
-      S += [(delta * start + l - lo, delta * start + r - lo) for l, r in T]
-    S += [
-      (delta * 1, delta * 5),
-      (delta * 12, delta * 16),
-      (delta * 4, delta * 9),
-      (delta * 8, delta * 13)
-    ]
-    T = S
-  return T
+  import random
+  random.seed(0)
 
-  # return [  # Figure 3, OPT=2, FF=4
-  #   (2,3),
-  #   (6,7),
-  #   (10,11),
-  #   (14,15),
-  #   (1,5),
-  #   (12,16),
-  #   (4,9),
-  #   (8,13),
-  # ]
+  def firstfit_color_count(intervals):
+    """Simulate FirstFit on the given arrival-ordered intervals."""
+    colors = []
+    for (l, r) in intervals:
+      placed = False
+      for col in colors:
+        conflict = False
+        for (cl, cr) in col:
+          # open intervals overlap iff cl < r and l < cr
+          if cl < r and l < cr:
+            conflict = True
+            break
+        if not conflict:
+          col.append((l, r))
+          placed = True
+          break
+      if not placed:
+        colors.append([(l, r)])
+    return len(colors)
+
+  def clique_number(intervals):
+    """Compute the clique number (Ï‰) by sweep-line. For open intervals we
+    process ends before starts at the same coordinate so [a,b) and [b,c)
+    don't overlap."""
+    events = []
+    for (l, r) in intervals:
+      events.append((l, 1))   # start
+      events.append((r, -1))  # end
+    events.sort(key=lambda x: (x[0], x[1]))  # end (-1) comes before start (+1) at same coord
+    active = 0
+    best = 0
+    for _, delta in events:
+      active += delta
+      if active > best:
+        best = active
+    return best
+
+  def generate_recursive(starts, caps, depth, interleave=False):
+    """Generate a recursive construction parameterized by:
+       - starts: sequence of integer offsets for block copies per level
+       - caps: list of (a,b) base intervals appended each level (scaled by delta)
+       - depth: recursion depth
+       - interleave: if True, use a round-robin copy order (increases cross-copy interference)
+    """
+    T = [(0.0, 1.0)]
+    for _ in range(depth):
+      lo = min(l for l, r in T)
+      hi = max(r for l, r in T)
+      delta = hi - lo
+      S = []
+      if interleave:
+        # Round-robin copy to increase color interactions across blocks
+        for i in range(len(T)):
+          li, ri = T[i]
+          for start in starts:
+            S.append((delta * start + li - lo, delta * start + ri - lo))
+      else:
+        for start in starts:
+          S += [(delta * start + l - lo, delta * start + r - lo) for l, r in T]
+      # append scaled caps (longer intervals that intersect several blocks)
+      for a, b in caps:
+        S.append((delta * a, delta * b))
+      T = S
+    return T
+
+  # baseline original construction (kept as fallback)
+  def original():
+    T = [(0, 1)]
+    for _ in range(4):
+      lo = min(l for l, r in T)
+      hi = max(r for l, r in T)
+      delta = hi - lo
+      S = []
+      for start in (2, 6, 10, 14):
+        S += [(delta * start + l - lo, delta * start + r - lo) for l, r in T]
+      S += [
+        (delta * 1, delta * 5),
+        (delta * 12, delta * 16),
+        (delta * 4, delta * 9),
+        (delta * 8, delta * 13)
+      ]
+      T = S
+    return T
+
+  # Search for an improved variant (time/size-bounded)
+  best_seq = None
+  best_score = -1.0
+  best_meta = None
+  max_intervals = 2200
+
+  starts_options = [
+    (2, 6, 10, 14),
+    (2, 6, 10, 14, 18),
+    (2, 6, 10, 14, 18, 22),
+  ]
+  depth_options = [3, 4, 5]
+  trials_per_combo = 80
+
+  # Start with the baseline as a safe candidate
+  baseline = original()
+  baseline_colors = firstfit_color_count(baseline)
+  baseline_omega = clique_number(baseline)
+  if baseline_omega > 0:
+    best_seq = baseline
+    best_score = baseline_colors / baseline_omega
+    best_meta = ("baseline", baseline_colors, baseline_omega, len(baseline))
+
+  # Randomized exploration of caps and interleaving (deterministic seed)
+  for starts in starts_options:
+    for depth in depth_options:
+      # quick estimate of explosion: skip patterns that will definitely exceed budget
+      p_est = max(4, len(starts))
+      est = 1
+      for _ in range(depth):
+        est = len(starts) * est + p_est
+        if est > max_intervals:
+          break
+      if est > max_intervals:
+        continue
+
+      min_s = min(starts)
+      max_s = max(starts)
+
+      # heuristic cap set derived from the starts sequence
+      cap_heur = []
+      for i in range(len(starts)):
+        if i == 0:
+          a = starts[0] - 1
+          b = starts[0] + 3
+        elif i == len(starts) - 1:
+          a = starts[i - 1] + 2
+          b = starts[i] + 2
+        else:
+          a = starts[i - 1] + 2
+          b = starts[i] + 3
+        cap_heur.append((a, b))
+
+      candidates = [cap_heur]
+      # add random cap-sets to explore the local neighborhood
+      for _ in range(trials_per_combo):
+        caps = []
+        for _i in range(max(4, len(starts))):
+          a = random.randint(min_s - 2, max_s + 1)
+          b = a + random.randint(3, 6)
+          caps.append((a, b))
+        candidates.append(caps)
+
+      for interleave in (False, True):
+        for caps in candidates:
+          seq = generate_recursive(starts, caps, depth, interleave=interleave)
+          if len(seq) == 0 or len(seq) > max_intervals:
+            continue
+          colors = firstfit_color_count(seq)
+          omega = clique_number(seq)
+          if omega <= 0:
+            continue
+          score = colors / omega
+          if score > best_score or (abs(score - best_score) < 1e-9 and len(seq) < len(best_seq)):
+            best_score = score
+            best_seq = seq
+            best_meta = ("starts=%s depth=%d interleave=%s caps=%s" % (starts, depth, interleave, caps), colors, omega, len(seq))
+
+  if best_seq is None:
+    best_seq = original()
+  return best_seq
 
 # EVOLVE-BLOCK-END
 
 def run_experiment(**kwargs):
   """Main called by evaluator"""
   return construct_intervals()