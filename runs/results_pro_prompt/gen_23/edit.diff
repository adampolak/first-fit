--- a/original.py
+++ b/original.py
@@ -1,246 +1,194 @@
 # EVOLVE-BLOCK-START
 
 def construct_intervals():
-  """
-  Construct a sequence of intervals of real line,
-  in the order in which they are presented to FirstFit,
-  so that it maximizes the number of colors used by FirstFit
-  divided by the maximum number of intervals that cover a single point
+    import math, random
+    random.seed(42)
 
-  The initial implementation uses the construction from
-  Figure 4 in https://arxiv.org/abs/1506.00192
+    # FirstFit simulator
+    def firstfit_color_count(intervals):
+        end_times = []
+        for l, r in intervals:
+            placed = False
+            for i, et in enumerate(end_times):
+                if et <= l:
+                    end_times[i] = r
+                    placed = True
+                    break
+            if not placed:
+                end_times.append(r)
+        return len(end_times)
 
-  Returns:
-    intervals: list of tuples, each tuple (l, r) represents an open interval from l to r
-  """
+    # Offline optimum via clique number
+    def clique_bound(intervals):
+        events = []
+        for l, r in intervals:
+            events.append((l, 1))
+            events.append((r, -1))
+        events.sort(key=lambda x: (x[0], x[1]))
+        cur = best = 0
+        for _, d in events:
+            cur += d
+            best = max(best, cur)
+        return best
 
-  import random
-  random.seed(0)
+    # Fractal construction
+    def build_fractal(base, depth, starts, caps):
+        T = list(base)
+        for _ in range(depth):
+            lo = min(l for l, _ in T)
+            hi = max(r for _, r in T)
+            delta = hi - lo
+            S = []
+            # scaled copies
+            for s in starts:
+                off = delta * s
+                S.extend([(off + l - lo, off + r - lo) for l, r in T])
+            # cap intervals
+            for a, b in caps:
+                S.append((delta * a, delta * b))
+            T = S
+        return T
 
-  def firstfit_color_count(intervals):
-    """Simulate FirstFit on the given arrival-ordered intervals."""
-    colors = []
-    for (l, r) in intervals:
-      placed = False
-      for col in colors:
-        conflict = False
-        for (cl, cr) in col:
-          # open intervals overlap iff cl < r and l < cr
-          if cl < r and l < cr:
-            conflict = True
-            break
-        if not conflict:
-          col.append((l, r))
-          placed = True
-          break
-      if not placed:
-        colors.append([(l, r)])
-    return len(colors)
+    # Block‐hybrid reordering
+    def block_hybrid_order(seq):
+        n = len(seq)
+        if n < 4:
+            return list(seq)
+        k = 4
+        b = n // k
+        parts = [seq[i*b:(i+1)*b] for i in range(k-1)]
+        parts.append(seq[(k-1)*b:])
+        out = []
+        out += parts[0]
+        if len(parts) > 1:
+            out += sorted(parts[1], key=lambda iv: (iv[0], iv[1]))
+        if len(parts) > 2:
+            out += list(reversed(parts[2]))
+        if len(parts) > 3:
+            out += sorted(parts[3], key=lambda iv: (iv[1]-iv[0], iv[0]))
+        return out
 
-  def clique_number(intervals):
-    """Compute the clique number (ω) by sweep-line. For open intervals we
-    process ends before starts at the same coordinate so [a,b) and [b,c)
-    don't overlap."""
-    events = []
-    for (l, r) in intervals:
-      events.append((l, 1))   # start
-      events.append((r, -1))  # end
-    events.sort(key=lambda x: (x[0], x[1]))  # end (-1) comes before start (+1) at same coord
-    active = 0
-    best = 0
-    for _, delta in events:
-      active += delta
-      if active > best:
-        best = active
-    return best
+    # Greedy that picks the interval forcing the largest FirstFit color
+    def greedy_max_assigned_color(seq, sample_size=80, seed=0):
+        rng = random.Random(seed)
+        rem = list(seq)
+        order = []
+        end_times = []
+        while rem:
+            k = min(sample_size, len(rem))
+            idxs = list(range(len(rem))) if k == len(rem) else rng.sample(range(len(rem)), k)
+            best_idx = idxs[0]
+            best_color = -1
+            for idx in idxs:
+                l, r = rem[idx]
+                assigned = None
+                for i, et in enumerate(end_times):
+                    if et <= l:
+                        assigned = i
+                        break
+                if assigned is None:
+                    assigned = len(end_times)
+                if assigned > best_color:
+                    best_color = assigned
+                    best_idx = idx
+            l, r = rem.pop(best_idx)
+            placed = False
+            for i, et in enumerate(end_times):
+                if et <= l:
+                    end_times[i] = r
+                    placed = True
+                    break
+            if not placed:
+                end_times.append(r)
+            order.append((l, r))
+        return order
 
-  def generate_recursive(starts, caps, depth, interleave=False, caps_before=False):
-    """Generate a recursive construction parameterized by:
-       - starts: sequence of integer offsets for block copies per level
-       - caps: list of (a,b) base intervals appended each level (scaled by delta)
-       - depth: recursion depth
-       - interleave: if True, use a round-robin copy order (increases cross-copy interference)
-       - caps_before: if True, present caps first at each level to pre-block low colors
-    """
-    T = [(0.0, 1.0)]
-    for _ in range(depth):
-      lo = min(l for l, r in T)
-      hi = max(r for l, r in T)
-      delta = hi - lo
-      S = []
-      if caps_before:
-        # Place caps first this round to occupy low colors early
-        for a, b in caps:
-          S.append((delta * a, delta * b))
-      if interleave:
-        # Round-robin copy to increase color interactions across blocks
-        for i in range(len(T)):
-          li, ri = T[i]
-          for start in starts:
-            S.append((delta * start + li - lo, delta * start + ri - lo))
-      else:
-        for start in starts:
-          S += [(delta * start + l - lo, delta * start + r - lo) for l, r in T]
-      if not caps_before:
-        # Append caps after block copies (original behavior)
-        for a, b in caps:
-          S.append((delta * a, delta * b))
-      T = S
-    return T
+    # Greedy that picks the interval overlapping the most active colors
+    def greedy_max_overlap(seq, sample_size=80, seed=1):
+        rng = random.Random(seed)
+        rem = list(seq)
+        order = []
+        end_times = []
+        while rem:
+            k = min(sample_size, len(rem))
+            idxs = list(range(len(rem))) if k == len(rem) else rng.sample(range(len(rem)), k)
+            best_idx = idxs[0]
+            best_ov = -1
+            for idx in idxs:
+                l, r = rem[idx]
+                ov = sum(1 for et in end_times if et > l)
+                if ov > best_ov:
+                    best_ov = ov
+                    best_idx = idx
+            l, r = rem.pop(best_idx)
+            placed = False
+            for i, et in enumerate(end_times):
+                if et <= l:
+                    end_times[i] = r
+                    placed = True
+                    break
+            if not placed:
+                end_times.append(r)
+            order.append((l, r))
+        return order
 
-  def hybrid_blockwise(seq):
-    """Block-wise hybrid ordering to exploit local fractal structure."""
-    n = len(seq)
-    if n < 8:
-      return list(seq)
-    k = 4
-    b = n // k
-    parts = [list(seq[i * b:(i + 1) * b]) for i in range(k - 1)]
-    parts.append(list(seq[(k - 1) * b:]))
-    out = []
-    # block 0: keep original local structure
-    out += parts[0]
-    # block 1: left-first
-    if len(parts) > 1:
-      out += sorted(parts[1], key=lambda x: (x[0], x[1]))
-    # block 2: reversed
-    if len(parts) > 2:
-      out += list(reversed(parts[2]))
-    # block 3: short-first
-    if len(parts) > 3:
-      out += sorted(parts[3], key=lambda x: (x[1] - x[0], x[0]))
-    return out
+    # Seed patterns (starts + caps)
+    seeds = [
+        {'starts': (2, 6, 10, 14), 'caps': [(1,5),(4,9),(8,13),(12,16)]},
+        {'starts': (3, 7, 11, 15), 'caps': [(2,6),(5,10),(9,14),(13,17)]},
+        {'starts': (4, 8, 12, 16), 'caps': [(3,7),(6,11),(10,15),(14,18)]},
+    ]
 
-  # baseline original construction (kept as fallback)
-  def original():
-    T = [(0, 1)]
-    for _ in range(4):
-      lo = min(l for l, r in T)
-      hi = max(r for l, r in T)
-      delta = hi - lo
-      S = []
-      for start in (2, 6, 10, 14):
-        S += [(delta * start + l - lo, delta * start + r - lo) for l, r in T]
-      S += [
-        (delta * 1, delta * 5),
-        (delta * 12, delta * 16),
-        (delta * 4, delta * 9),
-        (delta * 8, delta * 13)
-      ]
-      T = S
-    return T
+    base = [(0.0, 1.0)]
+    depth_options = [3, 4]
+    max_intervals = 2000
 
-  # Search for an improved variant (time/size-bounded)
-  best_seq = None
-  best_score = -1.0
-  best_meta = None
-  max_intervals = 2200
+    best_seq = None
+    best_ratio = -1.0
 
-  starts_options = [
-    (2, 6, 10, 14),
-    (3, 7, 11, 15),
-    (4, 8, 12, 16),
-  ]
-  depth_options = [3, 4]
-  trials_per_combo = 6
+    # Explore each seed & depth
+    for sd in seeds:
+        for depth in depth_options:
+            seq_f = build_fractal(base, depth, sd['starts'], sd['caps'])
+            if len(seq_f) == 0 or len(seq_f) > max_intervals:
+                continue
+            # integer endpoints
+            seq = [(int(l), int(r)) for l, r in seq_f]
+            omega = clique_bound(seq)
+            if omega <= 0:
+                continue
+            # Arrival‐order heuristics
+            orderings = [
+                ('id',         lambda x: x),
+                ('rev',        lambda x: list(reversed(x))),
+                ('left',       lambda x: sorted(x, key=lambda iv:(iv[0],iv[1]))),
+                ('right',      lambda x: sorted(x, key=lambda iv:(-iv[0],-iv[1]))),
+                ('short',      lambda x: sorted(x, key=lambda iv:(iv[1]-iv[0],iv[0]))),
+                ('long',       lambda x: sorted(x, key=lambda iv:(-(iv[1]-iv[0]),iv[0]))),
+                ('block_hyb',  block_hybrid_order),
+                ('g_assn_40',  lambda x: greedy_max_assigned_color(x,40,0)),
+                ('g_assn_80',  lambda x: greedy_max_assigned_color(x,80,0)),
+                ('g_ovlp_40',  lambda x: greedy_max_overlap(x,40,1)),
+                ('g_ovlp_80',  lambda x: greedy_max_overlap(x,80,1)),
+            ]
+            for name, ofunc in orderings:
+                try:
+                    seq_o = ofunc(seq)
+                except:
+                    continue
+                alg = firstfit_color_count(seq_o)
+                ratio = alg / omega
+                if ratio > best_ratio or (abs(ratio-best_ratio)<1e-9 and (best_seq is None or len(seq_o)<len(best_seq))):
+                    best_ratio = ratio
+                    best_seq = seq_o
 
-  # Start with the baseline as a safe candidate (evaluate multiple orders)
-  baseline = original()
-  baseline_omega = clique_number(baseline)
-  if baseline_omega > 0:
-    orders = []
-    base = list(baseline)
-    orders.append(("fractal", base))
-    orders.append(("reversed", list(reversed(base))))
-    orders.append(("left_first", sorted(base, key=lambda x: (x[0], x[1]))))
-    orders.append(("right_first", sorted(base, key=lambda x: (-x[0], -x[1]))))
-    orders.append(("short_first", sorted(base, key=lambda x: (x[1] - x[0], x[0]))))
-    orders.append(("long_first", sorted(base, key=lambda x: (-(x[1] - x[0]), x[0]))))
-    orders.append(("hybrid_blockwise", hybrid_blockwise(base)))
-    for order_name, seq0 in orders:
-      colors0 = firstfit_color_count(seq0)
-      score0 = colors0 / baseline_omega
-      if score0 > best_score:
-        best_seq = seq0
-        best_score = score0
-        best_meta = ("baseline order=%s" % order_name, colors0, baseline_omega, len(seq0))
-
-  # Randomized exploration of caps and interleaving (deterministic seed)
-  for starts in starts_options:
-    for depth in depth_options:
-      # quick estimate of explosion: skip patterns that will definitely exceed budget
-      p_est = max(4, len(starts))
-      est = 1
-      for _ in range(depth):
-        est = len(starts) * est + p_est
-        if est > max_intervals:
-          break
-      if est > max_intervals:
-        continue
-
-      min_s = min(starts)
-      max_s = max(starts)
-
-      # heuristic cap set derived from the starts sequence
-      cap_heur = []
-      for i in range(len(starts)):
-        if i == 0:
-          a = starts[0] - 1
-          b = starts[0] + 3
-        elif i == len(starts) - 1:
-          a = starts[i - 1] + 2
-          b = starts[i] + 2
-        else:
-          a = starts[i - 1] + 2
-          b = starts[i] + 3
-        cap_heur.append((a, b))
-
-      candidates = [cap_heur]
-      # add random cap-sets to explore the local neighborhood
-      for _ in range(trials_per_combo):
-        caps = []
-        for _i in range(max(4, len(starts))):
-          a = random.randint(min_s - 2, max_s + 1)
-          b = a + random.randint(3, 6)
-          caps.append((a, b))
-        candidates.append(caps)
-
-      for interleave in (False, True):
-        for caps_before in (False, True):
-          for caps in candidates:
-            seq = generate_recursive(starts, caps, depth, interleave=interleave, caps_before=caps_before)
-            if len(seq) == 0 or len(seq) > max_intervals:
-              continue
-            omega = clique_number(seq)
-            if omega <= 0:
-              continue
-
-            # Evaluate several principled arrival orders
-            base = list(seq)
-            orderings = [
-              ("fractal", base),
-              ("reversed", list(reversed(base))),
-              ("left_first", sorted(base, key=lambda x: (x[0], x[1]))),
-              ("right_first", sorted(base, key=lambda x: (-x[0], -x[1]))),
-              ("short_first", sorted(base, key=lambda x: (x[1] - x[0], x[0]))),
-              ("long_first", sorted(base, key=lambda x: (-(x[1] - x[0]), x[0]))),
-              ("hybrid_blockwise", hybrid_blockwise(base)),
-            ]
-
-            for order_name, candidate_seq in orderings:
-              colors = firstfit_color_count(candidate_seq)
-              score = colors / omega
-              if score > best_score or (abs(score - best_score) < 1e-9 and len(candidate_seq) < len(best_seq)):
-                best_score = score
-                best_seq = candidate_seq
-                best_meta = ("starts=%s depth=%d interleave=%s caps_before=%s caps=%s order=%s" % (starts, depth, interleave, caps_before, caps, order_name), colors, omega, len(candidate_seq))
-
-  if best_seq is None:
-    best_seq = original()
-  return best_seq
+    # Fallback to a trivial interval if nothing found
+    if best_seq is None:
+        best_seq = [(0,1)]
+    return best_seq
 
 # EVOLVE-BLOCK-END
 
 def run_experiment(**kwargs):
   """Main called by evaluator"""
   return construct_intervals()