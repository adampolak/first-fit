<NAME>
adversarial_orders_and_caps_templates
</NAME>

<DESCRIPTION>
Checklist:
- Add multi-order evaluation including an adaptive adversarial order to stress FirstFit.
- Introduce deterministic cap templates (bridging adjacent/non-adjacent blocks) plus jittered variants.
- Expand anchor (starts) families to diversify the fractal backbone.
- Evaluate each candidate under multiple orders and return the best-ordered sequence, not just the set.
- Keep interval budget pruning; lightly tune exploration parameters.

Rationale and plan:
The prior construction consistently returns the literature baseline with ratio 13/5 ≈ 2.6. To push FirstFit’s colors higher while maintaining a low clique number, we (i) enrich the structural search using cap templates that couple tiles across scales, (ii) explore more anchor configurations, and (iii) crucially, adversarially choose the arrival order per candidate so as to block all currently used colors as often as possible. We implement a bitset-based adaptive adversary (gated for large n) and several deterministic orderings. For each candidate we pick the order maximizing FirstFit/ω and return that order. This preserves OPT but increases FF usage.

Validation after each step:
- New orderers compile locally (pure Python, deterministic). If adversary is too heavy for large n, we fall back to right-end ordering (guarded).
- Template generation yields valid caps; jitter ensures min cap length 3; budget pruning prevents explosion.
- Final return uses the best-ordered candidate; ω is rechecked via cached eval to ensure order-invariance; if issues arise, we fall back to the as-built order.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
  def generate_recursive(starts, caps, depth, interleave=False, caps_before=False):
    """Recursive fractal-like construction with optional interleaving and cap placement ordering."""
    T = [(0.0, 1.0)]
    for _ in range(depth):
      lo = min(l for l, r in T)
      hi = max(r for l, r in T)
      delta = hi - lo
      S = []
      if caps_before:
        # place caps first to occupy some colors early
        for a, b in caps:
          S.append((delta * a, delta * b))
      if interleave:
        for i in range(len(T)):
          li, ri = T[i]
          for start in starts:
            S.append((delta * start + li - lo, delta * start + ri - lo))
      else:
        for start in starts:
          S += [(delta * start + l - lo, delta * start + r - lo) for l, r in T]
      if not caps_before:
        for a, b in caps:
          S.append((delta * a, delta * b))
      T = S
    return T
=======
  # -------------------- Orderings and adversarial machinery --------------------
  def order_left_first(seq):
    return sorted(seq, key=lambda x: (x[0], x[1]))

  def order_right_first(seq):
    return sorted(seq, key=lambda x: (-x[0], -x[1]))

  def order_short_first(seq):
    return sorted(seq, key=lambda x: ((x[1] - x[0]), x[0]))

  def order_long_first(seq):
    return sorted(seq, key=lambda x: (-(x[1] - x[0]), x[0]))

  def order_by_right_endpoint(seq):
    return sorted(seq, key=lambda x: (x[1], x[0]))

  def order_hybrid_blockwise(seq):
    # Partition into 4 blocks and apply different local orders
    n = len(seq)
    if n < 12:
      return list(seq)
    k = 4
    b = n // k
    parts = [list(seq[i * b:(i + 1) * b]) for i in range(k - 1)]
    parts.append(list(seq[(k - 1) * b:]))
    out = []
    out += parts[0]
    if len(parts) > 1:
      out += order_left_first(parts[1])
    if len(parts) > 2:
      out += list(reversed(parts[2]))
    if len(parts) > 3:
      out += order_short_first(parts[3])
    return out

  def adversarial_order(seq):
    """
    Adaptive adversary: iteratively pick an interval that blocks all current colors if possible,
    breaking ties by maximum coverage among unplaced intervals, then by shorter length.
    Uses bitsets; falls back for very large n.
    """
    n = len(seq)
    if n == 0:
      return []
    if n > 1200:
      # For very large instances, use a strong deterministic stress order
      return order_by_right_endpoint(seq)

    # Precompute intersection bitsets
    neighbors = [0] * n
    for i in range(n):
      li, ri = seq[i]
      for j in range(i + 1, n):
        lj, rj = seq[j]
        if li < rj and lj < ri:
          neighbors[i] |= (1 << j)
          neighbors[j] |= (1 << i)

    unplaced = set(range(n))
    color_sets = []   # list of bitsets, one per color
    assigned = [-1] * n
    ordering = []

    def assign_color(i):
      ni = neighbors[i]
      for c, cm in enumerate(color_sets):
        if (ni & cm) == 0:
          color_sets[c] |= (1 << i)
          assigned[i] = c
          return c
      # new color
      color_sets.append(1 << i)
      assigned[i] = len(color_sets) - 1
      return assigned[i]

    while unplaced:
      used = len(color_sets)
      # bitset for unplaced
      mask_unplaced = 0
      for j in unplaced:
        mask_unplaced |= (1 << j)
      best_i = None
      best_key = None
      for i in list(unplaced):
        ni = neighbors[i]
        # how many colors it intersects
        blocked = 0
        for cm in color_sets:
          if (ni & cm) != 0:
            blocked += 1
        new_color = 1 if blocked == used else 0
        coverage = ((ni & mask_unplaced) & ~(1 << i)).bit_count()
        length = seq[i][1] - seq[i][0]
        key = (new_color, blocked, coverage, -length)
        if best_key is None or key > best_key:
          best_key = key
          best_i = i
      ordering.append(best_i)
      assign_color(best_i)
      unplaced.remove(best_i)

    return [seq[i] for i in ordering]

  def best_ordered_seq(seq):
    """
    Try several deterministic orders and an adaptive adversarial order (budget-gated).
    Return (best_ordered_sequence, colors_used_by_FirstFit, omega).
    """
    orders = []
    orders.append(list(seq))  # as-built
    orders.append(list(reversed(seq)))
    orders.append(order_left_first(seq))
    orders.append(order_by_right_endpoint(seq))
    orders.append(order_short_first(seq))
    orders.append(order_long_first(seq))
    orders.append(order_hybrid_blockwise(seq))
    try:
      orders.append(adversarial_order(seq))
    except Exception:
      # safety net in case of pathologies
      pass
    best_seq = None
    best_colors = -1
    best_omega = 0
    for cand in orders:
      colors, omega = eval_seq_cached(tuple(cand))
      if omega <= 0:
        continue
      # primary objective: maximize colors/omega
      if best_omega == 0 or (colors / omega) > (best_colors / best_omega):
        best_seq = cand
        best_colors = colors
        best_omega = omega
    if best_seq is None:
      colors, omega = eval_seq_cached(tuple(seq))
      return list(seq), colors, omega
    return best_seq, best_colors, best_omega

  def generate_recursive(starts, caps, depth, interleave=False, caps_before=False):
    """Recursive fractal-like construction with optional interleaving and cap placement ordering."""
    T = [(0.0, 1.0)]
    for _ in range(depth):
      lo = min(l for l, r in T)
      hi = max(r for l, r in T)
      delta = hi - lo
      S = []
      if caps_before:
        # place caps first to occupy some colors early
        for a, b in caps:
          S.append((delta * a, delta * b))
      if interleave:
        for i in range(len(T)):
          li, ri = T[i]
          for start in starts:
            S.append((delta * start + li - lo, delta * start + ri - lo))
      else:
        for start in starts:
          S += [(delta * start + l - lo, delta * start + r - lo) for l, r in T]
      if not caps_before:
        for a, b in caps:
          S.append((delta * a, delta * b))
      T = S
    return T
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
  # Baseline original construction (safe fallback)
  def original():
=======
  # Cap templates bridging adjacent and non-adjacent towers (deterministic scaffolds)
  def cap_templates_for_starts(starts):
    s = list(starts)
    t = []
    if len(s) >= 4:
      # Canonical pattern and a few balanced variants
      t.append([(s[0] - 1, s[0] + 3),
                (s[1] + 2, s[2] + 2),
                (s[2] - 1, s[3] + 1),
                (s[1] - 2, s[2] + 3)])
      t.append([(s[0], s[1] + 2),
                (s[1] + 1, s[2] + 3),
                (s[2], s[3] + 2),
                (s[0] + 2, s[2] + 1)])
      t.append([(s[0] - 1, s[1] + 3),
                (s[1] - 1, s[2] + 3),
                (s[2] - 1, s[3] + 3),
                (s[0] + 1, s[3] + 1)])
      t.append([(s[0] - 1, s[1] + 1),
                (s[2] - 1, s[3] + 1),
                (s[1], s[2] + 2),
                (s[0] + 2, s[3])])
    else:
      for i in range(len(s) - 1):
        t.append([(s[i], s[i + 1] + 2)] * 4)
    return t

  # Baseline original construction (safe fallback)
  def original():
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
  # Baseline evaluation
  baseline = original()
  baseline_colors, baseline_omega = eval_seq_cached(tuple(baseline))
  if baseline_omega > 0:
    best_seq = baseline
    best_score = baseline_colors / baseline_omega
    best_meta = ("baseline", baseline_colors, baseline_omega, len(baseline))
=======
  # Baseline evaluation (with adversarial/best ordering)
  baseline = original()
  base_ordered, baseline_colors, baseline_omega = best_ordered_seq(baseline)
  if baseline_omega > 0:
    best_seq = base_ordered
    best_score = baseline_colors / baseline_omega
    best_meta = ("baseline+order", baseline_colors, baseline_omega, len(base_ordered))
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
  alt = original_alt()
  alt_colors, alt_omega = eval_seq_cached(tuple(alt))
  if alt_omega > 0:
    alt_score = alt_colors / alt_omega
    if alt_score > best_score + 1e-12:
      best_seq = alt
      best_score = alt_score
      best_meta = ("alt_anchor=(3,7,11,15)", alt_colors, alt_omega, len(alt))
=======
  alt = original_alt()
  alt_ordered, alt_colors, alt_omega = best_ordered_seq(alt)
  if alt_omega > 0:
    alt_score = alt_colors / alt_omega
    if alt_score > best_score + 1e-12:
      best_seq = alt_ordered
      best_score = alt_score
      best_meta = ("alt_anchor=(3,7,11,15)+order", alt_colors, alt_omega, len(alt_ordered))
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
  starts_options = [
    (2, 6, 10, 14),
    (3, 7, 11, 15),
    (2, 6, 10, 14, 18),
    (2, 6, 10, 14, 18, 22),
    (3, 7, 11, 15, 19),
  ]
=======
  starts_options = [
    (2, 6, 10, 14),
    (3, 7, 11, 15),
    (4, 8, 12, 16),
    (2, 5, 9, 13),
    (2, 7, 12, 17),
    (3, 6, 9, 12),
    (2, 6, 10, 14, 18),
    (2, 6, 10, 14, 18, 22),
    (3, 7, 11, 15, 19),
    (4, 8, 12, 16, 20),
  ]
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
  trials_per_combo = 60
=======
  trials_per_combo = 50
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
      cap_heur = []
      for i in range(len(starts)):
        if i == 0:
          a = starts[0] - 1
          b = starts[0] + 3
        elif i == len(starts) - 1:
          a = starts[i - 1] + 2
          b = starts[i] + 2
        else:
          a = starts[i - 1] + 2
          b = starts[i] + 3
        cap_heur.append((a, b))

      candidates = [cap_heur]
      for _ in range(trials_per_combo):
        caps = []
        for _i in range(max(4, len(starts))):
          a = random.randint(min_s - 2, max_s + 1)
          b = a + random.randint(3, 6)
          caps.append((a, b))
        candidates.append(caps)

      for interleave in (False, True):
        for caps_before in (False, True):
          for caps in candidates:
            seq = generate_recursive(starts, caps, depth, interleave=interleave, caps_before=caps_before)
            if len(seq) == 0 or len(seq) > max_intervals:
              continue
            colors, omega = eval_seq_cached(tuple(seq))
            if omega <= 0:
              continue
            score = colors / omega
            if score > best_score + 1e-12 or (abs(score - best_score) < 1e-12 and len(seq) < len(best_seq)):
              best_seq = seq
              best_score = score
              best_meta = ("starts=%s depth=%d interleave=%s caps_before=%s caps=%s" % (
                              starts, depth, interleave, caps_before, caps), colors, omega, len(seq))
=======
      cap_heur = []
      for i in range(len(starts)):
        if i == 0:
          a = starts[0] - 1
          b = starts[0] + 3
        elif i == len(starts) - 1:
          a = starts[i - 1] + 2
          b = starts[i] + 2
        else:
          a = starts[i - 1] + 2
          b = starts[i] + 3
        cap_heur.append((a, b))

      candidates = [cap_heur]
      # Deterministic template-based caps to couple towers
      templates = cap_templates_for_starts(starts)
      candidates += templates
      # Jittered variants around templates (budgeted)
      rng = random.Random(1337 + depth + len(starts))
      for tpl in templates:
        for _ in range(2):
          cc = []
          for (a, b) in tpl:
            da = rng.choice([-2, -1, 0, 1, 2])
            db = rng.choice([-1, 0, 1, 2, 3])
            aa = a + da
            bb = b + db
            if bb - aa < 3:
              bb = aa + 3
            cc.append((aa, bb))
          candidates.append(cc)
      # Random cap-sets to diversify search
      for _ in range(trials_per_combo):
        caps = []
        for _i in range(max(4, len(starts))):
          a = random.randint(min_s - 2, max_s + 1)
          b = a + random.randint(3, 6)
          caps.append((a, b))
        candidates.append(caps)

      for interleave in (False, True):
        for caps_before in (False, True):
          for caps in candidates:
            seq = generate_recursive(starts, caps, depth, interleave=interleave, caps_before=caps_before)
            if len(seq) == 0 or len(seq) > max_intervals:
              continue
            ordered_seq, colors, omega = best_ordered_seq(seq)
            if omega <= 0:
              continue
            score = colors / omega
            if score > best_score + 1e-12 or (abs(score - best_score) < 1e-12 and len(ordered_seq) < len(best_seq or [])):
              best_seq = ordered_seq
              best_score = score
              best_meta = ("starts=%s depth=%d interleave=%s caps_before=%s caps=%s" % (
                              starts, depth, interleave, caps_before, caps), colors, omega, len(ordered_seq))
>>>>>>> REPLACE

</DIFF>