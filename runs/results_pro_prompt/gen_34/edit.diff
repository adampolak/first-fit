--- a/original.py
+++ b/original.py
@@ -1,428 +1,490 @@
 # EVOLVE-BLOCK-START
 
 def construct_intervals():
   """
   Construct a sequence of intervals of real line,
   in the order in which they are presented to FirstFit,
   so that it maximizes the number of colors used by FirstFit
   divided by the maximum number of intervals that cover a single point
 
   The implementation is a cross-over of two strategies:
   - fractal/tile recursive construction
   - caching-based evaluation with multiple anchor strategies
   Returns:
     intervals: list of tuples, each tuple (l, r) represents an open interval [l, r)
   """
   import random
   from dataclasses import dataclass
   from typing import List, Tuple, Iterable
 
   random.seed(0)
 
   # -------------------- Utilities --------------------
 
   Interval = Tuple[float, float]
 
   def overlaps(a: Interval, b: Interval) -> bool:
     # Open intervals overlap iff a.l < b.r and b.l < a.r
     return a[0] < b[1] and b[0] < a[1]
 
   def clique_number(intervals: List[Interval]) -> int:
     # Sweep-line; ends before starts on ties (open intervals)
     events = []
     for (l, r) in intervals:
       events.append((l, 1))
       events.append((r, -1))
     events.sort(key=lambda x: (x[0], x[1]))
     active = 0
     best = 0
     for _, delta in events:
       active += delta
       if active > best:
         best = active
     return best
 
   def firstfit_color_count(intervals: List[Interval]) -> int:
     # Plain FirstFit with given order
     color_blocks: List[List[Interval]] = []
     for (l, r) in intervals:
       placed = False
       for block in color_blocks:
         conflict = False
         for (pl, pr) in block:
           if pl < r and l < pr:
             conflict = True
             break
         if not conflict:
           block.append((l, r))
           placed = True
           break
       if not placed:
         color_blocks.append([(l, r)])
     return len(color_blocks)
 
   # -------------------- Orderings --------------------
 
   def order_fractal(seq: List[Interval]) -> List[Interval]:
     return list(seq)
 
   def order_reversed(seq: List[Interval]) -> List[Interval]:
     return list(reversed(seq))
 
   def order_left_first(seq: List[Interval]) -> List[Interval]:
     return sorted(seq, key=lambda x: (x[0], x[1]))
 
   def order_right_first(seq: List[Interval]) -> List[Interval]:
     return sorted(seq, key=lambda x: (-x[0], -x[1]))
 
   def order_short_first(seq: List[Interval]) -> List[Interval]:
     return sorted(seq, key=lambda x: (x[1] - x[0], x[0]))
 
   def order_long_first(seq: List[Interval]) -> List[Interval]:
     return sorted(seq, key=lambda x: (-(x[1] - x[0]), x[0]))
 
   def order_hybrid_blockwise(seq: List[Interval]) -> List[Interval]:
     # Partition into 4 blocks and apply different local orders to each block
     n = len(seq)
     if n < 12:
       return list(seq)
     k = 4
     b = n // k
     parts = [list(seq[i * b:(i + 1) * b]) for i in range(k - 1)]
     parts.append(list(seq[(k - 1) * b:]))
     out = []
     out += parts[0]  # keep original local
     if len(parts) > 1:
       out += order_left_first(parts[1])
     if len(parts) > 2:
       out += list(reversed(parts[2]))
     if len(parts) > 3:
       out += order_short_first(parts[3])
     return out
 
   def order_by_right_endpoint(seq: List[Interval]) -> List[Interval]:
     return sorted(seq, key=lambda x: (x[1], x[0]))
 
   ORDERERS = [
     ("fractal", order_fractal),
     ("reversed", order_reversed),
     ("left_first", order_left_first),
     ("right_first", order_right_first),
     ("short_first", order_short_first),
     ("long_first", order_long_first),
     ("hybrid_blockwise", order_hybrid_blockwise),
     ("right_endpoint", order_by_right_endpoint),
   ]
 
   # -------------------- Adversarial orderer --------------------
 
   def adversarial_order(seq: List[Interval]) -> List[Interval]:
     """
     Bitset-based adaptive adversary: at each step choose the interval that blocks
     all currently used colors if possible (forcing a new color). Break ties by
     maximizing future coverage (# of remaining intervals it intersects).
     If none can force a new color, choose one that blocks the most colors.
     """
     n = len(seq)
     if n == 0:
       return []
 
     # Precompute adjacency bitsets (Python int as bitset)
     # Map index -> bit position
     neighbors = [0] * n
     for i in range(n):
       li, ri = seq[i]
       mask = 0
       # Only consider j>i then mirror
       for j in range(i + 1, n):
         lj, rj = seq[j]
         if li < rj and lj < ri:
           mask |= (1 << j)
           neighbors[j] |= (1 << i)
       neighbors[i] |= mask
 
     unplaced = set(range(n))
     # color_sets[c] is bitset of indices colored with color c (0-based)
     color_sets: List[int] = []
     assigned_color = [-1] * n
     order_indices = []
 
     # Helper: how many currently used colors are blocked by interval i
     def blocked_color_count(i: int) -> int:
       ni = neighbors[i]
       cnt = 0
       for cmask in color_sets:
         if (ni & cmask) != 0:
           cnt += 1
       return cnt
 
     # Helper: will interval i force a new color now?
     def forces_new_color(i: int) -> bool:
       ni = neighbors[i]
       for cmask in color_sets:
         if (ni & cmask) == 0:
           return False
       return True
 
     # Helper: future coverage among unplaced
     def future_coverage(i: int) -> int:
       # Intersections with unplaced excluding self if present
       ni = neighbors[i]
       mask_unplaced = 0
       for j in unplaced:
         mask_unplaced |= (1 << j)
       cover = (ni & mask_unplaced)
       if i in unplaced:
         cover &= ~(1 << i)
       return cover.bit_count()
 
     # Assign FirstFit color for i w.r.t. current color_sets
     def assign_color(i: int) -> int:
       ni = neighbors[i]
       for c, cmask in enumerate(color_sets):
         if (ni & cmask) == 0:
           assigned_color[i] = c
           color_sets[c] |= (1 << i)
           return c
       # Create new color
       assigned_color[i] = len(color_sets)
       color_sets.append(1 << i)
       return assigned_color[i]
 
     # Main loop
     while unplaced:
       best_i = None
       best_key = None
       used_colors = len(color_sets)
 
       # Pre-compose mask of unplaced for coverage metric
       mask_unplaced = 0
       for j in unplaced:
         mask_unplaced |= (1 << j)
 
       for i in list(unplaced):
         # Compute metrics
         block_cnt = 0
         ni = neighbors[i]
         for cmask in color_sets:
           if (ni & cmask) != 0:
             block_cnt += 1
         new_color = (block_cnt == used_colors)
         coverage = ((ni & mask_unplaced) & ~(1 << i)).bit_count()
         # Prefer forcing a new color, then more blocked colors, then more coverage, then shorter length
         length = seq[i][1] - seq[i][0]
         key = (1 if new_color else 0, block_cnt, coverage, -length)
         if best_key is None or key > best_key:
           best_key = key
           best_i = i
 
       # Place best_i
       order_indices.append(best_i)
       assign_color(best_i)
       unplaced.remove(best_i)
 
     return [seq[i] for i in order_indices]
+
+  def evaluate_best_order(seq: List[Interval]) -> Tuple[int, List[Interval]]:
+    """
+    Evaluate a sequence across several deterministic orders and an adaptive
+    adversarial ordering; return (best_colors, best_ordered_sequence).
+    """
+    best_colors = -1
+    best_seq = list(seq)
+    # Deterministic orderings
+    for _name, order_fn in ORDERERS:
+      try:
+        s2 = order_fn(seq)
+      except Exception:
+        s2 = seq
+      c2 = firstfit_color_count(s2)
+      if c2 > best_colors:
+        best_colors = c2
+        best_seq = s2
+    # Adaptive adversary ordering
+    try:
+      s_adv = adversarial_order(seq)
+      c_adv = firstfit_color_count(s_adv)
+      if c_adv > best_colors:
+        best_colors = c_adv
+        best_seq = s_adv
+    except Exception:
+      pass
+    return best_colors, best_seq
 
   # -------------------- Fractal/Tiles builder --------------------
 
   def build_fractal(depth: int,
                     starts: Tuple[int, ...],
                     caps: List[Tuple[int, int]],
                     interleave: bool = False,
                     caps_before: bool = False) -> List[Interval]:
     """
     Recursive fractal-like builder:
     - starts: tuple of integer offsets for block copies per level
     - caps: list of (a,b) base intervals appended each level (scaled by delta)
     - interleave: copy order variant
     - caps_before: present caps before copies at each level
     """
     T = [(0.0, 1.0)]
     for _ in range(depth):
       lo = min(l for l, r in T)
       hi = max(r for l, r in T)
       delta = hi - lo
       S = []
       if caps_before:
         for a, b in caps:
           S.append((delta * a, delta * b))
       if interleave:
         for i in range(len(T)):
           li, ri = T[i]
           for s in starts:
             S.append((delta * s + li - lo, delta * s + ri - lo))
       else:
         for start in starts:
           S += [(delta * start + l - lo, delta * start + r - lo) for l, r in T]
       if not caps_before:
         for a, b in caps:
           S.append((delta * a, delta * b))
       T = S
     return [(l, r) for (l, r) in T]  # already normalized in process
 
   # Baseline original construction (safe fallback)
   def original():
     T = [(0.0, 1.0)]
     for _ in range(4):
       lo = min(l for l, r in T)
       hi = max(r for l, r in T)
-      delta = hi - los
+      delta = hi - lo
       S = []
       for start in (2, 6, 10, 14):
         S += [(delta * start + l - lo, delta * start + r - lo) for l, r in T]
       S += [
         (delta * 1, delta * 5),
         (delta * 12, delta * 16),
         (delta * 4, delta * 9),
         (delta * 8, delta * 13)
       ]
       T = S
     return T
 
   # The above uses a variety of utilities; to keep robust, we implement a safe baseline
   def original_safe():
     T = [(0.0, 1.0)]
     for _ in range(4):
       lo = min(l for l, r in T)
       hi = max(r for l, r in T)
       delta = hi - lo
       S = []
       for start in (2, 6, 10, 14):
         S += [(delta * start + l - lo, delta * start + r - lo) for l, r in T]
       S += [
         (delta * 1, delta * 5),
         (delta * 12, delta * 16),
         (delta * 4, delta * 9),
         (delta * 8, delta * 13)
       ]
       T = S
     return T
 
   best_seq = None
   best_score = -1.0
   best_meta = None
   max_intervals = 3200
 
+  # Keep a small pool of best candidates by simple (fractal-order) score
+  top_k = 6
+  top_entries: List[Tuple[float, int, int, int, List[Interval]]] = []
+
+  def push_candidate(seq: List[Interval], colors: int, omega: int):
+    score = colors / omega if omega > 0 else 0.0
+    top_entries.append((score, colors, omega, len(seq), seq))
+    top_entries.sort(key=lambda x: (-x[0], x[3]))
+    if len(top_entries) > top_k:
+      del top_entries[top_k:]
+
   # Variation space
   starts_options = [
     (2, 6, 10, 14),
     (3, 7, 11, 15),
+    (4, 8, 12, 16),
+    (2, 5, 9, 13),
+    (3, 6, 9, 12),
     (2, 6, 10, 14, 18),
     (2, 6, 10, 14, 18, 22),
     (3, 7, 11, 15, 19),
   ]
   depth_options = [3, 4, 5]
   trials_per_combo = 60
 
   # Baseline evaluation
   baseline = original_safe()
   baseline_colors = firstfit_color_count(baseline)
   baseline_omega = clique_number(baseline)
   if baseline_omega > 0:
     best_seq = baseline
     best_score = baseline_colors / baseline_omega
     best_meta = ("baseline", baseline_colors, baseline_omega, len(baseline))
+    push_candidate(baseline, baseline_colors, baseline_omega)
 
   # Alt anchor variant (3,7,11,15)
   def original_alt():
     T = [(0.0, 1.0)]
     for _ in range(4):
       lo = min(l for l, r in T)
       hi = max(r for l, r in T)
       delta = hi - lo
       S = []
       for start in (3, 7, 11, 15):
         S += [(delta * start + l - lo, delta * start + r - lo) for l, r in T]
       S += [
         (delta * 1, delta * 5),
         (delta * 12, delta * 16),
         (delta * 4, delta * 9),
         (delta * 8, delta * 13)
       ]
       T = S
     return T
 
   alt = original_alt()
   alt_colors = firstfit_color_count(alt)
   alt_omega = clique_number(alt)
   if alt_omega > 0:
     alt_score = alt_colors / alt_omega
+    push_candidate(alt, alt_colors, alt_omega)
     if alt_score > best_score + 1e-12:
       best_seq = alt
       best_score = alt_score
       best_meta = ("alt_anchor=(3,7,11,15)", alt_colors, alt_omega, len(alt))
 
   # Exploration over combinations
   for starts in starts_options:
     for depth in depth_options:
       # rough estimate of produced size; prune if exceeds budget
       p_est = max(4, len(starts))
       est = 1
       for _ in range(depth):
         est = len(starts) * est + p_est
         if est > max_intervals:
           break
       if est > max_intervals:
         continue
 
       min_s = min(starts)
       max_s = max(starts)
 
       cap_heur = []
       for i in range(len(starts)):
         if i == 0:
           a = starts[0] - 1
           b = starts[0] + 3
         elif i == len(starts) - 1:
           a = starts[i - 1] + 2
           b = starts[i] + 2
         else:
           a = starts[i - 1] + 2
           b = starts[i] + 3
         cap_heur.append((a, b))
 
       candidates = [cap_heur]
       # deterministic-ish jitter around templates
       rng = random.Random(1337)
       for _ in range(trials_per_combo):
         caps = []
         for _i in range(max(4, len(starts))):
           a = rng.randint(min_s - 2, max_s + 1)
           b = a + rng.randint(3, 6)
           caps.append((a, b))
         candidates.append(caps)
 
       for interleave in (False, True):
         for caps_before in (False, True):
           for caps in candidates:
             seq = build_fractal(depth, starts, caps, interleave=interleave, caps_before=caps_before)
             if len(seq) == 0 or len(seq) > max_intervals:
               continue
             omega = clique_number(seq)
             if omega <= 0:
               continue
             colors = firstfit_color_count(seq)
             score = colors / omega
+            push_candidate(seq, colors, omega)
             if score > best_score + 1e-12 or (abs(score - best_score) < 1e-12 and len(seq) < len(best_seq or [])):
               best_seq = seq
               best_score = score
               best_meta = ("starts=%s depth=%d interleave=%s caps_before=%s caps=%s" % (
                               starts, depth, interleave, caps_before, caps), colors, omega, len(seq))
 
-  if best_seq is None:
-    best_seq = original_safe()
-
-  # Print the validation line
-  if best_meta is None:
-    best_meta = ("unknown", 0, 0, 0)
-  best_desc, best_colors, best_omega, best_n = best_meta
-  ratio = best_colors / best_omega if best_omega > 0 else 0.0
-  print(f"construct_intervals: depth=0, order={best_desc}, n={best_n}, FirstFit={best_colors}, OPT={best_omega}, ratio={ratio:.3f}")
-
-  return best_seq
+  # Final refinement: evaluate best orderings (including adversarial) on the top candidates
+  final_seq = None
+  final_meta = None
+  final_ratio = -1.0
+
+  # Ensure at least the current best is considered
+  if best_seq is not None:
+    omega_best = clique_number(best_seq)
+    push_candidate(best_seq, firstfit_color_count(best_seq), omega_best)
+
+  for score, colors_est, omega, n, seq_raw in top_entries:
+    colors_ord, seq_ord = evaluate_best_order(seq_raw)
+    ratio = colors_ord / omega if omega > 0 else 0.0
+    if ratio > final_ratio + 1e-12 or (abs(ratio - final_ratio) < 1e-12 and len(seq_ord) < len(final_seq or [])):
+      final_ratio = ratio
+      final_seq = seq_ord
+      final_meta = ("refined", colors_ord, omega, len(seq_ord))
+
+  if final_seq is None:
+    final_seq = original_safe()
+    omega0 = clique_number(final_seq)
+    colors0 = firstfit_color_count(final_seq)
+    final_meta = ("fallback", colors0, omega0, len(final_seq))
+
+  desc, ff_colors, opt_val, n_intervals = final_meta
+  print(f"construct_intervals: depth=0, order={desc}, n={n_intervals}, FirstFit={ff_colors}, OPT={opt_val}, ratio={ff_colors/opt_val if opt_val>0 else 0.0:.3f}")
+
+  return final_seq
 
 # EVOLVE-BLOCK-END
 
 def run_experiment(**kwargs):
   """Main called by evaluator"""
   return construct_intervals()