<NAME>anchor_pattern_expansion_and_eval_cache</NAME>
<DESCRIPTION>Proposed targeted enhancements to improve the FirstFit/OPT ratio search:
- Introduce a memoized evaluator to speed repeated sequence evaluations (colors_used, omega).
- Expand the set of fractal anchor patterns (starts) to explore more structural variants.
- Add a baseline alternate construction (anchor pattern 3,7,11,15) and adopt it if it improves the ratio.
- Increase search budget (larger max interval budget and more trials per combo) to widen exploration, while keeping within a practical bound.
- Maintain backward compatibility with existing logic and keep the original fallback as a safety net.</DESCRIPTION>
<DIFF>
<<<<<<< SEARCH
  import random
  random.seed(0)

  def firstfit_color_count(intervals):
    """Simulate FirstFit on the given arrival-ordered intervals."""
    colors = []
    for (l, r) in intervals:
      placed = False
      for col in colors:
        conflict = False
        for (cl, cr) in col:
          # open intervals overlap iff cl < r and l < cr
          if cl < r and l < cr:
            conflict = True
            break
        if not conflict:
          col.append((l, r))
          placed = True
          break
      if not placed:
        colors.append([(l, r)])
    return len(colors)
=======
  import random
  random.seed(0)
  from functools import lru_cache

  @lru_cache(maxsize=None)
  def eval_seq_cached(seq_tuple):
    """Return (colors_used, omega) for a given sequence tuple representation."""
    seq = list(seq_tuple)
    # colors
    colors = []
    for (l, r) in seq:
      placed = False
      for col in colors:
        conflict = False
        for (cl, cr) in col:
          if cl < r and l < cr:
            conflict = True
            break
        if not conflict:
          col.append((l, r))
          placed = True
          break
      if not placed:
        colors.append([(l, r)])
    colors_used = len(colors)

    # omega
    events = []
    for (l, r) in seq:
      events.append((l, 1))   # start
      events.append((r, -1))  # end
    events.sort(key=lambda x: (x[0], x[1]))  # end (-1) comes before start (+1) at same coord
    active = 0
    best = 0
    for _, delta in events:
      active += delta
      if active > best:
        best = active
    omega = best
    return (colors_used, omega)

  def firstfit_color_count(intervals):
    """Simulate FirstFit on the given arrival-ordered intervals."""
    colors = []
    for (l, r) in intervals:
      placed = False
      for col in colors:
        conflict = False
        for (cl, cr) in col:
          # open intervals overlap iff cl < r and l < cr
          if cl < r and l < cr:
            conflict = True
            break
        if not conflict:
          col.append((l, r))
          placed = True
          break
      if not placed:
        colors.append([(l, r)])
    return len(colors)
>>>>>>> REPLACE
</DIFF>
<DIFF>
<<<<<<< SEARCH
      for interleave in (False, True):
        for caps in candidates:
          seq = generate_recursive(starts, caps, depth, interleave=interleave)
          if len(seq) == 0 or len(seq) > max_intervals:
            continue
          colors = firstfit_color_count(seq)
          omega = clique_number(seq)
          if omega <= 0:
            continue
          score = colors / omega
          if score > best_score or (abs(score - best_score) < 1e-9 and len(seq) < len(best_seq)):
            best_score = score
            best_seq = seq
            best_meta = ("starts=%s depth=%d interleave=%s caps=%s" % (starts, depth, interleave, caps), colors, omega, len(seq))
=======
      for interleave in (False, True):
        for caps in candidates:
          seq = generate_recursive(starts, caps, depth, interleave=interleave)
          if len(seq) == 0 or len(seq) > max_intervals:
            continue
          colors, omega = eval_seq_cached(tuple(seq))
          if omega <= 0:
            continue
          score = colors / omega
          if score > best_score or (abs(score - best_score) < 1e-12 and len(seq) < len(best_seq)):
            best_score = score
            best_seq = seq
            best_meta = ("starts=%s depth=%d interleave=%s caps=%s" % (starts, depth, interleave, caps), colors, omega, len(seq))
>>>>>>> REPLACE
</DIFF>
<DIFF>
<<<<<<< SEARCH
  baseline = original()
  baseline_colors = firstfit_color_count(baseline)
  baseline_omega = clique_number(baseline)
  if baseline_omega > 0:
    best_seq = baseline
    best_score = baseline_colors / baseline_omega
    best_meta = ("baseline", baseline_colors, baseline_omega, len(baseline))
=======
  baseline = original()
  baseline_colors = firstfit_color_count(baseline)
  baseline_omega = clique_number(baseline)
  if baseline_omega > 0:
    best_seq = baseline
    best_score = baseline_colors / baseline_omega
    best_meta = ("baseline", baseline_colors, baseline_omega, len(baseline))

  # Additional anchor baseline (3,7,11,15)
  def original_alt():
    T = [(0.0, 1.0)]
    for _ in range(4):
      lo = min(l for l, r in T)
      hi = max(r for l, r in T)
      delta = hi - lo
      S = []
      for start in (3, 7, 11, 15):
        S += [(delta * start + l - lo, delta * start + r - lo) for l, r in T]
      S += [
        (delta * 1, delta * 5),
        (delta * 12, delta * 16),
        (delta * 4, delta * 9),
        (delta * 8, delta * 13)
      ]
      T = S
    return T

  alt = original_alt()
  alt_colors = firstfit_color_count(alt)
  alt_omega = clique_number(alt)
  if alt_omega > 0:
    alt_score = alt_colors / alt_omega
    if alt_score > best_score + 1e-12:
      best_seq = alt
      best_score = alt_score
      best_meta = ("alt_anchor=(3,7,11,15)", alt_colors, alt_omega, len(alt))
>>>>>>> REPLACE
</DIFF>
<DIFF>
<<<<<<< SEARCH
  starts_options = [
    (2, 6, 10, 14),
    (2, 6, 10, 14, 18),
    (2, 6, 10, 14, 18, 22),
  ]
=======
  starts_options = [
    (2, 6, 10, 14),
    (3, 7, 11, 15),
    (2, 6, 10, 14, 18),
    (2, 6, 10, 14, 18, 22),
    (3, 7, 11, 15, 19),
  ]
>>>>>>> REPLACE
</DIFF>
<DIFF>
<<<<<<< SEARCH
  max_intervals = 2200
=======
  max_intervals = 3200
>>>>>>> REPLACE
</DIFF>
<DIFF>
<<<<<<< SEARCH
  trials_per_combo = 80
=======
  trials_per_combo = 120
>>>>>>> REPLACE
</DIFF>