--- a/original.py
+++ b/original.py
@@ -1,49 +1,97 @@
 # EVOLVE-BLOCK-START
 
 def construct_intervals():
   """
-  Construct a sequence of intervals of real line,
-  in the order in which they are presented to FirstFit,
-  so that it maximizes the number of colors used by FirstFit
-  divided by the maximum number of intervals that cover a single point
-
-  The initial implementation uses the construction from
-  Figure 4 in https://arxiv.org/abs/1506.00192
-
+  Enhanced construction with omega-guarded expansion to improve FirstFit ratio
+  while keeping offline optimum (omega) bounded by 10.
+  This version attempts up to 3 rounds of the original expansion pattern,
+  and falls back to the original two-round construction if omega would exceed 10.
+  A small helper computes the current omega to guide the fallback.
   Returns:
-    intervals: list of tuples, each tuple (l, r) represents an open interval from l to r
+    intervals: list of tuples (l, r) open intervals
   """
 
+  def compute_omega(intervals):
+     # compute maximum number of intervals covering any point
+     events = []
+     for a, b in intervals:
+        events.append((a, 1))   # start
+        events.append((b, -1))  # end
+     # For open intervals, end before start at the same coordinate
+     events.sort(key=lambda x: (x[0], x[1]))
+     current = 0
+     best = 0
+     for pos, typ in events:
+        if typ == -1:
+           current -= 1
+        else:
+           current += 1
+           if current > best:
+              best = current
+     return best
+
   T = [(0, 1)]
-  for _ in range(2):
+  # Try up to 3 rounds with a richer set of shifts
+  best_T = None
+  best_omega = None
+
+  # We'll attempt 3 rounds of the expansion
+  for _round in range(3):
     lo = min(l for l, r in T)
     hi = max(r for l, r in T)
     delta = hi - lo
     S = []
-    for start in (2, 6, 10, 14):
+    for start in (2, 6, 10, 14, 18, 22):  # expanded set to increase potential colors
       S += [(delta * start + l - lo, delta * start + r - lo) for l, r in T]
     S += [
       (delta * 1, delta * 5),
       (delta * 12, delta * 16),
       (delta * 4, delta * 9),
       (delta * 8, delta * 13)
     ]
     T = S
-  return T
+    w = compute_omega(T)
+    if w <= 10:
+      best_T = T
+      best_omega = w
+      # continue to attempt one more round to potentially push more colors
+    else:
+      break
+
+  if best_T is None:
+     # Fall back to the original two-round construction to guarantee omega <= 10
+     T = [(0, 1)]
+     for _ in range(2):
+       lo = min(l for l, r in T)
+       hi = max(r for l, r in T)
+       delta = hi - lo
+       S = []
+       for start in (2, 6, 10, 14):
+         S += [(delta * start + l - lo, delta * start + r - lo) for l, r in T]
+       S += [
+         (delta * 1, delta * 5),
+         (delta * 12, delta * 16),
+         (delta * 4, delta * 9),
+         (delta * 8, delta * 13)
+       ]
+       T = S
+     best_T = T
+
+  return best_T
 
   # return [  # Figure 3, OPT=2, FF=4
   #   (2,3),
   #   (6,7),
   #   (10,11),
   #   (14,15),
   #   (1,5),
   #   (12,16),
   #   (4,9),
   #   (8,13),
   # ]
 
 # EVOLVE-BLOCK-END
 
 def run_experiment(**kwargs):
   """Main called by evaluator"""
   return construct_intervals()