<NAME>
chained_connectors_mblock
</NAME>

<DESCRIPTION>
Checklist:
- Generalize the 4-block gadget to m-block chained expansions with sliding connectors to couple colors across all blocks.
- Add an omega guard and size guard to keep offline optimum ≤ 10 and total intervals modest.
- Grid-search over candidate widths (m) and up to 4 rounds; pick the largest valid construction as a proxy for higher FirstFit usage.
- Retain a robust fallback to the original 2-round gadget if no candidate survives the constraints.

Rationale:
The new expand_once uses four sliding families of short “connector” intervals that bridge adjacent replicated blocks throughout the chain, ensuring that later arrivals overlap representatives from many earlier colors, pushing FirstFit upward, while keeping clique number bounded. We search over m in {9,8,7,6} and up to 4 rounds, selecting the largest sequence under omega ≤ 10 and a conservative 6k interval cap to balance the combined score. Fallback preserves the prior behavior.

Validation:
- Omega is checked after each round; the best valid T is retained.
- Connectors are O(m) per round, keeping omega small and tightly controlled.
- Intervals remain well under 10,000.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
def construct_intervals():
  """
  Enhanced construction with omega-guarded expansion to improve FirstFit ratio
  while keeping offline optimum (omega) bounded by 10.
  This version attempts up to 3 rounds of the original expansion pattern,
  and falls back to the original two-round construction if omega would exceed 10.
  A small helper computes the current omega to guide the fallback.
  Returns:
    intervals: list of tuples (l, r) open intervals
  """

  def compute_omega(intervals):
     # compute maximum number of intervals covering any point
     events = []
     for a, b in intervals:
        events.append((a, 1))   # start
        events.append((b, -1))  # end
     # For open intervals, end before start at the same coordinate
     events.sort(key=lambda x: (x[0], x[1]))
     current = 0
     best = 0
     for pos, typ in events:
        if typ == -1:
           current -= 1
        else:
           current += 1
           if current > best:
              best = current
     return best

  T = [(0, 1)]
  # Try up to 3 rounds with a richer set of shifts
  best_T = None
  best_omega = None

  # We'll attempt 3 rounds of the expansion
  for _round in range(3):
    lo = min(l for l, r in T)
    hi = max(r for l, r in T)
    delta = hi - lo
    S = []
    for start in (2, 6, 10, 14, 18, 22):  # expanded set to increase potential colors
      S += [(delta * start + l - lo, delta * start + r - lo) for l, r in T]
    S += [
      (delta * 1, delta * 5),
      (delta * 12, delta * 16),
      (delta * 4, delta * 9),
      (delta * 8, delta * 13)
    ]
    T = S
    w = compute_omega(T)
    if w <= 10:
      best_T = T
      best_omega = w
      # continue to attempt one more round to potentially push more colors
    else:
      break

  if best_T is None:
     # Fall back to the original two-round construction to guarantee omega <= 10
     T = [(0, 1)]
     for _ in range(2):
       lo = min(l for l, r in T)
       hi = max(r for l, r in T)
       delta = hi - lo
       S = []
       for start in (2, 6, 10, 14):
         S += [(delta * start + l - lo, delta * start + r - lo) for l, r in T]
       S += [
         (delta * 1, delta * 5),
         (delta * 12, delta * 16),
         (delta * 4, delta * 9),
         (delta * 8, delta * 13)
       ]
       T = S
     best_T = T

  return best_T

  # return [  # Figure 3, OPT=2, FF=4
  #   (2,3),
  #   (6,7),
  #   (10,11),
  #   (14,15),
  #   (1,5),
  #   (12,16),
  #   (4,9),
  #   (8,13),
  # ]
=======
def construct_intervals():
  """
  Omega-guarded, chained multi-block expansion to improve FirstFit ratio
  while keeping offline optimum (omega) bounded by 10.
  We generalize the 4-block gadget to m blocks per round with sliding connectors
  that couple colors across all blocks. We search over several widths (m) and
  up to 4 rounds and choose the largest valid construction (proxy for higher FF),
  with a strict omega cap and size bound. A robust fallback preserves the
  original two-round construction if needed.
  Returns:
    intervals: list of tuples (l, r) open intervals
  """

  def compute_omega(intervals):
    # compute maximum number of intervals covering any point
    events = []
    for a, b in intervals:
      events.append((a, 1))   # start
      events.append((b, -1))  # end
    # For open intervals, end before start at the same coordinate
    events.sort(key=lambda x: (x[0], x[1]))
    current = 0
    best = 0
    for _, typ in events:
      if typ == -1:
        current -= 1
      else:
        current += 1
        if current > best:
          best = current
    return best

  def expand_once(T, m):
    # Replicate T at m shifted positions and add sliding connector families
    lo = min(l for l, r in T)
    hi = max(r for l, r in T)
    delta = hi - lo
    S = []
    # m replicated blocks at starts 2,6,10,..., (4m-2)
    for i in range(m):
      start = 4 * i + 2
      S += [(delta * start + l - lo, delta * start + r - lo) for l, r in T]
    # Sliding connectors: four short families that couple adjacent blocks
    # Family A: (4i+1, 4i+5), i = 0..m-2
    for i in range(max(0, m - 1)):
      S.append((delta * (4 * i + 1), delta * (4 * i + 5)))
    # Family B: (4i+4, 4i+9), i = 0..m-3
    for i in range(max(0, m - 2)):
      S.append((delta * (4 * i + 4), delta * (4 * i + 9)))
    # Family C and D only when m >= 4 to avoid overshooting omega early
    if m >= 4:
      # Family C: (4i+8, 4i+13), i = 0..m-4
      for i in range(max(0, m - 3)):
        S.append((delta * (4 * i + 8), delta * (4 * i + 13)))
      # Family D: (4i+12, 4i+16), i = 0..m-4
      for i in range(max(0, m - 3)):
        S.append((delta * (4 * i + 12), delta * (4 * i + 16)))
    return S

  # Search over widths and rounds under omega<=10 and size constraint
  candidate_widths = [9, 8, 7, 6]
  max_rounds = 4
  max_n = 6000  # keep constructions compact for better combined score
  best_T = None
  best_w = None

  for m in candidate_widths:
    T = [(0, 1)]
    local_best_T = None
    local_best_w = None
    for _ in range(max_rounds):
      T = expand_once(T, m)
      if len(T) > max_n:
        break
      w = compute_omega(T)
      if w <= 10:
        local_best_T = list(T)
        local_best_w = w
      else:
        break
    # prefer larger sequences under the omega cap; tie-break by larger omega (harder)
    if local_best_T is not None:
      if (best_T is None or
          len(local_best_T) > len(best_T) or
          (len(local_best_T) == len(best_T) and (best_w is None or local_best_w > best_w))):
        best_T = local_best_T
        best_w = local_best_w

  if best_T is None:
    # Fall back to the original two-round construction to guarantee omega <= 10
    T = [(0, 1)]
    for _ in range(2):
      lo = min(l for l, r in T)
      hi = max(r for l, r in T)
      delta = hi - lo
      S = []
      for start in (2, 6, 10, 14):
        S += [(delta * start + l - lo, delta * start + r - lo) for l, r in T]
      S += [
        (delta * 1, delta * 5),
        (delta * 12, delta * 16),
        (delta * 4, delta * 9),
        (delta * 8, delta * 13)
      ]
      T = S
    best_T = T

  return best_T

  # return [  # Figure 3, OPT=2, FF=4
  #   (2,3),
  #   (6,7),
  #   (10,11),
  #   (14,15),
  #   (1,5),
  #   (12,16),
  #   (4,9),
  #   (8,13),
  # ]
>>>>>>> REPLACE

</DIFF>