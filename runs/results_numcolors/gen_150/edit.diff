--- a/original.py
+++ b/original.py
@@ -1,73 +1,147 @@
 # EVOLVE-BLOCK-START
 
 def construct_intervals():
   """
   Construct a sequence of intervals of real line,
   in the order in which they are presented to FirstFit,
   so that it maximizes the number of colors used by FirstFit
   divided by the maximum number of intervals that cover a single point
 
   The initial implementation uses the construction from
   Figure 4 in https://arxiv.org/abs/1506.00192
 
   Returns:
     intervals: list of tuples, each tuple (l, r) represents an open interval from l to r
   """
 
-  # Cycle through multiple start-pattern templates to break periodic reuse
-  start_patterns = [(2, 6, 10, 14), (1, 5, 9, 13), (3, 7, 11, 15), (2, 4, 8, 12)]
+  # Capacity guard to keep total intervals < 10000 and allow a thin micro-phase
+  CAP = 9800
+  RESERVE = 200  # reserve budget for the micro-phase
+
+  # Classic KT starts (keeps omega small while sustaining FF pressure)
+  spine_starts = (2, 6, 10, 14)
+
+  # Stage 1: Sequential KT-style spine (no interleaving)
   T = [(0, 1)]
   for round_idx in range(6):
+    # Predict next size: sz -> 4*sz + 4; keep room for micro-phase
+    nxt_size = 4 * len(T) + 4
+    if nxt_size > CAP - RESERVE:
+      break
+
     lo = min(l for l, r in T)
     hi = max(r for l, r in T)
     delta = hi - lo
-    # choose the start tuple for this round
-    starts = start_patterns[round_idx % len(start_patterns)]
-    # build translated blocks
-    blocks = []
-    for start in starts:
-      blocks.append([(delta * start + l - lo, delta * start + r - lo) for l, r in T])
-    # interleave translated blocks to maximize cross-block overlap
+    if delta <= 0:
+      delta = 1
+
     S = []
-    maxlen = max(len(b) for b in blocks)
-    for i in range(maxlen):
-      for blk in blocks:
-        if i < len(blk):
-          S.append(blk[i])
-    # dynamic connectors based on the current starts
-    s0, s1, s2, s3 = starts
+    for s in spine_starts:
+      base = s * delta - lo
+      # Alternate internal order per block to break symmetry without interleaving
+      src = T if ((round_idx + s) % 2 == 0) else list(reversed(T))
+      S.extend((l + base, r + base) for (l, r) in src)
+
+    # Classic connectors (Figure 4 style)
+    s0, s1, s2, s3 = spine_starts
     connectors = [
-      (delta * (s0 - 1), delta * (s1 - 1)),  # left cap
-      (delta * (s2 + 2), delta * (s3 + 2)),  # right cap
-      (delta * (s0 + 2), delta * (s2 - 1)),  # cross 1
-      (delta * (s1 + 2), delta * (s3 - 1)),  # cross 2
+      ((s0 - 1) * delta, (s1 - 1) * delta),  # left cap
+      ((s2 + 2) * delta, (s3 + 2) * delta),  # right cap
+      ((s0 + 2) * delta, (s2 - 1) * delta),  # cross 1
+      ((s1 + 2) * delta, (s3 - 1) * delta),  # cross 2
     ]
-    for a, b in connectors:
-      S.append((a, b))
+    S.extend(connectors)
     T = S
-  # micro-phase: small-scale delta expansion to sprinkle long caps
-  lo = min(l for l, r in T)
-  hi = max(r for l, r in T)
-  delta2 = max(1, (hi - lo) // 4)
-  # create sparse long-range caps overlapping many active colors
-  micro = [(lo + delta2, lo + 5 * delta2), (hi - 6 * delta2, hi - 2 * delta2)]
-  for it in micro:
-    T.append(it)
+
+  # Stage 2: Thin, capacity-guarded micro-round at half-scale
+  remaining = max(0, CAP - len(T))
+  if remaining > 0:
+    def thin_seed(current_T, max_seed):
+      n = len(current_T)
+      if n == 0 or max_seed <= 0:
+        return []
+      step = max(1, n // max_seed)
+      return current_T[::step][:max_seed]
+
+    def micro_round(current_T, budget):
+      if budget <= 0 or not current_T:
+        return []
+
+      glo = min(l for l, r in current_T)
+      ghi = max(r for l, r in current_T)
+      G = max(1, ghi - glo)
+      delta2 = max(1, G // 2)
+
+      # Thin seed size bounded by budget; keep blocks modest
+      per_block_target = max(16, min(64, budget // 8))
+      U = thin_seed(current_T, per_block_target)
+      if not U:
+        return []
+
+      ulo = min(l for l, r in U)
+
+      # Build four translated micro blocks; lightly reverse on parity
+      blocks = []
+      for s in spine_starts:
+        base = s * delta2 - ulo
+        block = [(l + base, r + base) for (l, r) in U]
+        if ((s // 2) % 2) == 1:
+          block.reverse()
+        blocks.append(block)
+
+      # Interleave micro blocks to mix colors across clones
+      micro = []
+      maxlen = max(len(b) for b in blocks)
+      for i in range(maxlen):
+        for blk in blocks:
+          if i < len(blk):
+            micro.append(blk[i])
+
+      # Deterministic connectors at delta2 scale
+      s0, s1, s2, s3 = spine_starts
+      micro.extend([
+        ((s0 - 1) * delta2 + glo, (s1 - 1) * delta2 + glo),  # left cap
+        ((s2 + 2) * delta2 + glo, (s3 + 2) * delta2 + glo),  # right cap
+        ((s0 + 2) * delta2 + glo, (s2 - 1) * delta2 + glo),  # cross 1
+        ((s1 + 2) * delta2 + glo, (s3 - 1) * delta2 + glo),  # cross 2
+      ])
+
+      # Sparse micro caps
+      cap1 = (glo + (delta2 // 4), glo + int(1.6 * delta2))
+      cap2 = (glo + int(0.9 * delta2), glo + int(2.3 * delta2))
+      mid = glo + G // 2
+      cap3 = (mid - max(1, delta2 // 10), mid + max(1, delta2 // 10))
+      for cap in (cap1, cap2, cap3):
+        if cap[1] > cap[0]:
+          micro.append(cap)
+
+      if len(micro) > budget:
+        micro = micro[:budget]
+      return micro
+
+    budget = min(200, remaining)
+    mr = micro_round(T, budget)
+    if mr:
+      room = CAP - len(T)
+      if len(mr) > room:
+        mr = mr[:room]
+      T.extend(mr)
+
   return T
 
   # return [  # Figure 3, OPT=2, FF=4
   #   (2,3),
   #   (6,7),
   #   (10,11),
   #   (14,15),
   #   (1,5),
   #   (12,16),
   #   (4,9),
   #   (8,13),
   # ]
 
 # EVOLVE-BLOCK-END
 
 def run_experiment(**kwargs):
   """Main called by evaluator"""
   return construct_intervals()