<NAME>
parity_interleave_and_fractional_micro
</NAME>

<DESCRIPTION>
I propose three targeted changes to push FirstFit higher while keeping omega at 10:

1) Enable deterministic parity-based interleaving in the KT spine:
   - Interleave blocks on even rounds and reverse block order on odd rounds. This increases color mixing across the four translated blocks without increasing the clique number, in line with known constructions.

2) Inject a tiny set of deterministic long caps near the tail before micro-phases:
   - Three fractional-span caps couple many active colors late in the sequence. This is a standard way to amplify FF while keeping omega stable.

3) Replace the delta2 micro-round with a fractional-window micro-phase:
   - Use four fixed inner windows with a small parity-based shift per iteration, interleave across windows, and add fractional-span connectors. This mirrors successful designs from the literature and our best-performing prior generations.

All changes are CAP-guarded and deterministic. The code remains simple and should restore the 2.30-tier performance observed in prior programs by strengthening cross-scale color coupling.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
  def apply_spine_round(current_T, starts):
    # Compute span and delta
    lo = min(l for l, r in current_T)
    hi = max(r for l, r in current_T)
    delta = hi - lo
    if delta <= 0:
      delta = 1

    # Four translated blocks sequentially (no interleaving)
    S = []
    for s in starts:
      base = s * delta - lo
      S.extend((l + base, r + base) for (l, r) in current_T)

    # Classic connectors (Figure 4 style)
    s0, s1, s2, s3 = starts
    connectors = [
      ((s0 - 1) * delta, (s1 - 1) * delta),  # left cap
      ((s2 + 2) * delta, (s3 + 2) * delta),  # right cap
      ((s0 + 2) * delta, (s2 - 1) * delta),  # cross 1
      ((s1 + 2) * delta, (s3 - 1) * delta),  # cross 2
    ]
    S.extend(connectors)
    return S
=======
  def apply_spine_round(current_T, starts, do_interleave=False, reverse_order=False):
    # Compute span and delta
    lo = min(l for l, r in current_T)
    hi = max(r for l, r in current_T)
    delta = hi - lo
    if delta <= 0:
      delta = 1

    # Build translated blocks
    blocks = []
    for s in starts:
      base = s * delta - lo
      block = [(l + base, r + base) for (l, r) in current_T]
      blocks.append(block)

    # Assemble S with optional interleaving and order control
    S = []
    if do_interleave:
      order = list(range(len(blocks)))
      if reverse_order:
        order.reverse()
      maxlen = max(len(b) for b in blocks)
      for i in range(maxlen):
        for idx in order:
          blk = blocks[idx]
          if i < len(blk):
            S.append(blk[i])
    else:
      if reverse_order:
        blocks = list(reversed(blocks))
      for blk in blocks:
        S.extend(blk)

    # Classic connectors (Figure 4 style)
    s0, s1, s2, s3 = starts
    connectors = [
      ((s0 - 1) * delta, (s1 - 1) * delta),  # left cap
      ((s2 + 2) * delta, (s3 + 2) * delta),  # right cap
      ((s0 + 2) * delta, (s2 - 1) * delta),  # cross 1
      ((s1 + 2) * delta, (s3 - 1) * delta),  # cross 2
    ]
    S.extend(connectors)
    return S
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
  for ridx in range(6):
    # Rotate starts per round to break symmetry
    starts = template_bank[ridx % bank_size]
    # Predict next size: sz -> 4*sz + 4
    nxt_size = 4 * len(T) + 4
    if nxt_size > CAP:
      break
    T = apply_spine_round(T, starts)
=======
  for ridx in range(6):
    # Rotate starts per round to break symmetry
    starts = template_bank[ridx % bank_size]
    # Predict next size: sz -> 4*sz + 4
    nxt_size = 4 * len(T) + 4
    if nxt_size > CAP:
      break
    # Parity-based interleaving: even rounds interleave; odd rounds reverse order
    do_interleave = (ridx % 2 == 0)
    reverse_order = (ridx % 2 == 1)
    T = apply_spine_round(T, starts, do_interleave=do_interleave, reverse_order=reverse_order)
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
  # If we are already near the cap, return the strong baseline.
  if len(T) >= CAP:
    return T

  # Stage 2: Two delta2-driven micro extension rounds (thin sampling; four-start translations).
  # Goals:
  #  - Raise FF pressure via cross-scale coupling and interleaving parity,
  #  - Keep omega in check by using thin seeds and sparse caps/connectors,
  #  - Respect strict capacity guard.

  def thin_seed(current_T, max_seed):
    """Take a thin, evenly spaced sample of current_T of size <= max_seed."""
    n = len(current_T)
    if n == 0 or max_seed <= 0:
      return []
    step = max(1, n // max_seed)
    U = current_T[::step][:max_seed]
    return U

  def micro_round(current_T, round_id, budget):
    if budget <= 0 or not current_T:
      return []

    glo = min(l for l, r in current_T)
    ghi = max(r for l, r in current_T)
    G = max(1, ghi - glo)

    # Use delta2 at half-scale to avoid expanding the global span too aggressively.
    delta2 = max(1, G // 2)

    # Thin seed: bounded and deterministic size to respect budget
    # Keep micro blocks small: target at most ~ (budget//6) per block (four blocks + ~8 extras).
    per_block_target = max(16, min(64, budget // 8))
    U = thin_seed(current_T, per_block_target)

    if not U:
      return []

    # Build four translated blocks using the same 4-start template,
    # with deterministic parity-based interleaving policy:
    # - Rounds with round_id % 2 == 0: forward interleave
    # - Rounds with round_id % 2 == 1: reverse interleave
    starts = spine_starts
    blocks = []
    ulo = min(l for l, r in U)
    for s in starts:
      base = s * delta2 - ulo
      block = [(l + base, r + base) for (l, r) in U]
      # Add a tiny deterministic internal reversal to break symmetry every other block
      if ((s // 2) % 2) == (round_id % 2):
        block = list(reversed(block))
      blocks.append(block)

    micro = []
    if round_id % 2 == 0:
      # Forward interleave
      maxlen = max(len(b) for b in blocks)
      for i in range(maxlen):
        for blk in blocks:
          if i < len(blk):
            micro.append(blk[i])
    else:
      # Reverse interleave (swap block order)
      maxlen = max(len(b) for b in blocks)
      for i in range(maxlen):
        for blk in reversed(blocks):
          if i < len(blk):
            micro.append(blk[i])

    # Deterministic connectors at delta2 scale, including a cross3 extension
    s0, s1, s2, s3 = starts
    connectors = [
      ((s0 - 1) * delta2 + glo, (s1 - 1) * delta2 + glo),  # left cap (localized)
      ((s2 + 2) * delta2 + glo, (s3 + 2) * delta2 + glo),  # right cap
      ((s0 + 2) * delta2 + glo, (s2 - 1) * delta2 + glo),  # cross 1
      ((s1 + 2) * delta2 + glo, (s3 - 1) * delta2 + glo),  # cross 2
      ((s0 + 3) * delta2 + glo, (s3 + 3) * delta2 + glo),  # cross3 (longer range)
      ((s1 + 4) * delta2 + glo, (s2 + 4) * delta2 + glo),  # cross4 (extended coupling)
    ]
    micro.extend(connectors)

    # Sparse micro caps: add three long but safe caps at half-scale
    cap1 = (glo + (delta2 // 4), glo + int(1.8 * delta2))
    cap2 = (glo + int(0.9 * delta2), glo + int(2.6 * delta2))
    mid = glo + G // 2
    cap3 = (mid - max(1, delta2 // 8), mid + max(1, delta2 // 8))
    for cap in (cap1, cap2, cap3):
      if cap[1] > cap[0]:
        micro.append(cap)

    # Enforce budget
    if len(micro) > budget:
      micro = micro[:budget]
    return micro
=======
  # If we are already near the cap, return the strong baseline.
  # Inject a tiny set of long caps near the tail before micro-phases to amplify FF mixing.
  lo = min(l for l, r in T)
  hi = max(r for l, r in T)
  span = max(1, hi - lo)
  def _cap_at(a_frac, b_frac):
    L = lo + max(1, int(round(a_frac * span)))
    R = lo + max(1, int(round(b_frac * span)))
    if R <= L:
      R = L + 1
    return (L, R)
  tail_caps = [_cap_at(0.08, 0.60), _cap_at(0.25, 0.75), _cap_at(0.75, 0.92)]
  for c in tail_caps:
    if len(T) >= CAP:
      break
    T.append(c)
  if len(T) >= CAP - 8:
    return T

  # Stage 2: Fractional-window micro extension rounds (thin sampling; interleaved).
  # Goals:
  #  - Raise FF pressure via cross-scale coupling and interleaving parity,
  #  - Keep omega in check by using thin seeds and fractional-span connectors,
  #  - Respect strict capacity guard.

  def thin_seed(current_T, max_seed):
    """Take a thin, evenly spaced sample of current_T of size <= max_seed."""
    n = len(current_T)
    if n == 0 or max_seed <= 0:
      return []
    step = max(1, n // max_seed)
    U = current_T[::step][:max_seed]
    return U

  def micro_round(current_T, round_id, budget):
    if budget <= 0 or not current_T:
      return []

    glo = min(l for l, r in current_T)
    ghi = max(r for l, r in current_T)
    G = max(1, ghi - glo)

    # Thin seed: bounded and deterministic size to respect budget
    per_block_target = max(16, min(40, budget // 10))
    U = thin_seed(current_T, per_block_target)
    if not U:
      return []

    ulo = min(l for l, r in U)

    # Four fractional windows with a small parity-based shift
    shift = (round_id % 3) * 0.02
    window_fracs = [
      (0.12 + shift, 0.22 + shift),
      (0.35 + shift, 0.45 + shift),
      (0.58 + shift, 0.68 + shift),
      (0.80 + shift, 0.90 + shift),
    ]
    window_fracs = [
      (max(0.05, min(0.90, a)), max(0.10, min(0.95, b)))
      for (a, b) in window_fracs
    ]

    # Build translated micro-blocks aligned to these windows
    blocks = []
    for idx, (fa, fb) in enumerate(window_fracs):
      win_lo = glo + int(round(fa * G))
      base = win_lo - ulo
      block = [(l + base, r + base) for (l, r) in U]
      # Alternate internal reversal by window index and round parity
      if ((idx + round_id) % 2) == 1:
        block = list(reversed(block))
      blocks.append(block)

    # Interleave micro-blocks (reverse order on odd rounds)
    micro = []
    maxlen = max(len(b) for b in blocks)
    order = list(range(len(blocks)))
    if round_id % 2 == 1:
      order.reverse()
    for i in range(maxlen):
      for j in order:
        blk = blocks[j]
        if i < len(blk):
          micro.append(blk[i])

    # Fractional-span connectors at the micro scale
    micro_connectors = [
      (glo + int(round(0.08 * G)), glo + int(round(0.30 * G))),  # left cap
      (glo + int(round(0.60 * G)), glo + int(round(0.92 * G))),  # right cap
      (glo + int(round(0.26 * G)), glo + int(round(0.56 * G))),  # cross 1
      (glo + int(round(0.44 * G)), glo + int(round(0.78 * G))),  # cross 2
    ]
    for a, b in micro_connectors:
      if b > a:
        micro.append((a, b))

    # Enforce budget
    if len(micro) > budget:
      micro = micro[:budget]
    return micro
>>>>>>> REPLACE
</DIFF>