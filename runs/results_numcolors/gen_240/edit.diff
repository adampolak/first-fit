--- a/original.py
+++ b/original.py
@@ -1,262 +1,347 @@
 # EVOLVE-BLOCK-START
 
 def construct_intervals(seed_count=1):
   """
-  Construct a sequence of intervals of real line,
-  in the order in which they are presented to FirstFit,
-  so that it maximizes the number of colors used by FirstFit
-  divided by the maximum number of intervals that cover a single point
-
-  The initial implementation uses the construction from
-  Figure 4 in https://arxiv.org/abs/1506.00192
-
-  Returns:
-    intervals: list of tuples, each tuple (l, r) represents an open interval from l to r
+  Construct a sequence of intervals on the real line, in the order presented to FirstFit,
+  engineered to drive up FirstFit's color usage while keeping the maximum clique (omega) <= ~10.
+
+  Interface compatibility:
+    - Accepts seed_count (unused by evaluator, but supported).
+    - Returns a list of (l, r) integer tuples with r > l (open intervals).
   """
-
-  # Capacity guard to keep the total count under 10000 and allow a micro-phase
   CAP = 9800
 
-  # Rotate among four strong start-pattern templates to couple colors across scales
+  # Rotating start templates (Kiersteadâ€“Trotter style)
   template_bank = [
-    (2, 6, 10, 14),
-    (1, 5, 9, 13),
-    (3, 7, 11, 15),
-    (4, 8, 12, 16),
+    (2, 6, 10, 14),  # classic KT
+    (1, 5, 9, 13),   # left-shifted
+    (3, 7, 11, 15),  # right-shifted
+    (4, 8, 12, 16),  # stretched-right
   ]
 
-  # Seed with multiple disjoint unit intervals if requested (new capability)
+  # Seed: single unit interval (multi-seed support capped defensively)
   if seed_count <= 1:
     T = [(0, 1)]
   else:
     step = 3
-    T = [(i * step, i * step + 1) for i in range(seed_count)]
-
-  # Six KT-style rounds with deterministic parity interleaving
-  for round_idx in range(6):
-    starts = template_bank[round_idx % 4]
-    lo = min(l for l, r in T)
-    hi = max(r for l, r in T)
-    delta = hi - lo if hi > lo else 1
-    # build translated blocks
+    seeds = min(4, max(1, int(seed_count)))
+    T = [(i * step, i * step + 1) for i in range(seeds)]
+
+  def _span_delta(current_T):
+    lo = min(l for l, r in current_T)
+    hi = max(r for l, r in current_T)
+    delta = hi - lo
+    if delta <= 0:
+      delta = 1
+    return lo, hi, delta
+
+  def _append_connectors(S, starts, delta):
+    # Four classic connectors that propagate color pressure without large omega jumps
+    s0, s1, s2, s3 = starts
+    S.append(((s0 - 1) * delta, (s1 - 1) * delta))  # left cap
+    S.append(((s2 + 2) * delta, (s3 + 2) * delta))  # right cap
+    S.append(((s0 + 2) * delta, (s2 - 1) * delta))  # cross 1
+    S.append(((s1 + 2) * delta, (s3 - 1) * delta))  # cross 2
+
+  def _apply_round(current_T, starts, do_interleave=False, reverse_order=False):
+    lo, hi, delta = _span_delta(current_T)
+
+    # Build four translated blocks
     blocks = []
-    for start in starts:
-      blocks.append([(delta * start + l - lo, delta * start + r - lo) for l, r in T])
+    for s in starts:
+      base = s * delta - lo
+      block = [(l + base, r + base) for (l, r) in current_T]
+      blocks.append(block)
+
+    # Compose S with chosen policy
     S = []
-    # interleave blocks on even rounds, sequential on odd rounds
-    if round_idx % 2 == 0:
+    if do_interleave:
+      order = list(range(4))
+      if reverse_order:
+        order.reverse()
       maxlen = max(len(b) for b in blocks)
       for i in range(maxlen):
-        for blk in blocks:
+        for idx in order:
+          blk = blocks[idx]
           if i < len(blk):
             S.append(blk[i])
     else:
-      for blk in blocks:
+      seq_blocks = list(reversed(blocks)) if reverse_order else blocks
+      for blk in seq_blocks:
         S.extend(blk)
-    # connectors based on the active starts
-    s0, s1, s2, s3 = starts
-    connectors = [
-      (delta * (s0 - 1), delta * (s1 - 1)),  # left cap
-      (delta * (s2 + 2), delta * (s3 + 2)),  # right cap
-      (delta * (s0 + 2), delta * (s2 - 1)),  # cross 1
-      (delta * (s1 + 2), delta * (s3 - 1)),  # cross 2
+
+    _append_connectors(S, starts, delta)
+    return S
+
+  # Stage 1: Six KT-style rounds with parity-based interleaving
+  for ridx in range(6):
+    starts = template_bank[ridx % len(template_bank)]
+    do_interleave = (ridx % 2 == 0)          # even: interleave
+    reverse_order = (ridx % 2 == 1)          # odd: reverse sequential
+    T = _apply_round(T, starts, do_interleave=do_interleave, reverse_order=reverse_order)
+    if len(T) >= CAP:
+      return T[:CAP]
+
+  # Micro-phase A: a few long caps near the global span to mix late colors
+  if len(T) < CAP - 8:
+    lo, hi, delta = _span_delta(T)
+    def cap_at(a_frac, b_frac):
+      L = lo + max(1, int(round(a_frac * delta)))
+      R = lo + max(1, int(round(b_frac * delta)))
+      if R <= L:
+        R = L + 1
+      return (L, R)
+    caps = [cap_at(0.08, 0.60), cap_at(0.25, 0.75), cap_at(0.75, 0.92)]
+    room = CAP - len(T)
+    if room > 0:
+      caps = caps[:room]
+      # Insert near the tail to avoid disrupting early structure
+      for i, iv in enumerate(caps):
+        pos = len(T) - (i * 2 + 1)
+        if pos < 0:
+          T.append(iv)
+        else:
+          T.insert(pos, iv)
+
+  if len(T) >= CAP - 16:
+    return T[:CAP]
+
+  # Helper: thin evenly-spaced seed from T
+  def _thin_seed(current_T, max_seed):
+    n = len(current_T)
+    if n == 0 or max_seed <= 0:
+      return []
+    step = max(1, n // max_seed)
+    return current_T[::step][:max_seed]
+
+  # Stage 2: delta2-driven micro rounds using thin evenly-spaced seeds
+  def _build_micro_delta_round(current_T, budget, iter_id=0, alt=False):
+    if not current_T or budget <= 8:
+      return []
+
+    glo = min(l for l, r in current_T)
+    ghi = max(r for l, r in current_T)
+    G = max(1, ghi - glo)
+
+    # Thin seed (slightly larger for alt to strengthen mixing)
+    base_seed = max(8, min(32, len(current_T) // 300))
+    seed_sz = base_seed if not alt else max(8, min(40, len(current_T) // 250))
+    U = _thin_seed(current_T, seed_sz)
+    if not U:
+      return []
+
+    ulo = min(l for l, r in U)
+
+    # Windows with small shifts on primary; distinct family on alt
+    if not alt:
+      shift = (iter_id % 3) * 0.02
+      window_fracs = [
+        (0.12 + shift, 0.22 + shift),
+        (0.35 + shift, 0.45 + shift),
+        (0.58 + shift, 0.68 + shift),
+        (0.80 + shift, 0.90 + shift),
+      ]
+      window_fracs = [(max(0.05, min(0.90, a)), max(0.10, min(0.95, b))) for (a, b) in window_fracs]
+    else:
+      window_fracs = [(0.05, 0.15), (0.28, 0.38), (0.60, 0.70), (0.82, 0.92)]
+
+    blocks = []
+    for (fa, fb) in window_fracs:
+      win_lo = glo + int(round(fa * G))
+      base = win_lo - ulo
+      block = [(l + base, r + base) for (l, r) in U]
+      tag = iter_id if not alt else (iter_id + 1)
+      # Parity-breaking reversal to reduce symmetry
+      if ((int(round(fa * 100)) // 5) + tag) % 2 == 1:
+        block = list(reversed(block))
+      blocks.append(block)
+
+    # Interleave policy depends on tag parity
+    micro = []
+    tag = iter_id if not alt else (iter_id + 1)
+    order = list(range(len(blocks)))
+    if tag % 2 == 1:
+      order.reverse()
+    maxlen = max(len(b) for b in blocks)
+    for i in range(maxlen):
+      for idx in order:
+        blk = blocks[idx]
+        if i < len(blk):
+          micro.append(blk[i])
+
+    # Fractional-span connectors (KT analog) + long-range cross on alt
+    micro_connectors = [
+      (glo + int(round(0.08 * G)), glo + int(round(0.30 * G))),
+      (glo + int(round(0.60 * G)), glo + int(round(0.92 * G))),
+      (glo + int(round(0.26 * G)), glo + int(round(0.56 * G))),
+      (glo + int(round(0.44 * G)), glo + int(round(0.78 * G))),
     ]
-    for a, b in connectors:
-      S.append((a, b))
-    T = S
-
-  # Micro-phase A: add three long-range caps to boost late FirstFit color usage while controlling omega
-  lo = min(l for l, r in T)
-  hi = max(r for l, r in T)
-  delta = hi - lo if hi > lo else 1
-  def cap_at(a_frac, b_frac):
-    l0 = lo + max(1, int(round(a_frac * delta)))
-    r0 = lo + max(1, int(round(b_frac * delta)))
-    return (l0, r0)
-  capA = cap_at(0.08, 0.60)
-  capB = cap_at(0.25, 0.75)
-  capC = cap_at(0.75, 0.92)
-  for cap in (capA, capB, capC):
-    if cap[1] > cap[0]:
-      T.append(cap)
-
-  # Micro-phase B: a thin delta2 micro-round (capacity-guarded) to increase FF colors without raising omega much
-  if len(T) < CAP - 16:
-    glo = min(l for l, r in T)
-    ghi = max(r for l, r in T)
-    G = ghi - glo if ghi > glo else 1
-
-    # Thin seed of current T (small and evenly spaced)
-    seed_sz = max(8, min(32, len(T) // 300))
-    stride = max(1, len(T) // max(1, seed_sz))
-    U = [T[i] for i in range(0, len(T), stride)][:seed_sz]
-
-    if U:
-      ulo = min(l for l, r in U)
-
-      # Four windows across the global span (stay inside to avoid omega spikes)
-      window_fracs = [(0.12, 0.22), (0.35, 0.45), (0.58, 0.68), (0.80, 0.90)]
-      micro_blocks = []
-      for (fa, fb) in window_fracs:
-        win_lo = glo + int(round(fa * G))
-        base = win_lo - ulo
-        block = [(l + base, r + base) for (l, r) in U]
-        micro_blocks.append(block)
-
-      # Interleave the micro-blocks
-      micro = []
-      maxlen = max(len(b) for b in micro_blocks)
-      for i in range(maxlen):
-        for blk in micro_blocks:
-          if i < len(blk):
-            micro.append(blk[i])
-
-      # Fractional-span connectors at the delta2 scale
-      micro_connectors = [
-        (glo + int(round(0.08 * G)), glo + int(round(0.30 * G))),
-        (glo + int(round(0.60 * G)), glo + int(round(0.92 * G))),
-        (glo + int(round(0.26 * G)), glo + int(round(0.56 * G))),
-        (glo + int(round(0.44 * G)), glo + int(round(0.78 * G))),
-      ]
-      for a, b in micro_connectors:
-        if b > a:
-          micro.append((a, b))
-
-      # Capacity guard
-      room = CAP - len(T)
-      if room > 0:
-        if len(micro) > room:
-          micro = micro[:room]
-        T.extend(micro)
-
-  # Micro-phase C: second guarded micro-round using distinct windows and pin shrinking
+    if alt:
+      micro_connectors.append((glo + int(round(0.18 * G)), glo + int(round(0.84 * G))))
+    for a, b in micro_connectors:
+      if b > a:
+        micro.append((a, b))
+
+    if len(micro) > budget:
+      micro = micro[:budget]
+    return micro
+
+  # Execute two primary micro rounds, then one alt round (capacity-guarded)
+  for iter_id in range(2):
+    room = CAP - len(T)
+    if room <= 8:
+      break
+    micro = _build_micro_delta_round(T, room, iter_id=iter_id, alt=False)
+    if not micro:
+      break
+    if len(micro) > room:
+      micro = micro[:room]
+    T.extend(micro)
+
+  room = CAP - len(T)
+  if room > 8:
+    micro_alt = _build_micro_delta_round(T, room, iter_id=2, alt=True)
+    if micro_alt:
+      avail = CAP - len(T)
+      if len(micro_alt) > avail:
+        micro_alt = micro_alt[:avail]
+      T.extend(micro_alt)
+
+  # Stage 3: pin-shrinking micro-phase (controls omega via short intervals)
   if len(T) < CAP - 8:
     glo2 = min(l for l, r in T)
     ghi2 = max(r for l, r in T)
-    G2 = ghi2 - glo2 if ghi2 > glo2 else 1
-
-    # Thin seed again (slightly smaller to limit omega growth)
+    G2 = max(1, ghi2 - glo2)
     seed_sz2 = max(8, min(24, len(T) // 400))
-    stride2 = max(1, len(T) // max(1, seed_sz2))
-    U2 = [T[i] for i in range(0, len(T), stride2)][:seed_sz2]
-
+    U2 = _thin_seed(T, seed_sz2)
     if U2:
       ulo2 = min(l for l, r in U2)
-
-      # New window set to avoid stacking with phase B windows
+      eps = max(1, G2 // 512)
       windows2 = [(0.05, 0.15), (0.28, 0.38), (0.60, 0.70), (0.82, 0.92)]
-
-      # Short pins to reduce clique growth; slight stagger to avoid co-location
-      eps = max(1, G2 // 512)
       blocks2 = []
       for (fa, fb) in windows2:
         win_lo2 = glo2 + int(round(fa * G2))
         base2 = win_lo2 - ulo2
         block = []
         for idx, (l, r) in enumerate(U2):
           mid = (l + r) // 2
           L = mid + base2 - (eps // 2) + (idx % 3)
           R = L + eps
           if R > L:
             block.append((L, R))
         blocks2.append(block)
 
-      # Interleave with a different order to diversify coupling
       micro2 = []
       if blocks2:
         maxlen2 = max(len(b) for b in blocks2)
         order2 = [3, 1, 0, 2]
         for i in range(maxlen2):
           for idx in order2:
             blk = blocks2[idx]
             if i < len(blk):
               micro2.append(blk[i])
 
-      # Very short cap-pins to tie windows without inflating omega
+      # Two short cap-pins to tie windows without inflating omega
       caps2 = [
         (glo2 + int(round(0.09 * G2)), glo2 + int(round(0.09 * G2)) + eps),
         (glo2 + int(round(0.64 * G2)), glo2 + int(round(0.64 * G2)) + eps),
       ]
       for a, b in caps2:
         if b > a:
           micro2.append((a, b))
 
-      # Capacity guard
       room2 = CAP - len(T)
       if room2 > 0:
         if len(micro2) > room2:
           micro2 = micro2[:room2]
         T.extend(micro2)
 
-  # Micro-phase D: second four-window micro-phase with distinct windows and long-range connectors
-  if len(T) < CAP - 4:
+  # Stage 4 (new): tower-and-cap micro-phase
+  # Build staggered short towers across five separated windows, then add a few long caps
+  # that each overlap one level from every tower. At any point, only a local tower pin
+  # is active with the cap, mitigating omega growth.
+  if len(T) < CAP - 12:
     glo3 = min(l for l, r in T)
     ghi3 = max(r for l, r in T)
-    G3 = ghi3 - glo3 if ghi3 > glo3 else 1
-
-    # Thin seed (moderate) from current T for stronger mixing
-    seed_sz3 = max(8, min(36, len(T) // 300))
-    stride3 = max(1, len(T) // max(1, seed_sz3))
-    U3 = [T[i] for i in range(0, len(T), stride3)][:seed_sz3]
-
+    G3 = max(1, ghi3 - glo3)
+
+    # Thin seed for pin positioning (moderate size)
+    U3 = _thin_seed(T, max(12, min(36, len(T) // 300)))
     if U3:
       ulo3 = min(l for l, r in U3)
-
-      # Distinct window pattern to complement earlier phases
-      window_fracs3 = [(0.09, 0.19), (0.32, 0.42), (0.64, 0.74), (0.86, 0.94)]
-      blocks3 = []
-      for (fa, fb) in window_fracs3:
+      eps3 = max(1, G3 // 768)  # very short pins
+
+      # Five windows for five towers; each builds 3 staggered pin levels
+      towers = [(0.10, 0.18), (0.28, 0.36), (0.46, 0.54), (0.64, 0.72), (0.82, 0.90)]
+      levels = 3
+      tower_blocks = []
+      for t_idx, (fa, fb) in enumerate(towers):
         win_lo3 = glo3 + int(round(fa * G3))
         base3 = win_lo3 - ulo3
-        block = [(l + base3, r + base3) for (l, r) in U3]
-        # Reverse every second block to vary internal order
-        if int(round(fa * 100)) % 2 == 0:
-          block = list(reversed(block))
-        blocks3.append(block)
-
-      # Interleave using a nontrivial order to break symmetry
-      micro3 = []
-      if blocks3:
-        maxlen3 = max(len(b) for b in blocks3)
-        order3 = [0, 2, 1, 3]
+        block = []
+        for idx, (l, r) in enumerate(U3):
+          mid = (l + r) // 2
+          # three levels staggered slightly to avoid co-location
+          for lv in range(levels):
+            jitter = (idx + lv + t_idx) % 4
+            L = mid + base3 - (eps3 // 2) + jitter + lv  # increasing shift by level
+            R = L + eps3
+            if R > L:
+              block.append((L, R))
+        tower_blocks.append(block)
+
+      # Interleave towers round-robin to distribute local density
+      tower_phase = []
+      if tower_blocks:
+        maxlen3 = max(len(b) for b in tower_blocks)
+        order3 = [0, 2, 4, 1, 3]
         for i in range(maxlen3):
           for idx in order3:
-            blk = blocks3[idx]
+            blk = tower_blocks[idx]
             if i < len(blk):
-              micro3.append(blk[i])
-
-      # Long-range, pairwise-disjoint connectors to avoid omega spikes
-      connectors3 = [
-        (glo3 + int(round(0.06 * G3)), glo3 + int(round(0.28 * G3))),
-        (glo3 + int(round(0.41 * G3)), glo3 + int(round(0.59 * G3))),
-        (glo3 + int(round(0.72 * G3)), glo3 + int(round(0.95 * G3))),
+              tower_phase.append(blk[i])
+
+      # Add a few long caps that span across the tower windows but avoid edges
+      caps3 = [
+        (glo3 + int(round(0.15 * G3)), glo3 + int(round(0.45 * G3))),
+        (glo3 + int(round(0.38 * G3)), glo3 + int(round(0.70 * G3))),
+        (glo3 + int(round(0.60 * G3)), glo3 + int(round(0.88 * G3))),
       ]
-      for a, b in connectors3:
+      for a, b in caps3:
         if b > a:
-          micro3.append((a, b))
-
-      # Capacity guard
+          tower_phase.append((a, b))
+
       room3 = CAP - len(T)
-      if room3 > 0:
-        if len(micro3) > room3:
-          micro3 = micro3[:room3]
-        T.extend(micro3)
-
-  return T
-
-  # return [  # Figure 3, OPT=2, FF=4
-  #   (2,3),
-  #   (6,7),
-  #   (10,11),
-  #   (14,15),
-  #   (1,5),
-  #   (12,16),
-  #   (4,9),
-  #   (8,13),
-  # ]
+      if room3 > 0 and tower_phase:
+        if len(tower_phase) > room3:
+          tower_phase = tower_phase[:room3]
+        T.extend(tower_phase)
+
+  # Final capacity guard
+  if len(T) > CAP:
+    T = T[:CAP]
+
+  # Normalize and ensure integer endpoints with r > l
+  if not T:
+    return []
+  min_l = min(l for l, r in T)
+  if min_l < 0:
+    T = [(l - min_l, r - min_l) for (l, r) in T]
+
+  intervals = []
+  for (l, r) in T:
+    li = int(l)
+    ri = int(r)
+    if ri <= li:
+      ri = li + 1
+    intervals.append((li, ri))
+
+  if len(intervals) > CAP:
+    intervals = intervals[:CAP]
+  return intervals
 
 # EVOLVE-BLOCK-END
 
 def run_experiment(**kwargs):
   """Main called by evaluator"""
   return construct_intervals()