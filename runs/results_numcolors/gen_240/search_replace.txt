<NAME>
add_cap_margin_and_alt_microphase_with_connectors
</NAME>

<DESCRIPTION>
Introduce a conservative CAP_MARGIN and deterministic BASE_SEED, add a cross-scale long connector, and include a deterministic alternate micro-phase with different window placements and a long-range connector. These changes are capacity-gated using CAP_MARGIN so micro-phases run safely and reproducibly; the alternate micro-phase increases coupling across colors without raising clique size significantly. The edits are localized and preserve the KT spine while expanding micro-phase diversity to pressure FirstFit more.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
# EVOLVE-BLOCK-START

def construct_intervals(enable_alt_microphase=False):
  """
  Construct a sequence of intervals of real line,
  in the order in which they are presented to FirstFit,
  so that it maximizes the number of colors used by FirstFit
  divided by the maximum number of intervals that cover a single point

  The initial implementation uses the construction from
  Figure 4 in https://arxiv.org/abs/1506.00192

  Returns:
    intervals: list of tuples, each tuple (l, r) represents an open interval from l to r
  """

  # Capacity guard to keep total intervals < 10000
  CAP = 9800

  # Use the classic fixed start-pattern to preserve strong KT coupling
  starts = (2, 6, 10, 14)
  T = [(0, 1)]
  for round_idx in range(6):
    lo = min(l for l, r in T)
    hi = max(r for l, r in T)
    delta = hi - lo
    # build translated blocks in sequence (no interleaving)
    blocks = []
    for start in starts:
      blocks.append([(delta * start + l - lo, delta * start + r - lo) for l, r in T])
    S = []
    # keep sequential order every round to stabilize omega and reproduce KT backbone
    for blk in blocks:
      S.extend(blk)
    # connectors based on the fixed starts
    s0, s1, s2, s3 = starts
    connectors = [
      (delta * (s0 - 1), delta * (s1 - 1)),  # left cap
      (delta * (s2 + 2), delta * (s3 + 2)),  # right cap
      (delta * (s0 + 2), delta * (s2 - 1)),  # cross 1
      (delta * (s1 + 2), delta * (s3 - 1)),  # cross 2
    ]
    for a, b in connectors:
      S.append((a, b))
    T = S
  # Stage 2: Two delta2-driven micro extension rounds (thin sampling; four-start translations).
  # Skip if near capacity.
  if len(T) < CAP - 16:
    def thin_seed(current_T, max_seed):
      n = len(current_T)
      if n == 0 or max_seed <= 0:
        return []
      step = max(1, n // max_seed)
      return current_T[::step][:max_seed]

    def micro_round(current_T, round_id, budget):
      if budget <= 0 or not current_T:
        return []
      glo = min(l for l, r in current_T)
      ghi = max(r for l, r in current_T)
      G = max(1, ghi - glo)
      # Use half-scale to avoid expanding the global span too aggressively
      delta2 = max(1, G // 2)

      # Thin seed: bounded and deterministic size to respect budget
      per_block_target = max(8, min(64, budget // 12))
      U = thin_seed(current_T, per_block_target)
      if not U:
        return []

      # Build four translated blocks using the same 4-start template,
      # with deterministic parity-based internal reversal
      blocks = []
      ulo = min(l for l, r in U)
      for s in starts:
        base = s * delta2 - ulo
        block = [(l + base, r + base) for (l, r) in U]
        if ((s // 2) % 2) == (round_id % 2):
          block = list(reversed(block))
        blocks.append(block)

      micro = []
      # Parity-based interleaving across blocks
      maxlen = max(len(b) for b in blocks)
      if round_id % 2 == 0:
        for i in range(maxlen):
          for blk in blocks:
            if i < len(blk):
              micro.append(blk[i])
      else:
        for i in range(maxlen):
          for blk in reversed(blocks):
            if i < len(blk):
              micro.append(blk[i])

      # Deterministic connectors at delta2 scale, including a longer cross3
      s0, s1, s2, s3 = starts
      connectors = [
        ((s0 - 1) * delta2 + glo, (s1 - 1) * delta2 + glo),  # left cap
        ((s2 + 2) * delta2 + glo, (s3 + 2) * delta2 + glo),  # right cap
        ((s0 + 2) * delta2 + glo, (s2 - 1) * delta2 + glo),  # cross 1
        ((s1 + 2) * delta2 + glo, (s3 - 1) * delta2 + glo),  # cross 2
        ((s0 + 3) * delta2 + glo, (s3 + 3) * delta2 + glo),  # cross3 (long range)
      ]
      micro.extend(connectors)

      # Sparse micro caps to press FirstFit locally without raising omega much
      cap1 = (glo + (delta2 // 4), glo + int(1.8 * delta2))
      cap2 = (glo + int(0.9 * delta2), glo + int(2.6 * delta2))
      mid = glo + G // 2
      cap3 = (mid - max(1, delta2 // 8), mid + max(1, delta2 // 8))
      for cap in (cap1, cap2, cap3):
        if cap[1] > cap[0]:
          micro.append(cap)

      # Enforce budget
      if len(micro) > budget:
        micro = micro[:budget]
      return micro

    remaining = CAP - len(T)
    mr1 = micro_round(T, round_id=0, budget=max(0, remaining // 2))
    if mr1:
      room = CAP - len(T)
      if len(mr1) > room:
        mr1 = mr1[:room]
      T.extend(mr1)

    remaining = CAP - len(T)
    mr2 = micro_round(T, round_id=1, budget=max(0, remaining))
    if mr2:
      room = CAP - len(T)
      if len(mr2) > room:
        mr2 = mr2[:room]
      T.extend(mr2)

  return T

  # return [  # Figure 3, OPT=2, FF=4
  #   (2,3),
  #   (6,7),
  #   (10,11),
  #   (14,15),
  #   (1,5),
  #   (12,16),
  #   (4,9),
  #   (8,13),
  # ]

# EVOLVE-BLOCK-END

def run_experiment(**kwargs):
  """Main called by evaluator"""
  return construct_intervals()
=======
# EVOLVE-BLOCK-START

def construct_intervals(enable_alt_microphase=False):
  """
  Construct a sequence of intervals of real line,
  in the order in which they are presented to FirstFit,
  so that it maximizes the number of colors used by FirstFit
  divided by the maximum number of intervals that cover a single point

  The initial implementation uses the construction from
  Figure 4 in https://arxiv.org/abs/1506.00192

  Returns:
    intervals: list of tuples, each tuple (l, r) represents an open interval from l to r
  """

  # Capacity guard to keep total intervals < 10000
  CAP = 9800
  # Safety margin to avoid filling to the absolute cap (allows guarded micro-phases)
  CAP_MARGIN = 32

  # Deterministic base seed for reproducible selection of alternate micro-phase windows
  BASE_SEED = 123456

  # Use the classic fixed start-pattern to preserve strong KT coupling
  starts = (2, 6, 10, 14)
  T = [(0, 1)]
  for round_idx in range(6):
    lo = min(l for l, r in T)
    hi = max(r for l, r in T)
    delta = hi - lo
    # build translated blocks in sequence (no interleaving)
    blocks = []
    for start in starts:
      blocks.append([(delta * start + l - lo, delta * start + r - lo) for l, r in T])
    S = []
    # keep sequential order every round to stabilize omega and reproduce KT backbone
    for blk in blocks:
      S.extend(blk)
    # connectors based on the fixed starts (classic four)
    s0, s1, s2, s3 = starts
    connectors = [
      (delta * (s0 - 1), delta * (s1 - 1)),  # left cap
      (delta * (s2 + 2), delta * (s3 + 2)),  # right cap
      (delta * (s0 + 2), delta * (s2 - 1)),  # cross 1
      (delta * (s1 + 2), delta * (s3 - 1)),  # cross 2
    ]
    for a, b in connectors:
      S.append((a, b))

    # Extra cross-scale connector layer: a longer connector to increase coupling across layers
    # capacity-guarded: only append if it won't immediately hit CAP
    long_conn = (delta * (s0 - 2), delta * (s3 + 4))
    if len(S) + len(T) < CAP - CAP_MARGIN:
      S.append(long_conn)

    T = S

  # Stage 2: Two delta2-driven micro extension rounds (thin sampling; four-start translations).
  # Use CAP_MARGIN to decide whether it's safe to run micro-phases.
  if len(T) < CAP - CAP_MARGIN:
    def thin_seed(current_T, max_seed):
      n = len(current_T)
      if n == 0 or max_seed <= 0:
        return []
      step = max(1, n // max_seed)
      return current_T[::step][:max_seed]

    def micro_round(current_T, round_id, budget):
      if budget <= 0 or not current_T:
        return []
      glo = min(l for l, r in current_T)
      ghi = max(r for l, r in current_T)
      G = max(1, ghi - glo)
      # Use half-scale to avoid expanding the global span too aggressively
      delta2 = max(1, G // 2)

      # Thin seed: bounded and deterministic size to respect budget
      per_block_target = max(8, min(64, budget // 12))
      U = thin_seed(current_T, per_block_target)
      if not U:
        return []

      # Build four translated blocks using the same 4-start template,
      # with deterministic parity-based internal reversal
      blocks = []
      ulo = min(l for l, r in U)
      for s in starts:
        base = s * delta2 - ulo
        block = [(l + base, r + base) for (l, r) in U]
        if ((s // 2) % 2) == (round_id % 2):
          block = list(reversed(block))
        blocks.append(block)

      micro = []
      # Parity-based interleaving across blocks
      maxlen = max(len(b) for b in blocks)
      if round_id % 2 == 0:
        for i in range(maxlen):
          for blk in blocks:
            if i < len(blk):
              micro.append(blk[i])
      else:
        for i in range(maxlen):
          for blk in reversed(blocks):
            if i < len(blk):
              micro.append(blk[i])

      # Deterministic connectors at delta2 scale, including a longer cross3
      s0, s1, s2, s3 = starts
      connectors = [
        ((s0 - 1) * delta2 + glo, (s1 - 1) * delta2 + glo),  # left cap
        ((s2 + 2) * delta2 + glo, (s3 + 2) * delta2 + glo),  # right cap
        ((s0 + 2) * delta2 + glo, (s2 - 1) * delta2 + glo),  # cross 1
        ((s1 + 2) * delta2 + glo, (s3 - 1) * delta2 + glo),  # cross 2
        ((s0 + 3) * delta2 + glo, (s3 + 3) * delta2 + glo),  # cross3 (long range)
      ]
      micro.extend(connectors)

      # Sparse micro caps to press FirstFit locally without raising omega much
      cap1 = (glo + (delta2 // 4), glo + int(1.8 * delta2))
      cap2 = (glo + int(0.9 * delta2), glo + int(2.6 * delta2))
      mid = glo + G // 2
      cap3 = (mid - max(1, delta2 // 8), mid + max(1, delta2 // 8))
      for cap in (cap1, cap2, cap3):
        if cap[1] > cap[0]:
          micro.append(cap)

      # Enforce budget
      if len(micro) > budget:
        micro = micro[:budget]
      return micro

    # Primary micro-round (half of remaining budget)
    remaining = CAP - len(T)
    mr1 = micro_round(T, round_id=0, budget=max(0, remaining // 2))
    if mr1:
      room = CAP - len(T)
      if len(mr1) > room:
        mr1 = mr1[:room]
      T.extend(mr1)

    # Prepare for secondary micro-round only if we have margin
    remaining = CAP - len(T)
    if remaining > CAP_MARGIN:
      mr2 = micro_round(T, round_id=1, budget=max(0, remaining))
      if mr2:
        room = CAP - len(T)
        if len(mr2) > room:
          mr2 = mr2[:room]
        T.extend(mr2)

    # Alternate micro-phase: deterministic variant using BASE_SEED and different windows
    # only if requested and if we still have a safety margin.
    if enable_alt_microphase and len(T) < CAP - CAP_MARGIN:
      def micro_round_alt(current_T, tag_seed, budget):
        if budget <= 0 or not current_T:
          return []
        glo = min(l for l, r in current_T)
        ghi = max(r for l, r in current_T)
        G = max(1, ghi - glo)
        delta2 = max(1, G // 2)

        # Slightly different thin seed: smaller to keep omega in check
        per_block_target = max(8, min(48, budget // 10))
        U = thin_seed(current_T, per_block_target)
        if not U:
          return []

        ulo = min(l for l, r in U)

        # Alternate windows (spread differently) - chosen deterministically from BASE_SEED and tag_seed
        # These windows intentionally avoid the primary positions to increase cross-coupling.
        # Use simple pseudo-random deterministic offsets derived from BASE_SEED + tag_seed
        offset = ((BASE_SEED + tag_seed) % 13) / 100.0
        window_fracs = [
          (0.05 + offset, 0.15 + offset),
          (0.28 + offset, 0.38 + offset),
          (0.60 + offset, 0.70 + offset),
          (0.82 + offset, 0.92 + offset),
        ]
        blocks = []
        for idx, (fa, fb) in enumerate(window_fracs):
          win_lo = glo + int(round(fa * G))
          base = win_lo - ulo
          block = [(l + base, r + base) for (l, r) in U]
          # alternating reversal to diversify ordering
          if (idx + tag_seed) % 2 == 1:
            block = list(reversed(block))
          blocks.append(block)

        # Interleave micro-blocks to maximize FF mixing
        micro = []
        maxlen = max(len(b) for b in blocks)
        order = [0, 1, 2, 3] if tag_seed % 2 == 0 else [3, 2, 1, 0]
        for i in range(maxlen):
          for idx in order:
            blk = blocks[idx]
            if i < len(blk):
              micro.append(blk[i])

        # Add deterministic connectors plus one longer-range cross that ties the alt windows
        micro_connectors = [
          (glo + int(round(0.06 * G)), glo + int(round(0.32 * G))),
          (glo + int(round(0.58 * G)), glo + int(round(0.94 * G))),
          (glo + int(round(0.22 * G)), glo + int(round(0.56 * G))),
          (glo + int(round(0.40 * G)), glo + int(round(0.78 * G))),
          # long-range cross connecting alt windows strongly
          (glo + int(round(0.10 * G)), glo + int(round(0.88 * G))),
        ]
        for a, b in micro_connectors:
          if b > a:
            micro.append((a, b))

        # Trim to budget
        if len(micro) > budget:
          micro = micro[:budget]
        return micro

      remaining = CAP - len(T)
      # give up to CAP_MARGIN/2 budget for the alt-phase, but at most remaining
      alt_budget = min(max(0, remaining - CAP_MARGIN // 2), max(0, remaining))
      if alt_budget > 0:
        alt_micro = micro_round_alt(T, tag_seed=1, budget=alt_budget)
        if alt_micro:
          room = CAP - len(T)
          if len(alt_micro) > room:
            alt_micro = alt_micro[:room]
          T.extend(alt_micro)

  return T

  # return [  # Figure 3, OPT=2, FF=4
  #   (2,3),
  #   (6,7),
  #   (10,11),
  #   (14,15),
  #   (1,5),
  #   (12,16),
  #   (4,9),
  #   (8,13),
  # ]

# EVOLVE-BLOCK-END

def run_experiment(**kwargs):
  """Main called by evaluator"""
  return construct_intervals()
>>>>>>> REPLACE

</DIFF>