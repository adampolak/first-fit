--- a/original.py
+++ b/original.py
@@ -1,195 +1,277 @@
 # EVOLVE-BLOCK-START
 
 def construct_intervals():
   """
   Construct a sequence of intervals of real line,
   in the order in which they are presented to FirstFit,
   so that it maximizes the number of colors used by FirstFit
   divided by the maximum number of intervals that cover a single point
 
   The initial implementation uses the construction from
   Figure 4 in https://arxiv.org/abs/1506.00192
 
   Returns:
     intervals: list of tuples, each tuple (l, r) represents an open interval from l to r
   """
 
   # Capacity guard to keep total intervals < 10000
   CAP = 9800
 
   # Stage 1: Deterministic KT-style spine with rotating start patterns to diversify block interactions
   templates = [
       (2, 6, 10, 14),
       (1, 5, 9, 13),
       (3, 7, 11, 15),
       (4, 8, 12, 16),
   ]
 
   # Seed: keep a single unit interval; multi-seed tends to inflate omega too early.
   T = [(0, 1)]
 
   # Perform up to six spine rounds unless capacity would be exceeded (it won't for this growth).
   for ridx in range(6):
     # Compute span and delta
     lo = min(l for l, r in T)
     hi = max(r for l, r in T)
     delta = hi - lo
     if delta <= 0:
       delta = 1
 
     # Rotate start pattern and build four translated blocks
     starts = templates[ridx % len(templates)]
     blocks = []
     for s in starts:
       base = s * delta - lo
       block = [(l + base, r + base) for (l, r) in T]
       blocks.append(block)
 
-    # Interleave blocks on even rounds; keep sequential on odd rounds
+    # Keep sequential order; on odd rounds, reverse block order to break symmetry (no interleaving)
     S = []
-    if ridx % 2 == 0:
-      maxlen = max(len(b) for b in blocks)
-      for i in range(maxlen):
-        for blk in blocks:
-          if i < len(blk):
-            S.append(blk[i])
-    else:
-      for blk in blocks:
-        S.extend(blk)
+    order = blocks if ridx % 2 == 0 else list(reversed(blocks))
+    for blk in order:
+      S.extend(blk)
 
     # Classic connectors (Figure 4 style), now using the rotated pattern
     s0, s1, s2, s3 = starts
     connectors = [
       ((s0 - 1) * delta, (s1 - 1) * delta),  # left cap
       ((s2 + 2) * delta, (s3 + 2) * delta),  # right cap
       ((s0 + 2) * delta, (s2 - 1) * delta),  # cross 1
       ((s1 + 2) * delta, (s3 - 1) * delta),  # cross 2
     ]
     S.extend(connectors)
     T = S
 
     if len(T) > CAP:
       break
 
+  # Stage 1.5: add long, sparse caps near the tail to boost FF while keeping omega modest
+  lo = min(l for l, r in T)
+  hi = max(r for l, r in T)
+  span = max(1, hi - lo)
+  def _cap(a_frac, b_frac):
+    L = lo + int(round(a_frac * span))
+    R = lo + int(round(b_frac * span))
+    if R <= L:
+      R = L + 1
+    return (L, R)
+  tail_caps = [_cap(0.08, 0.60), _cap(0.26, 0.74), _cap(0.78, 0.92)]
+  room = CAP - len(T)
+  if room > 0:
+    for cap in tail_caps:
+      if len(T) >= CAP:
+        break
+      T.append(cap)
+
   # Stage 2: delta2-driven micro extension rounds (thin sampling; four-start translations).
   # Goals:
   #  - Raise FF pressure via cross-scale coupling and interleaving parity,
   #  - Keep omega in check by using thin seeds and sparse caps/connectors,
   #  - Respect strict capacity guard and keep OPT <= 10 by avoiding dense local overlaps.
   remaining = CAP - len(T)
   if remaining <= 16:
     return T
 
   def thin_seed(current_T, max_seed):
     n = len(current_T)
     if n == 0 or max_seed <= 0:
       return []
     step = max(1, n // max_seed)
     return current_T[::step][:max_seed]
 
   def micro_round(current_T, round_id, budget):
     if budget <= 0 or not current_T:
       return []
 
     glo = min(l for l, r in current_T)
     ghi = max(r for l, r in current_T)
     G = max(1, ghi - glo)
 
     # Use delta2 at half-scale to avoid expanding the global span too aggressively.
     delta2 = max(1, G // 2)
 
     # Thin seed: bounded and deterministic size to respect budget.
-    per_block_target = max(8, min(64, budget // 12))
+    per_block_target = max(16, min(96, budget // 8))
     U = thin_seed(current_T, per_block_target)
     if not U:
       return []
 
     # Build four translated blocks using a fixed 4-start template to stabilize omega.
     starts = (2, 6, 10, 14)
     blocks = []
     ulo = min(l for l, r in U)
     for s in starts:
       base = s * delta2 - ulo
       block = [(l + base, r + base) for (l, r) in U]
       # Add a tiny deterministic internal reversal to break symmetry every other block
       if ((s // 2) % 2) == (round_id % 2):
         block = list(reversed(block))
       blocks.append(block)
 
     micro = []
     if round_id % 2 == 0:
       # Forward interleave
       maxlen = max(len(b) for b in blocks)
       for i in range(maxlen):
         for blk in blocks:
           if i < len(blk):
             micro.append(blk[i])
     else:
       # Reverse interleave (swap block order)
       maxlen = max(len(b) for b in blocks)
       for i in range(maxlen):
         for blk in reversed(blocks):
           if i < len(blk):
             micro.append(blk[i])
 
     # Deterministic connectors at delta2 scale, including a cross3 and cross4 extension.
     s0, s1, s2, s3 = starts
     connectors = [
       ((s0 - 1) * delta2 + glo, (s1 - 1) * delta2 + glo),  # left cap (localized)
       ((s2 + 2) * delta2 + glo, (s3 + 2) * delta2 + glo),  # right cap
       ((s0 + 2) * delta2 + glo, (s2 - 1) * delta2 + glo),  # cross 1
       ((s1 + 2) * delta2 + glo, (s3 - 1) * delta2 + glo),  # cross 2
       ((s0 + 3) * delta2 + glo, (s3 + 3) * delta2 + glo),  # cross3 (longer range)
       ((s1 + 4) * delta2 + glo, (s2 + 4) * delta2 + glo),  # cross4 (extended coupling)
     ]
     micro.extend(connectors)
 
     # Sparse micro caps: add three long but safe caps at half-scale
     cap1 = (glo + (delta2 // 4), glo + int(1.8 * delta2))
     cap2 = (glo + int(0.9 * delta2), glo + int(2.6 * delta2))
     mid = glo + G // 2
     cap3 = (mid - max(1, delta2 // 8), mid + max(1, delta2 // 8))
     for cap in (cap1, cap2, cap3):
       if cap[1] > cap[0]:
         micro.append(cap)
 
     # Enforce budget
     if len(micro) > budget:
       micro = micro[:budget]
     return micro
 
+  # Additional micro-phase: window-based thin interleaving across the global span
+  def micro_window_round(current_T, budget, iter_id=0):
+    if not current_T or budget <= 8:
+      return []
+    glo = min(l for l, r in current_T)
+    ghi = max(r for l, r in current_T)
+    G = max(1, ghi - glo)
+
+    # Thin seed: small, evenly spaced
+    seed_sz = max(8, min(32, len(current_T) // 300))
+    stride = max(1, len(current_T) // max(1, seed_sz))
+    U = [current_T[i] for i in range(0, len(current_T), stride)][:seed_sz]
+    if not U:
+      return []
+    ulo = min(l for l, r in U)
+
+    # Four narrow windows; shift slightly by iteration parity
+    shift = (iter_id % 2) * 0.015
+    window_fracs = [
+      (0.12 + shift, 0.20 + shift),
+      (0.34 + shift, 0.42 + shift),
+      (0.56 + shift, 0.64 + shift),
+      (0.78 + shift, 0.86 + shift),
+    ]
+    blocks = []
+    for (fa, fb) in window_fracs:
+      win_lo = glo + int(round(fa * G))
+      base = win_lo - ulo
+      block = [(l + base, r + base) for (l, r) in U]
+      blocks.append(block)
+
+    # Interleave windows to maximize mixing
+    micro = []
+    maxlen = max(len(b) for b in blocks)
+    order = list(range(len(blocks)))
+    if iter_id % 2 == 1:
+      order.reverse()
+    for i in range(maxlen):
+      for idx in order:
+        blk = blocks[idx]
+        if i < len(blk):
+          micro.append(blk[i])
+
+    # Add fractional-span caps and cross-window couplers
+    connectors = [
+      (glo + int(round(0.10 * G)), glo + int(round(0.30 * G))),
+      (glo + int(round(0.32 * G)), glo + int(round(0.50 * G))),
+      (glo + int(round(0.52 * G)), glo + int(round(0.70 * G))),
+      (glo + int(round(0.72 * G)), glo + int(round(0.90 * G))),
+      (glo + int(round(0.22 * G)), glo + int(round(0.58 * G))),
+      (glo + int(round(0.40 * G)), glo + int(round(0.82 * G))),
+    ]
+    for a, b in connectors:
+      if b > a:
+        micro.append((a, b))
+
+    if len(micro) > budget:
+      micro = micro[:budget]
+    return micro
+
   # Execute two micro rounds with strong guards
   remaining = CAP - len(T)
   mr1 = micro_round(T, round_id=0, budget=max(0, remaining // 2))
   if mr1:
     room = CAP - len(T)
     if len(mr1) > room:
       mr1 = mr1[:room]
     T.extend(mr1)
 
   remaining = CAP - len(T)
   mr2 = micro_round(T, round_id=1, budget=max(0, remaining))
   if mr2:
     room = CAP - len(T)
     if len(mr2) > room:
       mr2 = mr2[:room]
     T.extend(mr2)
+
+  # Final window-based micro-phase to exploit remaining budget
+  remaining = CAP - len(T)
+  if remaining > 8:
+    win_micro = micro_window_round(T, budget=remaining, iter_id=0)
+    if win_micro:
+      avail = CAP - len(T)
+      if len(win_micro) > avail:
+        win_micro = win_micro[:avail]
+      T.extend(win_micro)
 
   return T
 
   # return [  # Figure 3, OPT=2, FF=4
   #   (2,3),
   #   (6,7),
   #   (10,11),
   #   (14,15),
   #   (1,5),
   #   (12,16),
   #   (4,9),
   #   (8,13),
   # ]
 
 # EVOLVE-BLOCK-END
 
 def run_experiment(**kwargs):
   """Main called by evaluator"""
   return construct_intervals()