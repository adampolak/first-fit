--- a/original.py
+++ b/original.py
@@ -1,180 +1,273 @@
 # EVOLVE-BLOCK-START
 
 def construct_intervals(seed_count=1):
   """
-  Construct a sequence of intervals on the real line, in the order presented to FirstFit,
-  to maximize FF colors divided by the clique number.
-  Returns:
-    intervals: list of (l, r) tuples (open intervals).
+  Construct a sequence of open intervals for FirstFit in presentation order.
+  Maintains the same I/O as prior versions: returns a list of (l, r) integer tuples.
   """
 
-  # Capacity guard tuned to return after six spine rounds (skipping micro-phase) and < 10000
+  # Hard capacity to keep intervals < 10000 and allow room for micro-phases
   CAP = 9800
 
-  # Stage 1: Deterministic KT-style spine (no interleaving), 6 rounds, classic connectors.
-  spine_starts = (2, 6, 10, 14)
-
-  # Seed: keep a single unit interval; multi-seed tends to inflate omega too early.
+  # Deterministic global seed to derive minor parity choices and offsets (no randomness)
+  BASE_SEED = 137
+
+  # Rotating start templates for the KT-style backbone (classic set)
+  TEMPLATE_BANK = [
+    (2, 6, 10, 14),  # T1: classic KT
+    (1, 5, 9, 13),   # T2: left-shifted
+    (3, 7, 11, 15),  # T3: right-shifted
+    (4, 8, 12, 16),  # T4: stretched-right
+  ]
+
+  # Seed with a single unit interval to avoid early omega inflation
   T = [(0, 1)] if seed_count <= 1 else [(0, 1)]
 
-  def apply_spine_round(current_T, starts):
-    # Compute span and delta
-    lo = min(l for l, r in current_T)
-    hi = max(r for l, r in current_T)
+  # Helpers
+  def _span(TS):
+    lo = min(l for l, r in TS)
+    hi = max(r for l, r in TS)
     delta = hi - lo
     if delta <= 0:
       delta = 1
-
-    # Four translated blocks sequentially (no interleaving)
-    S = []
+    return lo, hi, delta
+
+  def _apply_round(current_T, starts, do_interleave=False, reverse_order=False, add_cross4=False):
+    lo, hi, delta = _span(current_T)
+
+    # Build four translated blocks
+    blocks = []
     for s in starts:
       base = s * delta - lo
-      S.extend((l + base, r + base) for (l, r) in current_T)
-
-    # Classic connectors (Figure 4 style)
+      block = [(l + base, r + base) for (l, r) in current_T]
+      # Gentle internal reversal by start parity to break symmetry
+      if ((s + BASE_SEED) // 2) % 2 == 1:
+        block = list(reversed(block))
+      blocks.append(block)
+
+    # Assemble S: either interleave round-robin or keep sequential (optionally reversed)
+    S = []
+    if do_interleave:
+      order = list(range(4))
+      if reverse_order:
+        order.reverse()
+      maxlen = max(len(b) for b in blocks)
+      for i in range(maxlen):
+        for idx in order:
+          blk = blocks[idx]
+          if i < len(blk):
+            S.append(blk[i])
+    else:
+      if reverse_order:
+        blocks = list(reversed(blocks))
+      for blk in blocks:
+        S.extend(blk)
+
+    # Classic four connectors
     s0, s1, s2, s3 = starts
-    connectors = [
-      ((s0 - 1) * delta, (s1 - 1) * delta),  # left cap
-      ((s2 + 2) * delta, (s3 + 2) * delta),  # right cap
-      ((s0 + 2) * delta, (s2 - 1) * delta),  # cross 1
-      ((s1 + 2) * delta, (s3 - 1) * delta),  # cross 2
-    ]
-    S.extend(connectors)
+    S.append(((s0 - 1) * delta, (s1 - 1) * delta))  # left cap
+    S.append(((s2 + 2) * delta, (s3 + 2) * delta))  # right cap
+    S.append(((s0 + 2) * delta, (s2 - 1) * delta))  # cross 1
+    S.append(((s1 + 2) * delta, (s3 - 1) * delta))  # cross 2
+
+    # Optional long-range connector to enhance cross-scale coupling
+    if add_cross4:
+      # Carefully offset to avoid coinciding with classic caps
+      S.append(((s0 + 4) * delta, (s3 + 4) * delta))
+
     return S
 
-  # Perform exactly six spine rounds, rotating start templates to diversify structure.
-  template_bank = [
-    (2, 6, 10, 14),  # classic KT
-    (1, 5, 9, 13),   # left-shifted
-    (3, 7, 11, 15),  # right-shifted
-    (4, 8, 12, 16),  # alternate
+  def _predict_next_size(sz):
+    # Each round grows as 4*sz + 4 (four blocks + four connectors)
+    return 4 * sz + 4
+
+  def _thin_seed(seq, target):
+    n = len(seq)
+    if n == 0 or target <= 0:
+      return []
+    step = max(1, n // target)
+    return seq[::step][:target]
+
+  # Choose backbone depth to leave space for twin layer + micro phases
+  # Leave at least ~512 slots for gadgets after backbone
+  size = len(T)
+  rounds = 0
+  while rounds < 6:
+    nxt = _predict_next_size(size)
+    if nxt > CAP - 512:
+      break
+    size = nxt
+    rounds += 1
+
+  # Stage 1: Twin-spine backbone with parity-based interleaving and rotating templates
+  for ridx in range(rounds):
+    starts = TEMPLATE_BANK[ridx % len(TEMPLATE_BANK)]
+    do_inter = (ridx % 2 == 0)
+    rev = (ridx % 2 == 1)
+    # Only add the long cross on the last executed round to limit clique growth
+    add_c4 = (ridx == rounds - 1) and (rounds >= 3)
+    T = _apply_round(T, starts, do_interleave=do_inter, reverse_order=rev, add_cross4=add_c4)
+    if len(T) >= CAP:
+      return T[:CAP]
+
+    # Mid-round twin layer after rounds 2 and 4 (0-indexed), strictly CAP-gated
+    if ridx in (1, 3) and len(T) + 128 < CAP:
+      # This "twin" embeds a thin seed at half-scale offsets to couple colors
+      glo, ghi, G = _span(T)
+      delta2 = max(1, G // 2)
+      seed_sz = max(8, min(48, len(T) // 320))
+      U = _thin_seed(T, seed_sz)
+      if U:
+        ulo = min(l for l, r in U)
+        starts_twin = TEMPLATE_BANK[(ridx + 1) % len(TEMPLATE_BANK)]
+        blocks = []
+        for s in starts_twin:
+          base = s * delta2 - ulo + (BASE_SEED % 3)
+          block = [(l + base, r + base) for (l, r) in U]
+          if ((s + ridx) % 3) == 1:
+            block = list(reversed(block))
+          blocks.append(block)
+        # Parity-based interleaving
+        twin = []
+        maxlen = max(len(b) for b in blocks)
+        order = [0, 1, 2, 3]
+        if (BASE_SEED + ridx) % 2 == 1:
+          order.reverse()
+        for i in range(maxlen):
+          for idx in order:
+            blk = blocks[idx]
+            if i < len(blk):
+              twin.append(blk[i])
+
+        # Add sparse connectors at half scale to avoid omega blow-up
+        s0, s1, s2, s3 = starts_twin
+        connectors = [
+          (glo + (s0 - 1) * delta2, glo + (s1 - 1) * delta2),
+          (glo + (s2 + 2) * delta2, glo + (s3 + 2) * delta2),
+        ]
+        twin.extend(connectors)
+        # Capacity guard
+        room = CAP - len(T)
+        if room > 0:
+          twin = twin[:room]
+          T.extend(twin)
+
+  if len(T) >= CAP - 64:
+    return T[:CAP]
+
+  # Cross4 connector layer (deterministic, long-range, capped)
+  # Ties distant positions ~4â€“6 delta apart to strengthen mixing across scales.
+  lo, hi, delta = _span(T)
+  span = max(1, hi - lo)
+  cross4 = [
+    (lo + 1 * delta, lo + 5 * delta),
+    (lo + 2 * delta, lo + 6 * delta),
+    (lo + 3 * delta, lo + 7 * delta),
   ]
-  bank_size = len(template_bank)
-  for ridx in range(6):
-    # Rotate starts per round to break symmetry
-    starts = template_bank[ridx % bank_size]
-    # Predict next size: sz -> 4*sz + 4
-    nxt_size = 4 * len(T) + 4
-    if nxt_size > CAP:
+  for c in cross4:
+    if len(T) >= CAP:
       break
-    T = apply_spine_round(T, starts)
-
-  # If we are already near the cap, return the strong baseline.
-  if len(T) >= CAP:
-    return T
-
-  # Stage 2: Two delta2-driven micro extension rounds (thin sampling; four-start translations).
-  # Goals:
-  #  - Raise FF pressure via cross-scale coupling and interleaving parity,
-  #  - Keep omega in check by using thin seeds and sparse caps/connectors,
-  #  - Respect strict capacity guard.
-
-  def thin_seed(current_T, max_seed):
-    """Take a thin, evenly spaced sample of current_T of size <= max_seed."""
-    n = len(current_T)
-    if n == 0 or max_seed <= 0:
-      return []
-    step = max(1, n // max_seed)
-    U = current_T[::step][:max_seed]
-    return U
-
-  def micro_round(current_T, round_id, budget):
-    if budget <= 0 or not current_T:
+    a, b = c
+    if b > a:
+      T.append((a, b))
+
+  if len(T) >= CAP - 64:
+    return T[:CAP]
+
+  # Micro-phase builder with two window families
+  def _build_micro(current_T, budget, windows, iter_id=0):
+    if not current_T or budget <= 8:
       return []
 
     glo = min(l for l, r in current_T)
     ghi = max(r for l, r in current_T)
     G = max(1, ghi - glo)
-
-    # Use delta2 at half-scale to avoid expanding the global span too aggressively.
-    delta2 = max(1, G // 2)
-
-    # Thin seed: bounded and deterministic size to respect budget
-    # Keep micro blocks small: target at most ~ (budget//6) per block (four blocks + ~8 extras).
-    per_block_target = max(16, min(64, budget // 8))
-    U = thin_seed(current_T, per_block_target)
-
+    # Thin, bounded seed
+    seed_sz = max(8, min(40, len(current_T) // 250))
+    U = _thin_seed(current_T, seed_sz)
     if not U:
       return []
-
-    # Build four translated blocks using the same 4-start template,
-    # with deterministic parity-based interleaving policy:
-    # - Rounds with round_id % 2 == 0: forward interleave
-    # - Rounds with round_id % 2 == 1: reverse interleave
-    starts = spine_starts
+    ulo = min(l for l, r in U)
+
+    # Build translated micro-blocks aligned to fractional windows
     blocks = []
-    ulo = min(l for l, r in U)
-    for s in starts:
-      base = s * delta2 - ulo
+    for (fa, fb) in windows:
+      win_lo = glo + int(round(fa * G))
+      base = win_lo - ulo
       block = [(l + base, r + base) for (l, r) in U]
-      # Add a tiny deterministic internal reversal to break symmetry every other block
-      if ((s // 2) % 2) == (round_id % 2):
+      # Internal reversal keyed by iter_id and window
+      tag = ((int(fa * 100) + 3 * iter_id + BASE_SEED) // 5) % 2
+      if tag == 1:
         block = list(reversed(block))
       blocks.append(block)
 
+    # Interleave with parity on iter_id
     micro = []
-    if round_id % 2 == 0:
-      # Forward interleave
-      maxlen = max(len(b) for b in blocks)
-      for i in range(maxlen):
-        for blk in blocks:
-          if i < len(blk):
-            micro.append(blk[i])
-    else:
-      # Reverse interleave (swap block order)
-      maxlen = max(len(b) for b in blocks)
-      for i in range(maxlen):
-        for blk in reversed(blocks):
-          if i < len(blk):
-            micro.append(blk[i])
-
-    # Deterministic connectors at delta2 scale, including a cross3 extension
-    s0, s1, s2, s3 = starts
-    connectors = [
-      ((s0 - 1) * delta2 + glo, (s1 - 1) * delta2 + glo),  # left cap (localized)
-      ((s2 + 2) * delta2 + glo, (s3 + 2) * delta2 + glo),  # right cap
-      ((s0 + 2) * delta2 + glo, (s2 - 1) * delta2 + glo),  # cross 1
-      ((s1 + 2) * delta2 + glo, (s3 - 1) * delta2 + glo),  # cross 2
-      ((s0 + 3) * delta2 + glo, (s3 + 3) * delta2 + glo),  # cross3 (longer range)
-      ((s1 + 4) * delta2 + glo, (s2 + 4) * delta2 + glo),  # cross4 (extended coupling)
+    maxlen = max(len(b) for b in blocks)
+    order = list(range(len(blocks)))
+    if (iter_id + BASE_SEED) % 2 == 1:
+      order.reverse()
+    for i in range(maxlen):
+      for idx in order:
+        blk = blocks[idx]
+        if i < len(blk):
+          micro.append(blk[i])
+
+    # Fractional-span connectors for the micro scale
+    micro_connectors = [
+      (glo + int(round(0.08 * G)), glo + int(round(0.30 * G))),  # left cap
+      (glo + int(round(0.26 * G)), glo + int(round(0.56 * G))),  # cross 1
+      (glo + int(round(0.44 * G)), glo + int(round(0.78 * G))),  # cross 2
+      (glo + int(round(0.60 * G)), glo + int(round(0.92 * G))),  # right cap
     ]
-    micro.extend(connectors)
-
-    # Sparse micro caps: add three long but safe caps at half-scale
-    cap1 = (glo + (delta2 // 4), glo + int(1.8 * delta2))
-    cap2 = (glo + int(0.9 * delta2), glo + int(2.6 * delta2))
-    mid = glo + G // 2
-    cap3 = (mid - max(1, delta2 // 8), mid + max(1, delta2 // 8))
-    for cap in (cap1, cap2, cap3):
-      if cap[1] > cap[0]:
-        micro.append(cap)
-
-    # Enforce budget
+    # Add a long cross only on odd iterations
+    if iter_id % 2 == 1:
+      micro_connectors.append((glo + int(round(0.18 * G)), glo + int(round(0.84 * G))))
+    for a, b in micro_connectors:
+      if b > a:
+        micro.append((a, b))
+
     if len(micro) > budget:
       micro = micro[:budget]
     return micro
 
-  # Execute two micro rounds with strong guards
-  remaining = CAP - len(T)
-  mr1 = micro_round(T, round_id=0, budget=max(0, remaining // 2))
-  if mr1:
-    room = CAP - len(T)
-    if len(mr1) > room:
-      mr1 = mr1[:room]
-    T.extend(mr1)
-
-  remaining = CAP - len(T)
-  mr2 = micro_round(T, round_id=1, budget=max(0, remaining))
-  if mr2:
-    room = CAP - len(T)
-    if len(mr2) > room:
-      mr2 = mr2[:room]
-    T.extend(mr2)
-
-  return T
+  # Two guarded micro-phases with distinct window sets
+  W1 = [(0.12, 0.22), (0.35, 0.45), (0.58, 0.68), (0.80, 0.90)]
+  W2 = [(0.05, 0.15), (0.28, 0.38), (0.60, 0.70), (0.82, 0.92)]
+
+  # Micro-phase 1
+  room = CAP - len(T)
+  if room > 16:
+    micro1 = _build_micro(T, room, W1, iter_id=0)
+    if micro1:
+      micro1 = micro1[:room]
+      T.extend(micro1)
+
+  # Gate Micro-phase 2 to stay within CAP and avoid omega spikes near capacity
+  room = CAP - len(T)
+  if room > 16:
+    micro2 = _build_micro(T, room, W2, iter_id=1)
+    if micro2:
+      micro2 = micro2[:room]
+      T.extend(micro2)
+
+  # Final capacity trim and normalization
+  if len(T) > CAP:
+    T = T[:CAP]
+
+  # Normalize to integer open intervals and ensure r > l
+  out = []
+  for (l, r) in T:
+    li = int(l)
+    ri = int(r)
+    if ri <= li:
+      ri = li + 1
+    out.append((li, ri))
+
+  return out
 
 # EVOLVE-BLOCK-END
 
 def run_experiment(**kwargs):
   """Main called by evaluator"""
   return construct_intervals()