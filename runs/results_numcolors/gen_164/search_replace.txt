<NAME>
rotate_spine_two_micro_with_parity
</NAME>

<DESCRIPTION>
I enable a roundâ€‘robin rotation among four start templates for the main KT spine, add parity-based reversal of block order, and strengthen the micro-phase by allowing up to two iterations with parity-shifted windows and an extra long-range connector on odd micro rounds. These changes are inspired by known strategies for raising FirstFit while controlling omega: round-robin KT templates couple colors across scales; parity interleaving and reversal improve cross-block mixing; and a two-stage micro-phase with shifted windows increases late-stage FF pressure without inflating the clique number. The cross4 connector remains gated to final round to avoid omega spikes. Defaults and guards ensure we remain under the 10,000 interval cap.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
def construct_intervals(rounds=6,
                        rotate_starts=True,
                        reverse_block_parity=True,
                        interleave_blocks=True,
                        phase2_iters=1,
                        cross4_enabled=True):
=======
def construct_intervals(rounds=6,
                        rotate_starts=True,
                        reverse_block_parity=True,
                        interleave_blocks=True,
                        phase2_iters=2,
                        cross4_enabled=True):
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
  def apply_round(current_T, starts, do_interleave=False, add_cross4=False):
    # Compute span and delta
    lo = min(l for l, r in current_T)
    hi = max(r for l, r in current_T)
    delta = hi - lo
    if delta <= 0:
      delta = 1

    # Build four translated blocks; optionally interleave to enhance color mixing
    blocks = []
    for s in starts:
      base = s * delta - lo
      block = [(l + base, r + base) for (l, r) in current_T]
      blocks.append(block)

    # Interleave on demand (even rounds), otherwise keep sequential (odd rounds)
    S = []
    if do_interleave:
      maxlen = max(len(b) for b in blocks)
      for i in range(maxlen):
        for blk in blocks:
          if i < len(blk):
            S.append(blk[i])
    else:
      for blk in blocks:
        S.extend(blk)

    # Classic connectors that preserve the desired FF pressure without
    # blowing up omega when used with spine_starts:
    s0, s1, s2, s3 = starts
    connectors = [
      ((s0 - 1) * delta, (s1 - 1) * delta),
      ((s2 + 2) * delta, (s3 + 2) * delta),
      ((s0 + 2) * delta, (s2 - 1) * delta),
      ((s1 + 2) * delta, (s3 - 1) * delta),
    ]
    if add_cross4:
      connectors.append(((s0 + 4) * delta, (s3 + 4) * delta))  # long-range cross (final-round only)
    S.extend(connectors)
    return S
=======
  def apply_round(current_T, starts, do_interleave=False, add_cross4=False, reverse_order=False):
    # Compute span and delta
    lo = min(l for l, r in current_T)
    hi = max(r for l, r in current_T)
    delta = hi - lo
    if delta <= 0:
      delta = 1

    # Build four translated blocks; optionally interleave to enhance color mixing
    blocks = []
    for s in starts:
      base = s * delta - lo
      block = [(l + base, r + base) for (l, r) in current_T]
      blocks.append(block)

    # Interleave on demand (even rounds), otherwise keep sequential (odd rounds)
    S = []
    if do_interleave:
      maxlen = max(len(b) for b in blocks)
      block_order = list(range(len(blocks)))
      if reverse_order:
        block_order.reverse()
      for i in range(maxlen):
        for idx in block_order:
          blk = blocks[idx]
          if i < len(blk):
            S.append(blk[i])
    else:
      if reverse_order:
        blocks = list(reversed(blocks))
      for blk in blocks:
        S.extend(blk)

    # Classic connectors that preserve the desired FF pressure without
    # blowing up omega when used with spine_starts:
    s0, s1, s2, s3 = starts
    connectors = [
      ((s0 - 1) * delta, (s1 - 1) * delta),
      ((s2 + 2) * delta, (s3 + 2) * delta),
      ((s0 + 2) * delta, (s2 - 1) * delta),
      ((s1 + 2) * delta, (s3 - 1) * delta),
    ]
    if add_cross4:
      connectors.append(((s0 + 4) * delta, (s3 + 4) * delta))  # long-range cross (final-round only)
    S.extend(connectors)
    return S
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
  for ridx in range(depth):
    # Even rounds interleave blocks, odd rounds keep sequential order
    add_cross4_flag = (ridx == depth - 1) and cross4_enabled
    T = apply_round(T, spine_starts, do_interleave=(ridx % 2 == 0), add_cross4=add_cross4_flag)
=======
  for ridx in range(depth):
    # Round-robin rotate among four strong templates to couple colors across scales
    starts = template_bank[ridx % 4] if rotate_starts else spine_starts
    # Even rounds interleave blocks; odd rounds optionally reverse block order for mixing
    add_cross4_flag = (ridx == depth - 1) and cross4_enabled
    rev_flag = bool(reverse_block_parity and (ridx % 2 == 1))
    T = apply_round(T, starts, do_interleave=(ridx % 2 == 0), add_cross4=add_cross4_flag, reverse_order=rev_flag)
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
  def build_micro_delta_round(current_T, budget):
    if not current_T or budget <= 8:
      return []

    # Global span
    glo = min(l for l, r in current_T)
    ghi = max(r for l, r in current_T)
    G = max(1, ghi - glo)

    # Sample a thin seed from current_T, evenly spaced to diversify structure.
    # Keep it small and bounded by budget.
    max_seed_by_budget = max(8, min(32, (budget - 4) // 4))
    max_seed_by_len = max(8, len(current_T) // 300)
    seed_sz = min(max_seed_by_budget, max_seed_by_len, 32)
    seed_sz = max(8, seed_sz)
    stride = max(1, len(current_T) // seed_sz)
    U = [current_T[i] for i in range(0, len(current_T), stride)][:seed_sz]
    if not U:
      return []

    ulo = min(l for l, r in U)

    # Four windows across the global span (fractions chosen to stay well inside [glo, ghi])
    # This emulates a small KT-like four-block round at a reduced scale.
    window_fracs = [(0.12, 0.22), (0.35, 0.45), (0.58, 0.68), (0.80, 0.90)]

    # Build translated micro-blocks aligned to these windows
    blocks = []
    for (fa, fb) in window_fracs:
      win_lo = glo + int(round(fa * G))
      win_hi = glo + int(round(fb * G))
      base = win_lo - ulo
      block = [(l + base, r + base) for (l, r) in U]
      blocks.append(block)

    # Interleave micro-blocks to maximize FF mixing
    micro = []
    maxlen = max(len(b) for b in blocks)
    for i in range(maxlen):
      for blk in blocks:
        if i < len(blk):
          micro.append(blk[i])

    # Deterministic connectors across windows (fractional-span analog of KT caps)
    connectors = [
      (glo + int(round(0.08 * G)), glo + int(round(0.30 * G))),  # left cap
      (glo + int(round(0.60 * G)), glo + int(round(0.92 * G))),  # right cap
      (glo + int(round(0.26 * G)), glo + int(round(0.56 * G))),  # cross 1
      (glo + int(round(0.44 * G)), glo + int(round(0.78 * G))),  # cross 2
    ]
    micro.extend(connectors)

    # Trim to available budget
    if len(micro) > budget:
      micro = micro[:budget]
    return micro
=======
  def build_micro_delta_round(current_T, budget, iter_id=0):
    if not current_T or budget <= 8:
      return []

    # Global span
    glo = min(l for l, r in current_T)
    ghi = max(r for l, r in current_T)
    G = max(1, ghi - glo)

    # Sample a thin seed from current_T, evenly spaced to diversify structure.
    # Slightly larger seed and denser than before to increase mixing, still bounded.
    max_seed_by_budget = max(8, min(40, (budget - 4) // 4))
    max_seed_by_len = max(8, len(current_T) // 250)
    seed_sz = min(max_seed_by_budget, max_seed_by_len, 40)
    seed_sz = max(8, seed_sz)
    stride = max(1, len(current_T) // seed_sz)
    U = [current_T[i] for i in range(0, len(current_T), stride)][:seed_sz]
    if not U:
      return []

    ulo = min(l for l, r in U)

    # Four windows across the global span with a small parity-based shift
    shift = (iter_id % 3) * 0.02
    base_windows = [(0.12, 0.22), (0.35, 0.45), (0.58, 0.68), (0.80, 0.90)]
    window_fracs = []
    for (fa, fb) in base_windows:
      a = max(0.05, min(0.90, fa + shift))
      b = max(0.10, min(0.95, fb + shift))
      if b <= a:
        b = min(0.95, a + 0.08)
      window_fracs.append((a, b))

    # Build translated micro-blocks aligned to these windows
    blocks = []
    for (fa, fb) in window_fracs:
      win_lo = glo + int(round(fa * G))
      base = win_lo - ulo
      block = [(l + base, r + base) for (l, r) in U]
      # Alternate internal reversal by block to break symmetry
      if ((int(round(fa * 100)) // 5) + iter_id) % 2 == 1:
        block = list(reversed(block))
      blocks.append(block)

    # Interleave micro-blocks to maximize FF mixing
    micro = []
    maxlen = max(len(b) for b in blocks)
    order = list(range(len(blocks)))
    if iter_id % 2 == 1:
      order.reverse()
    for i in range(maxlen):
      for idx in order:
        blk = blocks[idx]
        if i < len(blk):
          micro.append(blk[i])

    # Deterministic connectors across windows (fractional-span analog of KT caps)
    connectors = [
      (glo + int(round(0.08 * G)), glo + int(round(0.30 * G))),  # left cap
      (glo + int(round(0.60 * G)), glo + int(round(0.92 * G))),  # right cap
      (glo + int(round(0.26 * G)), glo + int(round(0.56 * G))),  # cross 1
      (glo + int(round(0.44 * G)), glo + int(round(0.78 * G))),  # cross 2
    ]
    # Add an extra long-range cross on odd iterations to couple distant layers
    if iter_id % 2 == 1:
      connectors.append((glo + int(round(0.10 * G)), glo + int(round(0.85 * G))))
    micro.extend(connectors)

    # Trim to available budget
    if len(micro) > budget:
      micro = micro[:budget]
    return micro
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
  # Respect requested phase2_iters but guard to a single micro-round by default.
  steps = min(max(0, int(phase2_iters)), 1)
  for _ in range(steps):
    room = CAP - len(T)
    if room <= 8:
      break
    micro = build_micro_delta_round(T, room)
    if not micro:
      break
    # Capacity guard and append
    avail = CAP - len(T)
    if len(micro) > avail:
      micro = micro[:avail]
    T.extend(micro)
=======
  # Respect requested phase2_iters but guard to at most two micro-rounds.
  steps = min(max(0, int(phase2_iters)), 2)
  for iter_id in range(steps):
    room = CAP - len(T)
    if room <= 8:
      break
    micro = build_micro_delta_round(T, room, iter_id=iter_id)
    if not micro:
      break
    # Capacity guard and append
    avail = CAP - len(T)
    if len(micro) > avail:
      micro = micro[:avail]
    T.extend(micro)
>>>>>>> REPLACE

</DIFF>