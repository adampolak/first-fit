--- a/original.py
+++ b/original.py
@@ -1,139 +1,160 @@
 # EVOLVE-BLOCK-START
 
 def construct_intervals():
+  """
+  Deterministic round-robin parity spine with two thin micro-phases.
+  Returns a list of (l, r) integer open intervals for FirstFit.
+  """
+  # Tight capacity to stay near the empirically best regime; keeps < 10000
+  CAP = 9600
+
+  # Fixed four-template bank (round-robin)
+  TEMPLATES = [
+    (2, 6, 10, 14),  # T1: classic KT
+    (1, 5, 9, 13),   # T2: left-shifted
+    (3, 7, 11, 15),  # T3: right-shifted
+    (4, 8, 12, 16),  # T4: alternate wide
+  ]
+
+  # Seed: one unit interval; six rounds fit comfortably under CAP in this scheme.
+  intervals = [(0, 1)]
+
+  def spine_round(curr, starts, ridx, add_cross4=True, interleave_even=True):
     """
-    Construct a sequence of open intervals for FirstFit,
-    maximizing FF colors / clique number via an improved multi-phase strategy.
-    Returns:
-      intervals: list of (l, r) tuples.
+    Apply one parity-aware round using the given start template.
+    connectors: classic + optional cross4.
+    Even rounds: interleave blocks; odd rounds: sequential.
     """
-    CAP = 9800
+    lo = min(l for l, _ in curr)
+    hi = max(r for _, r in curr)
+    delta = max(1, hi - lo)
 
-    # Phase 1: KT‐style spine with rotated templates and alternating multiplier K
-    template_bank = [
-        (2, 6, 10, 14),  # A: classic
-        (1, 5, 9, 13),   # B: left-shifted
-        (3, 7, 11, 15),  # C: right-shifted
-        (4, 8, 12, 16),  # D: alternate
+    # Build four translated blocks
+    blocks = []
+    for s in starts:
+      base = s * delta - lo
+      blk = [(l + base, r + base) for (l, r) in curr]
+      blocks.append(blk)
+
+    # Interleave on even rounds; sequential on odd rounds
+    out = []
+    if interleave_even and (ridx % 2 == 0):
+      m = max(len(b) for b in blocks)
+      for i in range(m):
+        for b in blocks:
+          if i < len(b):
+            out.append(b[i])
+    else:
+      for b in blocks:
+        out.extend(b)
+
+    # Classic four connectors
+    s0, s1, s2, s3 = starts
+    connectors = [
+      ((s0 - 1) * delta, (s1 - 1) * delta),  # left cap
+      ((s2 + 2) * delta, (s3 + 2) * delta),  # right cap
+      ((s0 + 2) * delta, (s2 - 1) * delta),  # cross 1
+      ((s1 + 2) * delta, (s3 - 1) * delta),  # cross 2
     ]
-    K_values = [1, 2]
-    spine_rounds = 6
+    # Add a single cross4 connector on odd rounds only (sparser -> safer for omega)
+    if add_cross4 and (ridx % 2 == 1):
+      connectors.append(((s0 + 4) * delta, (s3 + 4) * delta))
 
-    intervals = [(0, 1)]  # seed
+    out.extend(connectors)
+    return out
 
-    def apply_spine_round(curr, starts, K):
-        lo = min(l for l, _ in curr)
-        hi = max(r for _, r in curr)
-        delta = max(1, hi - lo)
-        out = []
-        # four translated blocks
-        for s in starts:
-            base = s * delta * K - lo
-            for (l, r) in curr:
-                out.append((l + base, r + base))
-        # classic connectors
-        s0, s1, s2, s3 = starts
-        con = [
-            ((s0-1)*delta*K, (s1-1)*delta*K),
-            ((s2+2)*delta*K, (s3+2)*delta*K),
-            ((s0+2)*delta*K, (s2-1)*delta*K),
-            ((s1+2)*delta*K, (s3-1)*delta*K),
-        ]
-        out.extend(con)
-        return out
+  # Stage 1: six spine rounds, round-robin templates with parity behavior.
+  for ridx in range(6):
+    predicted = 4 * len(intervals) + 4
+    if predicted > CAP:
+      break
+    starts = TEMPLATES[ridx % 4]
+    intervals = spine_round(intervals, starts, ridx, add_cross4=True, interleave_even=True)
 
-    # build spine
-    for i in range(spine_rounds):
-        if 4*len(intervals)+4 > CAP:
-            break
-        tpl = template_bank[i % len(template_bank)]
-        K = K_values[i % len(K_values)]
-        intervals = apply_spine_round(intervals, tpl, K)
-    if len(intervals) >= CAP - 16:
-        return intervals
+  # If already near the cap, return the backbone.
+  if len(intervals) >= CAP - 32:
+    return intervals
 
-    # Phase 2: three micro‐rounds at scale divisors 2,3,4
-    def thin_seed(curr, max_seed):
-        n = len(curr)
-        if n == 0 or max_seed <= 0:
-            return []
-        step = max(1, n // max_seed)
-        return curr[::step][:max_seed]
+  # Stage 2: Two ultra-thin micro-phases at divisors 2 and 3.
+  # Thin sampling + parity interleaving; minimal connectors only.
+  def thin_seed(curr, k):
+    n = len(curr)
+    if n == 0 or k <= 0:
+      return []
+    step = max(1, n // k)
+    return curr[::step][:k]
 
-    def micro_round(curr, rid, scale_div, extras):
-        lo = min(l for l, _ in curr)
-        hi = max(r for _, r in curr)
-        G = max(1, hi - lo)
-        delta = max(1, G // scale_div)
-        # sample
-        per = max(8, min(64, len(curr)//50))
-        U = thin_seed(curr, per)
-        if not U:
-            return []
-        # build blocks with parity‐reversal
-        starts = (2, 6, 10, 14)
-        ulo = min(l for l, _ in U)
-        blocks = []
-        for s in starts:
-            base = s * delta - ulo
-            blk = [(l+base, r+base) for (l, r) in U]
-            if (s//2)%2 == rid%2:
-                blk.reverse()
-            blocks.append(blk)
-        # interleave or reverse order
-        out = []
-        order = blocks if rid%2==0 else list(reversed(blocks))
-        mlen = max(len(b) for b in blocks)
-        for i in range(mlen):
-            for b in order:
-                if i < len(b):
-                    out.append(b[i])
-        # connectors: classic + extras
-        s0, s1, s2, s3 = starts
-        con = [
-            ((s0-1)*delta+lo, (s1-1)*delta+lo),
-            ((s2+2)*delta+lo, (s3+2)*delta+lo),
-            ((s0+2)*delta+lo, (s2-1)*delta+lo),
-            ((s1+2)*delta+lo, (s3-1)*delta+lo),
-        ]
-        # extras: list of (i, da, j, db) => (starts[i]+da, starts[j]+db)
-        for (i, da, j, db) in extras:
-            con.append(((starts[i]+da)*delta+lo, (starts[j]+db)*delta+lo))
-        out.extend(con)
-        return out
+  def micro_phase(curr, rid, scale_div, max_budget):
+    if not curr or max_budget <= 0:
+      return []
+    glo = min(l for l, _ in curr)
+    ghi = max(r for _, r in curr)
+    G = max(1, ghi - glo)
+    delta = max(1, G // scale_div)
 
-    subphases = [
-        {'scale_div':2, 'extras':[(0,3,3,3)]},  # cross3
-        {'scale_div':3, 'extras':[(1,4,2,4)]},  # cross4
-        {'scale_div':4, 'extras':[(0,5,3,5)]},  # cross5
+    # Choose a very thin seed to limit growth and omega impact
+    per_block = max(12, min(48, max_budget // 16))
+    U = thin_seed(curr, per_block)
+    if not U:
+      return []
+
+    starts = TEMPLATES[0]  # lock to classic for micro to stabilize geometry
+    ulo = min(l for l, _ in U)
+
+    # Build four translated blocks with internal parity reversal
+    blocks = []
+    for s in starts:
+      base = s * delta - ulo
+      blk = [(l + base, r + base) for (l, r) in U]
+      if ((s // 2) % 2) == (rid % 2):
+        blk = list(reversed(blk))
+      blocks.append(blk)
+
+    out = []
+    # Parity interleaving at micro-level
+    order = blocks if (rid % 2 == 0) else list(reversed(blocks))
+    m = max(len(b) for b in blocks)
+    for i in range(m):
+      for b in order:
+        if i < len(b):
+          out.append(b[i])
+
+    # Minimal connectors (localized)
+    s0, s1, s2, s3 = starts
+    connectors = [
+      ((s0 - 1) * delta + glo, (s1 - 1) * delta + glo),
+      ((s2 + 2) * delta + glo, (s3 + 2) * delta + glo),
+      ((s0 + 2) * delta + glo, (s2 - 1) * delta + glo),
     ]
+    # Gate one cross4 in micro only on rid == 1 (odd parity), to stay sparse
+    if rid % 2 == 1:
+      connectors.append(((s0 + 4) * delta + glo, (s3 + 4) * delta + glo))
+    out.extend(connectors)
 
-    for rid, p in enumerate(subphases):
-        if len(intervals) >= CAP:
-            break
-        bud = CAP - len(intervals)
-        mr = micro_round(intervals, rid, p['scale_div'], p['extras'])
-        if mr:
-            intervals.extend(mr[:bud])
+    # Enforce budget
+    if len(out) > max_budget:
+      out = out[:max_budget]
+    return out
 
-    # Phase 3: final sparse caps
-    if len(intervals) < CAP:
-        lo = min(l for l, _ in intervals)
-        hi = max(r for _, r in intervals)
-        G = max(1, hi - lo)
-        d = max(1, G//3)
-        caps = [
-            (lo + d, lo + 4*d),
-            (hi - 5*d, hi - 2*d),
-            ((lo+hi)//2 - 2*d, (lo+hi)//2 + 3*d),
-        ]
-        rem = CAP - len(intervals)
-        intervals.extend(caps[:rem])
+  # Apply two micro-phases with tight budgets
+  remaining = CAP - len(intervals)
+  if remaining > 0:
+    mp1 = micro_phase(intervals, rid=0, scale_div=2, max_budget=remaining // 2)
+    if mp1:
+      add = mp1[:CAP - len(intervals)]
+      intervals.extend(add)
 
-    return intervals
+  remaining = CAP - len(intervals)
+  if remaining > 0:
+    mp2 = micro_phase(intervals, rid=1, scale_div=3, max_budget=remaining)
+    if mp2:
+      add = mp2[:CAP - len(intervals)]
+      intervals.extend(add)
+
+  return intervals
 
 # EVOLVE-BLOCK-END
 
 def run_experiment(**kwargs):
   """Main called by evaluator"""
   return construct_intervals()