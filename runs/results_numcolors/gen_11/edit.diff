--- a/original.py
+++ b/original.py
@@ -1,60 +1,64 @@
 # EVOLVE-BLOCK-START
 
-def construct_intervals(rounds=2):
+def construct_intervals(rounds=3, seed_lo=0.0, seed_scale=1.0):
   """
-  Construct a sequence of intervals of real line,
-  in the order in which they are presented to FirstFit,
-  so that it tends to maximize the number of colors used by FirstFit
-  divided by the maximum number of intervals that cover a single point
-  through a recursive wave construction.
-
-  The construction generalizes the two-round pattern used in Figure 4 of
-  https://arxiv.org/abs/1506.00192 to a multi-round recursive expansion.
-
+  Deterministic, adaptive multi-round wave construction.
+  - rounds: number of recursive expansion rounds
+  - seed_lo / seed_scale: deterministic knobs for initial placement and scaling
   Returns:
-    intervals: list of tuples, each tuple (l, r) represents an open interval from l to r
+    intervals: list of tuples (l, r) representing open intervals
   """
-  T = [(0, 1)]
+  # Start with a compact core
+  T = [(seed_lo, seed_lo + 1.0 * seed_scale)]
   for round_idx in range(rounds):
+    # Furthest-left/right boundaries of current wave
     lo = min(l for l, r in T)
     hi = max(r for l, r in T)
-    delta = hi - lo
+    delta = hi - lo if hi > lo else 1.0  # avoid degenerate
+
     S = []
-    # In earlier rounds we apply a compact set of shifts; in later rounds,
-    # we widen the set of shifts to inject more waves and increase color usage.
-    # Density-increasing starts: first round uses a core set, subsequent rounds add more starts
+    # Adaptive starts: denser in early rounds, controlled growth later
     if round_idx == 0:
       starts = [2, 4, 6, 8, 10, 12, 14, 16]
     else:
-      starts = [2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 24, 28]
-    for start in starts:
-      S += [(delta * start + l - lo, delta * start + r - lo) for l, r in T]
-    # additional local blocks to create overlapping waves without increasing omega too much
+      # add a few extra starts but cap total to prevent exponential blowup
+      starts = [2, 4, 6, 8, 10, 12, 14, 16, 18, 22, 26]
+
+    # Create translated copies of current T
+    for i, start in enumerate(starts):
+      # Alternate inner order to reduce color re-use
+      base = T if (i % 2 == 0) else list(reversed(T))
+      S += [(delta * start + l - lo, delta * start + r - lo) for l, r in base]
+
+      # Optional light bridging to couple colors across adjacent blocks
+      if i + 1 < len(starts):
+        nxt = starts[i + 1]
+        # bridge spans inside current to inside next block
+        S.append((delta * (start + 0.5), delta * (nxt + 0.5)))
+
+    # Local four-interval gadget to keep omega small but push FF usage
     S += [
-      (delta * 1, delta * 5),
-      (delta * 12, delta * 16),
-      (delta * 4, delta * 9),
-      (delta * 8, delta * 13),
-      # extra caps to push color usage further without bloating omega
-      (delta * 0.5, delta * 2.0),
-      (delta * 14.0, delta * 15.0)
+      (delta * 1.0, delta * 5.0),
+      (delta * 12.0, delta * 16.0),
+      (delta * 4.0, delta * 9.0),
+      (delta * 8.0, delta * 13.0)
     ]
+
+    # Tiny caps to further push color usage without large omega
+    caps = []
+    cap1 = max(1.0, delta * 0.4)
+    cap2 = delta * 1.8
+    # place a few small caps at spaced positions
+    for j in range(3):
+      caps.append((cap1 * (j + 1), cap1 * (j + 1) + cap2 * 0.2))
+    S += caps
+
     T = S
+
   return T
-
-  # return [  # Figure 3, OPT=2, FF=4
-  #   (2,3),
-  #   (6,7),
-  #   (10,11),
-  #   (14,15),
-  #   (1,5),
-  #   (12,16),
-  #   (4,9),
-  #   (8,13),
-  # ]
 
 # EVOLVE-BLOCK-END
 
 def run_experiment(**kwargs):
   """Main called by evaluator"""
   return construct_intervals()