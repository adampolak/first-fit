--- a/original.py
+++ b/original.py
@@ -1,258 +1,244 @@
 # EVOLVE-BLOCK-START
 
 def construct_intervals(enable_alt_microphase=True):
   """
-  Construct a sequence of intervals of real line,
-  in the order in which they are presented to FirstFit,
-  so that it maximizes the number of colors used by FirstFit
-  divided by the maximum number of intervals that cover a single point.
-
-  Deterministic KT-style backbone with two CAP-aware micro-phases and
-  carefully chosen connectors, keeping omega small (target <= 10).
-
-  Args:
-    enable_alt_microphase (bool): enable a second, alternate micro-phase.
-
-  Returns:
-    intervals: list of tuples, each tuple (l, r) represents an open interval from l to r.
+  Deterministic spine-wave with an expanded backbone (six templates),
+  two micro-phases (A and optional B), and deterministic post-phase connectors.
+  Keeps omega under a target bound while maximizing FirstFit color usage.
   """
-
-  # Capacity guard to keep total intervals < 10000
   CAP = 9800
 
-  # Rotating six-start templates for the KT spine (expanded bank for more mixing)
-  template_bank = [
+  # Expanded backbone bank of six templates
+  TEMPLATE_BANK = [
     (2, 6, 10, 14),  # classic KT
     (1, 5, 9, 13),   # left-shifted
     (3, 7, 11, 15),  # right-shifted
     (4, 8, 12, 16),  # stretched-right
-    (5, 9, 13, 17),  # extra right-shift
-    (6, 10, 14, 18), # extra classic-shift
+    (5, 9, 13, 17),  # extra-right
+    (6, 10, 14, 18), # extra-classic
   ]
 
-  # Seed with a single unit interval
+  # Seed spine with a single unit interval
   T = [(0, 1)]
 
-  # Helpers
-  def _span(current_T):
-    lo = min(l for l, r in current_T)
-    hi = max(r for l, r in current_T)
-    delta = hi - lo
-    if delta <= 0:
-      delta = 1
-    return lo, hi, delta
-
-  def _apply_round(current_T, starts, do_interleave=False, reverse_order=False):
-    lo, hi, delta = _span(current_T)
-
-    # Build four translated blocks
+  def span_params(seq):
+    lo = min(l for l, r in seq)
+    hi = max(r for l, r in seq)
+    d = hi - lo
+    if d <= 0:
+      d = 1
+    return lo, hi, d
+
+  def apply_round(curr, starts, interleave=False, reverse_order=False):
+    lo, hi, delta = span_params(curr)
     blocks = []
     for s in starts:
       base = s * delta - lo
-      block = [(l + base, r + base) for (l, r) in current_T]
-      blocks.append(block)
-
-    # Interleaving policy: order derived from 'starts' to diversify per-round mixing
+      blocks.append([(l + base, r + base) for (l, r) in curr])
+
     S = []
-    if do_interleave:
-      # define order by sorting block indices by start values (or reverse)
-      order = sorted(range(4), key=lambda i: starts[i], reverse=reverse_order)
+    if interleave:
+      order = list(range(4))
+      if reverse_order:
+        order = list(reversed(order))
       maxlen = max(len(b) for b in blocks)
       for i in range(maxlen):
         for idx in order:
           blk = blocks[idx]
           if i < len(blk):
             S.append(blk[i])
     else:
       if reverse_order:
         blocks = list(reversed(blocks))
       for blk in blocks:
         S.extend(blk)
 
-    # Classic four connectors (Figure-4 style)
     s0, s1, s2, s3 = starts
     S.append(((s0 - 1) * delta, (s1 - 1) * delta))  # left cap
     S.append(((s2 + 2) * delta, (s3 + 2) * delta))  # right cap
     S.append(((s0 + 2) * delta, (s2 - 1) * delta))  # cross 1
     S.append(((s1 + 2) * delta, (s3 - 1) * delta))  # cross 2
     return S
 
-  # Stage 1: KT spine with rotation and parity policies, capacity-guarded
-  for ridx in range(8):
-    # Predict next size: sz -> 4*sz + 4
-    if 4 * len(T) + 4 > CAP:
+  # Stage 1: Backbone rounds
+  for ridx in range(9):  # up to 9 rounds
+    nxt = 4 * len(T) + 4
+    if nxt > CAP:
       break
-    starts = template_bank[ridx % len(template_bank)]
-    # Interleave on even rounds, reverse block order on odd rounds
-    do_inter = (ridx % 2 == 0)
-    rev = (ridx % 2 == 1)
-    T = _apply_round(T, starts, do_interleave=do_inter, reverse_order=rev)
-
-  # Early exit if nearly at capacity (before micro-phases)
+    starts = TEMPLATE_BANK[ridx % len(TEMPLATE_BANK)]
+    interleave = (ridx % 2 == 0)
+    reverse_order = (ridx % 2 == 1)
+    T = apply_round(T, starts, interleave=interleave, reverse_order=reverse_order)
+    if len(T) >= CAP - 16:
+      break
+
+  # Early exit if near CAP
   if len(T) >= CAP - 8:
-    return T
-
-  # Spine densification: duplicate a thin seed of intervals with slight shrink to boost FF pressure
-  room = CAP - len(T)
-  if room > 16:
-    # Sample a small seed of intervals uniformly from the KT spine
-    stride = max(1, len(T) // 100)
-    seed = [T[i] for i in range(0, len(T), stride)][:10]
-    lo_d, hi_d, span_d = _span(T)
-    eps = max(1, span_d // 1000)
-    densify = []
-    for (l, r) in seed:
-      if r - l > 2 * eps:
-        densify.append((l + eps, r - eps))
-    # Insert densified intervals if capacity allows
-    for iv in densify:
+    return normalize_and_cap(T)
+
+  # Densification: safe splitting of long intervals to create more colors without increasing omega
+  if len(T) < CAP - 40:
+    candidates = [i for i, (l, r) in enumerate(T) if (r - l) > 6][:8]
+    for idx in sorted(candidates, reverse=True):
+      l, r = T[idx]
+      mid = (l + r) // 2
+      if mid > l:
+        T[idx] = (l, mid)
+        T.insert(idx + 1, (mid, r))
       if len(T) >= CAP:
         break
-      T.append(iv)
-
-  # Micro-phase A: add three long-range caps to boost FF pressure (capacity-safe)
-  lo, hi, _ = _span(T)
-  span = max(1, hi - lo)
+
+  lo, hi, span_ = span_params(T)
+
   def cap_at(a_frac, b_frac):
-    L = lo + max(1, int(round(a_frac * span)))
-    R = lo + max(1, int(round(b_frac * span)))
+    L = lo + max(1, int(round(a_frac * span_)))
+    R = lo + max(1, int(round(b_frac * span_)))
     if R <= L:
       R = L + 1
     return (L, R)
+
+  # Micro-phase A: three long-range caps
   caps = [cap_at(0.08, 0.60), cap_at(0.25, 0.75), cap_at(0.75, 0.92)]
   for c in caps:
     if len(T) >= CAP:
       break
-    T.append(c)
-
-  # Micro-phase builder: thin-window replication with connectors
-  def build_micro_delta_round(current_T, budget, alt=False):
-    if not current_T or budget <= 8:
+    if c[1] > c[0]:
+      T.append(c)
+
+  # Micro-phase builder for windowed micro-blocks
+  def build_micro(curr, budget, windows, alt=False, long_cross=False, seed_boost=False):
+    if not curr or budget <= 0:
       return []
-
-    glo = min(l for l, r in current_T)
-    ghi = max(r for l, r in current_T)
+    glo = min(l for l, r in curr)
+    ghi = max(r for l, r in curr)
     G = max(1, ghi - glo)
 
-    # Thin, evenly spaced seed
-    seed_sz = max(8, min(32, len(current_T) // 300))
-    if alt:
-      seed_sz = max(8, min(40, len(current_T) // 250))
-    stride = max(1, len(current_T) // max(1, seed_sz))
-    U = [current_T[i] for i in range(0, len(current_T), stride)][:seed_sz]
+    base_seed = max(6, min(40, len(curr) // 120))
+    seed_sz = base_seed + (4 if seed_boost else 0)
+    seed_sz = min(seed_sz, 60)
+
+    stride = max(1, len(curr) // seed_sz)
+    U = [curr[i] for i in range(0, len(curr), stride)][:seed_sz]
     if not U:
       return []
 
     ulo = min(l for l, r in U)
 
-    # Four windows across the span (stay inside to control omega)
-    if not alt:
-      window_fracs = [(0.12, 0.22), (0.35, 0.45), (0.58, 0.68), (0.80, 0.90)]
-    else:
-      window_fracs = [(0.05, 0.15), (0.28, 0.38), (0.60, 0.70), (0.82, 0.92)]
-
-    # Build translated micro-blocks aligned to these windows
     blocks = []
-    for (fa, fb) in window_fracs:
+    for (fa, fb) in windows:
+      fa = max(0.05, min(0.95, fa))
+      fb = max(0.10, min(0.95, fb))
       win_lo = glo + int(round(fa * G))
       base = win_lo - ulo
       block = [(l + base, r + base) for (l, r) in U]
-      # Internal reversal on alternating pattern for alt-phase to diversify
-      if alt and int(round(fa * 100)) // 5 % 2 == 1:
-        block = list(reversed(block))
+      if alt:
+        tag = (int(round(fa * 100)) // 5) % 2
+        if tag == 1:
+          block = list(reversed(block))
       blocks.append(block)
 
-    # Interleave micro-blocks to maximize FF mixing
     micro = []
-    maxlen = max(len(b) for b in blocks)
+    maxlen = max((len(b) for b in blocks), default=0)
+    if not blocks:
+      return []
     if not alt:
-      # forward interleave
       for i in range(maxlen):
         for blk in blocks:
           if i < len(blk):
             micro.append(blk[i])
     else:
-      # reverse interleave
       for i in range(maxlen):
         for blk in reversed(blocks):
           if i < len(blk):
             micro.append(blk[i])
 
-    # Fractional-span connectors at the micro scale
-    micro_connectors = [
-      (glo + int(round(0.08 * G)), glo + int(round(0.30 * G))),  # left cap
-      (glo + int(round(0.60 * G)), glo + int(round(0.92 * G))),  # right cap
-      (glo + int(round(0.26 * G)), glo + int(round(0.56 * G))),  # cross 1
-      (glo + int(round(0.44 * G)), glo + int(round(0.78 * G))),  # cross 2
+    connectors = [
+      (glo + int(round(0.08 * G)), glo + int(round(0.30 * G))),
+      (glo + int(round(0.60 * G)), glo + int(round(0.92 * G))),
+      (glo + int(round(0.26 * G)), glo + int(round(0.56 * G))),
+      (glo + int(round(0.44 * G)), glo + int(round(0.78 * G))),
     ]
-    for a, b in micro_connectors:
+    for a, b in connectors:
       if b > a:
         micro.append((a, b))
 
-    # A long cross to tie distant colors (alt-phase only)
-    if alt:
+    if long_cross:
       a = glo + int(round(0.18 * G))
       b = glo + int(round(0.84 * G))
       if b > a:
         micro.append((a, b))
 
-    # Trim to available budget
     if len(micro) > budget:
       micro = micro[:budget]
     return micro
 
-  # Micro-phase B: one safeguarded micro-round (empirically strong for 2.30-tier results)
   room = CAP - len(T)
   if room > 8:
-    micro = build_micro_delta_round(T, room, alt=False)
-    if micro:
-      if len(micro) > room:
-        micro = micro[:room]
-      T.extend(micro)
-
-  # Micro-phase C: alternate window family + long cross (guarded, optional)
+    budgetA = max(0, int(room * 0.60))
+    microA = build_micro(T, budgetA, windows=[(0.12,0.22),(0.35,0.45),(0.58,0.68),(0.80,0.90)], alt=False, long_cross=False, seed_boost=False)
+    if microA:
+      avail = CAP - len(T)
+      if len(microA) > avail: microA = microA[:avail]
+      T.extend(microA)
+
   room = CAP - len(T)
   if enable_alt_microphase and room > 8:
-    micro_alt = build_micro_delta_round(T, room, alt=True)
-    if micro_alt:
-      if len(micro_alt) > room:
-        micro_alt = micro_alt[:room]
-      T.extend(micro_alt)
-
-  # Micro-phase D: tower pins (short, staggered intervals) to increase FF pressure
-  # without inflating omega; placed in four interior windows and spaced to be disjoint.
+    budgetB = room
+    microB = build_micro(T, budgetB, windows=[(0.06,0.14),(0.28,0.38),(0.54,0.64),(0.74,0.84)], alt=True, long_cross=True, seed_boost=True)
+    if microB:
+      avail = CAP - len(T)
+      if len(microB) > avail: microB = microB[:avail]
+      T.extend(microB)
+
+  # Post-micro deterministic connectors
   room = CAP - len(T)
-  if room > 8:
-    glo = min(l for l, r in T)
-    ghi = max(r for l, r in T)
-    G = max(1, ghi - glo)
-    eps = max(1, G // 4096)  # very short pins
-    windows = [0.14, 0.31, 0.66, 0.83]
-    # Limit per-window pins to keep total bounded and spacing clean
-    max_per_win = max(4, min(64, room // max(1, len(windows))))
-    stride = max(2 * eps + 3, 3)
-    pins = []
-    for wi, w in enumerate(windows):
-      base = glo + int(round(w * G))
-      start = base - (max_per_win // 2) * stride + (wi % 3)
-      for j in range(max_per_win):
-        L = start + j * stride
-        R = L + eps
-        if R > L:
-          pins.append((L, R))
-    if pins:
-      if len(pins) > room:
-        pins = pins[:room]
-      T.extend(pins)
-
-  # Final capacity trim
-  if len(T) > CAP:
-    T = T[:CAP]
-
-  return T
+  if room > 0:
+    lr = []
+    lo2, hi2, d2 = span_params(T)
+    anchors = [
+      (0.12, 0.62),
+      (0.22, 0.78),
+      (0.38, 0.86),
+      (0.48, 0.90),
+      (0.30, 0.70),
+      (0.15, 0.85),
+    ]
+    rot = 0
+    for i in range(min(room, len(anchors))):
+      a, b = anchors[(rot + i) % len(anchors)]
+      L = lo2 + max(1, int(round(a * d2)))
+      R = lo2 + max(1, int(round(b * d2)))
+      if R > L:
+        lr.append((L, R))
+    if lr:
+      if len(lr) > room:
+        lr = lr[:room]
+      T.extend(lr)
+
+  return normalize_and_cap(T)
+
+def run_experiment(**kwargs):
+  return construct_intervals(enable_alt_microphase=kwargs.get('enable_alt_microphase', True))
+
+def normalize_and_cap(seq):
+  if not seq:
+    return []
+  lo = min(l for l, r in seq)
+  if lo < 0:
+    seq = [(l - lo, r - lo) for (l, r) in seq]
+  out = []
+  for l, r in seq:
+    li = int(round(l))
+    ri = int(round(r))
+    if ri <= li:
+      ri = li + 1
+    out.append((li, ri))
+  if len(out) > 9800:
+    out = out[:9800]
+  return out
 
 # EVOLVE-BLOCK-END
 
 def run_experiment(**kwargs):
   """Main called by evaluator"""
   return construct_intervals()