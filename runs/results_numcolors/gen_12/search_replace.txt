<NAME>
template_cycle_multi_seed_expansion
</NAME>

<DESCRIPTION>
I propose a targeted improvement of the recursive "wave" construction to raise FirstFit pressure while keeping the clique number (omega) small.

Key ideas:
- Seed the construction with a small set of disjoint unit intervals instead of a single (0,1). This gives richer early structure that often increases color pressure without increasing omega much.
- Use a small bank of four block templates (variations of the four-interval gadget). Choosing a different template each round breaks self-similarity and can expose FirstFit to novel overlaps that force new colors.
- Cycle the translation starts across rounds using a short deterministic list of start patterns. This diversifies the placement of translated copies so overlaps between rounds are less regular and can increase the number of colors FirstFit uses.
- Increase default rounds to 3 to allow one more expansion iteration (keeps total intervals under the 10k budget for reasonable templates).
- Keep construction deterministic and fully reproducible.

I kept the edit local to the EVOLVE block and preserved the original function API but with a different default rounds. The replacement is conservative (no randomness) yet introduces structural diversity that heuristically raises FF usage while not drastically increasing omega.

Arguments: Seeding with a few disjoint units increases coupling between translated copies, template variability prevents FirstFit from reusing the same low color pattern across scales, and cyclic starts shift where new waves land relative to previous blocks. These heuristics were recommended in the prompt and are implemented here together.

</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
def construct_intervals(rounds=2):
  """
  Construct a sequence of intervals of real line,
  in the order in which they are presented to FirstFit,
  so that it tends to maximize the number of colors used by FirstFit
  divided by the maximum number of intervals that cover a single point
  through a recursive wave construction.

  The construction generalizes the two-round pattern used in Figure 4 of
  https://arxiv.org/abs/1506.00192 to a multi-round recursive expansion.

  Returns:
    intervals: list of tuples, each tuple (l, r) represents an open interval from l to r
  """
  T = [(0, 1)]
  for round_idx in range(rounds):
    lo = min(l for l, r in T)
    hi = max(r for l, r in T)
    delta = hi - lo
    S = []
    # In earlier rounds we apply a compact set of shifts; in later rounds,
    # we widen the set of shifts to inject more waves and increase color usage.
    # Use a denser set of shifts each round to amplify FirstFit pressure
    starts = [2, 4, 6, 8, 10, 12, 14, 16]
    for start in starts:
      S += [(delta * start + l - lo, delta * start + r - lo) for l, r in T]
    # additional local blocks to create overlapping waves without increasing omega too much
    S += [
      (delta * 1, delta * 5),
      (delta * 12, delta * 16),
      (delta * 4, delta * 9),
      (delta * 8, delta * 13)
    ]
    T = S
  return T

  # return [  # Figure 3, OPT=2, FF=4
  #   (2,3),
  #   (6,7),
  #   (10,11),
  #   (14,15),
  #   (1,5),
  #   (12,16),
  #   (4,9),
  #   (8,13),
  # ]
=======
def construct_intervals(rounds=3):
  """
  Construct a sequence of intervals of real line,
  in the order in which they are presented to FirstFit,
  so that it tends to maximize the number of colors used by FirstFit
  divided by the maximum number of intervals that cover a single point
  through a recursive wave construction.

  Improvements over the previous version:
  - start with multiple disjoint unit intervals to seed richer early overlaps
  - use a small bank of four-interval "templates" and pick a template per round
    (breaks strict self-similarity)
  - cycle through a list of start-patterns across rounds so translated copies
    land in different relative offsets each round
  - default to 3 rounds to allow one more expansion (still modest total size)
  """
  # seed with several disjoint unit intervals (keeps omega small but provides coupling)
  T = [(0, 1), (2, 3), (4, 5), (6, 7)]

  # a small bank of four-interval templates (variants of the gadget)
  templates = [
    # template A: original pattern
    [(1, 5), (12, 16), (4, 9), (8, 13)],
    # template B: shifted variant
    [(0.5, 4.5), (11, 15), (3.5, 8.5), (7, 12)],
    # template C: tighter local overlaps
    [(1, 4), (6, 9), (3, 7), (9, 13)],
    # template D: staggered caps
    [(2, 6), (7, 11), (0, 3), (10, 14)]
  ]

  # a short deterministic cycle of start patterns (each element is a tuple/list of starts)
  start_patterns = [
    (2, 6, 10, 14),             # compact 4-wave pattern
    (2, 4, 6, 8, 10, 12, 14, 16),  # denser pattern
    (2, 5, 8, 11, 14, 17, 20),  # staggered 7-wave
  ]

  for round_idx in range(rounds):
    lo = min(l for l, r in T)
    hi = max(r for l, r in T)
    delta = hi - lo
    S = []

    # choose start pattern and template deterministically based on round index
    starts = list(start_patterns[round_idx % len(start_patterns)])
    template = templates[round_idx % len(templates)]

    # vary the inner order of clones to make FirstFit reuse harder
    for idx, start in enumerate(starts):
      if idx % 2 == 0:
        base = T
      else:
        base = list(reversed(T))
      S += [(delta * start + l - lo, delta * start + r - lo) for l, r in base]

    # place the chosen template intervals scaled by delta
    S += [(delta * a, delta * b) for (a, b) in template]

    # add a few sparse caps that span small neighborhoods of starts to couple colors
    # without raising omega too much
    max_start = max(starts)
    for j in range(2, max_start, max(3, int(max_start // 6))):
      S.append((delta * (j - 0.5), delta * (j + 1.5)))

    T = S

  return T

  # return [  # Figure 3, OPT=2, FF=4
  #   (2,3),
  #   (6,7),
  #   (10,11),
  #   (14,15),
  #   (1,5),
  #   (12,16),
  #   (4,9),
  #   (8,13),
  # ]
>>>>>>> REPLACE
</DIFF>