--- a/original.py
+++ b/original.py
@@ -1,113 +1,115 @@
 # EVOLVE-BLOCK-START
 
 def _span_delta(T):
   lo = min(l for l, _ in T)
   hi = max(r for _, r in T)
   delta = hi - lo
   if delta <= 0:
     delta = 1
   return lo, hi, delta
 
 def _build_blocks_sequential(T, starts, delta, lo, K=1):
   """
   Build four translated blocks sequentially. No interleaving. This ordering
   is known to amplify FirstFit color pressure. K is a tunable spacing multiplier (default 1).
   """
   S = []
   for s in starts:
     base = s * delta * K - lo
     S.extend((l + base, r + base) for (l, r) in T)
   return S
 
 def _append_connectors(S, starts, delta, add_cross4=False):
   """
   Append the classic four connectors. Optionally add a single long-range cross4
   on the final round to improve pressure while keeping total size under CAP.
   """
   s0, s1, s2, s3 = starts
   S.append(((s0 - 1) * delta, (s1 - 1) * delta))  # left cap
   S.append(((s2 + 2) * delta, (s3 + 2) * delta))  # right cap
   S.append(((s0 + 2) * delta, (s2 - 1) * delta))  # cross 1
   S.append(((s1 + 2) * delta, (s3 - 1) * delta))  # cross 2
   if add_cross4:
     S.append(((s0 + 4) * delta, (s3 + 4) * delta))  # long-range cross (final-round only)
 
 def _append_micro_tail(T, max_extra=8):
   """
   Append a tiny tail of long caps near the end of T. This boosts FF late with minimal
   impact on omega. Caps are inserted near the end (rather than simply appended) to
   intersect many active colors while avoiding a single dense core.
   """
   if not T or max_extra <= 0:
     return T
   lo, hi, delta = _span_delta(T)
   d2 = max(1, delta // 4)
   # Symmetric, sparse long caps
   micro = [
       (lo + 1 * d2, lo + 5 * d2),
       (lo + 3 * d2, lo + 8 * d2),
       (hi - 6 * d2, hi - 2 * d2),
       (hi - 8 * d2, hi - 3 * d2),
   ]
   # Insert near the tail in a staggered fashion
   for i, interval in enumerate(micro[:max_extra]):
     pos = len(T) - (i * 2 + 1)
     if pos < 0:
       T.append(interval)
     else:
       T.insert(pos, interval)
   return T
 
 def construct_intervals(seed_count=1):
   """
   Construct a sequence of open intervals (l, r), in FirstFit arrival order,
   aiming to maximize FirstFit colors relative to the clique number.
 
   Interface preserved from prior versions.
   """
   CAP = 9800
 
   # Four-template spine bank: deterministic round-robin selection
   template_bank = [
     (2, 6, 10, 14),  # T1 classic KT
     (1, 5, 9, 13),   # T2 left-shifted
     (3, 7, 11, 15),  # T3 right-shifted
     (4, 8, 12, 16),  # T4 stretched right
   ]
 
   # Seed: keep single unit interval to avoid early omega inflation
   if seed_count <= 1:
     T = [(0, 1)]
   else:
     # Deterministic sparse multi-seed (guarded); still small to protect omega
     step = 3
     T = [(i * step, i * step + 1) for i in range(max(1, int(seed_count)))]
     T = T[:4]  # cap to 4 seeds deterministically
 
   # Main spine: exactly six rounds when under CAP; sequential blocks; classic connectors.
   rounds = 6
   for ridx in range(rounds):
     lo, hi, delta = _span_delta(T)
     starts = template_bank[ridx % 4]
-    S = _build_blocks_sequential(T, starts, delta, lo, K=1)
-    # Add connectors; only the last round gets a single extra cross4 (keeps count < CAP)
-    _append_connectors(S, starts, delta, add_cross4=(ridx == rounds - 1))
+    # Adaptive density: use K=2 in later rounds to pack blocks more tightly
+    K = 2 if ridx >= 3 else 1
+    S = _build_blocks_sequential(T, starts, delta, lo, K=K)
+    # Add connectors; enable long-range cross4 in the deepest two rounds for extra mixing
+    _append_connectors(S, starts, delta, add_cross4=(ridx >= rounds - 2))
     T = S
     if len(T) >= CAP:
       # Should not happen with this recurrence, but guard anyway
       T = T[:CAP]
       return T
 
   # Tiny micro tail: safe and capacity-bounded
   room = CAP - len(T)
   if room > 0:
     # Insert at most 8 extras or available room, whichever is smaller
     T = _append_micro_tail(T, max_extra=min(8, room))
 
   return T
 
 # EVOLVE-BLOCK-END
 
 def run_experiment(**kwargs):
   """Main called by evaluator"""
   return construct_intervals()