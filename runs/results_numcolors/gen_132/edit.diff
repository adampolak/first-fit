--- a/original.py
+++ b/original.py
@@ -1,148 +1,187 @@
 # EVOLVE-BLOCK-START
 
 def construct_intervals(rounds=6,
                         rotate_starts=True,
                         reverse_block_parity=True,
                         interleave_blocks=True,
                         phase2_iters=1):
-  """
-  Deterministic KT-style spine with a safeguarded two-phase scaffold.
+    """
+    Construct intervals to maximize FirstFit colors / clique number.
+    Implements:
+      - Two-seed start
+      - 4-template rotated KT-spine with multiplier K
+      - Cross4 connectors
+      - Three-scale micro-phase (delta2, delta2, delta4)
+    """
+    CAP = 9800
 
-  Parameters:
-    rounds (int): main expansion depth; near 6 yields ~9556 intervals for a single-seed KT spine.
-    rotate_starts (bool): available but disabled in the safeguarded spine mode.
-    reverse_block_parity (bool): available but disabled in the safeguarded spine mode.
-    interleave_blocks (bool): available but disabled in the safeguarded spine mode.
-    phase2_iters (int): requested micro iterations; actual application is strictly capacity- and safety-gated.
+    # Two non-overlapping seeds to avoid early ω inflation
+    T = [(0, 1), (3, 4)]
 
-  Returns:
-    intervals: list of (l, r) integer tuples, open intervals, in FF presentation order.
-  """
+    # 4-template bank for spine rotations
+    template_bank = [
+        [2, 6, 10, 14],
+        [1, 5, 9, 13],
+        [3, 7, 11, 15],
+        [4, 8, 12, 16],
+    ]
+    K = 2  # multiplier on spine translations
 
-  # Hard capacity guard to keep the total count < 10000
-  CAP = 9800
+    # Stage 1: rotated KT-style spine with cross4
+    def next_size(sz):
+        return 4 * sz + 4
+    depth = 0
+    size = len(T)
+    # find max spine rounds within CAP
+    while depth < rounds and next_size(size) <= CAP:
+        size = next_size(size)
+        depth += 1
 
-  # Stable KT-spine start pattern (proven strong in prior runs)
-  spine_starts = [2, 6, 10, 14]
+    for r in range(depth):
+        starts = template_bank[r % len(template_bank)] if rotate_starts else template_bank[0]
+        lo = min(l for (l, _) in T)
+        hi = max(r_ for (_, r_) in T)
+        delta = max(1, hi - lo)
 
-  # Optional template bank for exploratory use in micro/secondary phase
-  # (kept dormant by default to preserve the strong baseline).
-  template_bank = [
-    [2, 6, 10, 14],  # A: classic KT
-    [1, 5, 9, 13],   # B: left-shifted
-    [3, 7, 11, 15],  # C: right-shifted
-    [2, 4, 8, 12],   # D: compressed left pair
-    [3, 5, 9, 13],   # E: gentle left pack
-    [1, 7, 11, 15],  # F: wide skew
-    [2, 8, 10, 12],  # G: inner symmetric
-    [4, 6, 8, 10],   # H: tight middle
-  ]
+        # build 4 translated blocks
+        blocks = []
+        for idx, s in enumerate(starts):
+            src = list(reversed(T)) if (reverse_block_parity and idx % 2 == 1) else T
+            base = s * delta * K - lo
+            blocks.append([(l + base, r_ + base) for (l, r_) in src])
 
-  # Seed with one unit interval to allow six KT rounds within CAP.
-  T = [(0, 1)]
+        # interleave or concatenate
+        S = []
+        if interleave_blocks:
+            maxlen = max(len(b) for b in blocks)
+            order = list(range(len(blocks)))
+            # rotate block order to avoid patterns
+            shift = r % len(order)
+            order = order[shift:] + order[:shift]
+            for i in range(maxlen):
+                for j in order:
+                    if i < len(blocks[j]):
+                        S.append(blocks[j][i])
+        else:
+            for blk in blocks:
+                S.extend(blk)
 
-  # Predictive size accounting to cap the number of full rounds.
-  # KT growth per round: size -> 4*size + 4
-  def round_next_size(sz):
-    return 4 * sz + 4
+        # classic connectors + cross4
+        s0, s1, s2, s3 = starts[:4]
+        connectors = [
+            ((s0 - 1) * delta * K, (s1 - 1) * delta * K),
+            ((s2 + 2) * delta * K, (s3 + 2) * delta * K),
+            ((s0 + 2) * delta * K, (s2 - 1) * delta * K),
+            ((s1 + 2) * delta * K, (s3 - 1) * delta * K),
+            ((s0 + 4) * delta * K, (s3 + 4) * delta * K),  # cross4
+        ]
+        S.extend(connectors)
+        T = S
 
-  def max_rounds_within_cap(initial_size, max_rounds):
-    sz = initial_size
-    done = 0
-    for _ in range(max(0, int(max_rounds))):
-      nxt = round_next_size(sz)
-      if nxt > CAP:
-        break
-      sz = nxt
-      done += 1
-    return done, sz
+    # Stage 2: multi-scale micro rounds (delta2, delta2, delta4)
+    def thin_seed(U, m):
+        n = len(U)
+        if n == 0 or m <= 0:
+            return []
+        step = max(1, n // m)
+        return U[::step][:m]
 
-  # Stage 1: KT spine, un-interleaved, classic connectors, capacity-safe depth.
-  depth, size_est = max_rounds_within_cap(len(T), rounds)
+    def micro_round(curr, round_id, scale_div):
+        if not curr:
+            return []
+        lo = min(l for (l, _) in curr)
+        hi = max(r_ for (_, r_) in curr)
+        G = max(1, hi - lo)
+        delta = max(1, G // scale_div)
 
-  def apply_round(current_T, starts):
-    # Compute span and delta
-    lo = min(l for l, r in current_T)
-    hi = max(r for l, r in current_T)
-    delta = hi - lo
-    if delta <= 0:
-      delta = 1
+        # budget-aware thin sampling
+        budget = CAP - len(curr)
+        per = max(8, min(64, budget // 12))
+        U = thin_seed(curr, per)
+        if not U:
+            return []
 
-    # Build four translated blocks sequentially (no interleaving)
-    S = []
-    for s in starts:
-      base = s * delta - lo
-      # No parity reversal here: spine mode
-      S.extend((l + base, r + base) for (l, r) in current_T)
+        # build four micro blocks with parity reversal
+        micro = []
+        ulo = min(l for (l, _) in U)
+        micro_starts = template_bank[0]  # classic pattern
+        blocks = []
+        for idx, s in enumerate(micro_starts):
+            base = s * delta - ulo
+            blk = [(l + base, r_ + base) for (l, r_) in U]
+            if ((s // 2) % 2) == (round_id % 2):
+                blk = list(reversed(blk))
+            blocks.append(blk)
 
-    # Classic connectors that preserve the desired FF pressure without
-    # blowing up omega when used with spine_starts:
-    s0, s1, s2, s3 = starts
-    connectors = [
-      ((s0 - 1) * delta, (s1 - 1) * delta),
-      ((s2 + 2) * delta, (s3 + 2) * delta),
-      ((s0 + 2) * delta, (s2 - 1) * delta),
-      ((s1 + 2) * delta, (s3 - 1) * delta),
-    ]
-    S.extend(connectors)
-    return S
+        if round_id % 2 == 0:
+            maxlen = max(len(b) for b in blocks)
+            for i in range(maxlen):
+                for blk in blocks:
+                    if i < len(blk):
+                        micro.append(blk[i])
+        else:
+            maxlen = max(len(b) for b in blocks)
+            for i in range(maxlen):
+                for blk in reversed(blocks):
+                    if i < len(blk):
+                        micro.append(blk[i])
 
-  for _ in range(depth):
-    T = apply_round(T, spine_starts)
+        # connectors cross1-3 + cross4
+        s0, s1, s2, s3 = micro_starts[:4]
+        conn = [
+            ((s0 - 1) * delta + lo, (s1 - 1) * delta + lo),
+            ((s2 + 2) * delta + lo, (s3 + 2) * delta + lo),
+            ((s0 + 2) * delta + lo, (s2 - 1) * delta + lo),
+            ((s1 + 2) * delta + lo, (s3 - 1) * delta + lo),
+            ((s0 + 3) * delta + lo, (s3 + 3) * delta + lo),
+            ((s0 + 4) * delta + lo, (s3 + 4) * delta + lo),  # cross4
+        ]
+        micro.extend(conn)
 
-  # If we already reached or are near the cap, skip phase 2 safely.
-  if len(T) >= CAP - 16:
-    return T
+        # sparse caps
+        cap1 = (lo + delta // 4, lo + int(1.8 * delta))
+        cap2 = (lo + int(0.9 * delta), lo + int(2.6 * delta))
+        mid = lo + G // 2
+        cap3 = (mid - max(1, delta // 8), mid + max(1, delta // 8))
+        for cap in (cap1, cap2, cap3):
+            if cap[1] > cap[0]:
+                micro.append(cap)
 
-  # Stage 2 (safeguarded): attempt up to phase2_iters micro steps using a smaller delta2.
-  # To avoid harming the strong KT baseline, we:
-  #  - require enough residual capacity,
-  #  - use at most one light-touch micro step by default,
-  #  - place micro additions as sparse long caps that do not densify the core "spine."
-  def micro_caps(current_T, intensity=1):
-    if not current_T:
-      return []
-    lo = min(l for l, r in current_T)
-    hi = max(r for l, r in current_T)
-    delta = max(1, hi - lo)
-    d2 = max(1, delta // 3)
+        # enforce budget
+        if len(micro) > budget:
+            micro = micro[:budget]
+        return micro
 
-    # Two very sparse long caps placed away from the densest overlap
-    caps = [
-      (lo + 1 * d2, lo + 5 * d2),
-      (hi - 6 * d2, hi - 2 * d2),
-    ]
-    # intensity>1 adds a symmetric mid cap pair (still light)
-    if intensity > 1:
-      mid = (lo + hi) // 2
-      caps += [
-        (mid - 2 * d2, mid + 2 * d2),
-      ]
-    return caps
+    # run micro rounds
+    for rid, div in enumerate([2, 2, 4]):
+        if len(T) >= CAP:
+            break
+        mr = micro_round(T, rid, div)
+        if mr:
+            T.extend(mr)
 
-  # Compute how many safe micro intervals we can add
-  # Respect requested phase2_iters, but safeguard with CAP and keep additions tiny.
-  micro_steps = max(0, int(phase2_iters))
-  # Each step adds at most 2–3 caps; plan conservatively.
-  add_per_step = 2
-  max_steps_by_cap = max(0, (CAP - len(T)) // add_per_step)
+    # normalize to non-negative integers
+    if T:
+        min_l = min(l for (l, _) in T)
+        if min_l < 0:
+            T = [(l - min_l, r_ - min_l) for (l, r_) in T]
 
-  steps = min(micro_steps, max_steps_by_cap, 1)  # at most 1 guarded micro pass by default
-  for k in range(steps):
-    # keep micro intensity very low to avoid increasing omega
-    caps = micro_caps(T, intensity=1 if k == 0 else 1)
-    # capacity guard
-    room = CAP - len(T)
-    if room <= 0:
-      break
-    if len(caps) > room:
-      caps = caps[:room]
-    T.extend(caps)
+    intervals = []
+    for (l, r_) in T:
+        li = int(round(l))
+        ri = int(round(r_))
+        if ri <= li:
+            ri = li + 1
+        intervals.append((li, ri))
 
-  return T
+    # cap total intervals
+    if len(intervals) > CAP:
+        intervals = intervals[:CAP]
+
+    return intervals
 
 # EVOLVE-BLOCK-END
 
 def run_experiment(**kwargs):
   """Main called by evaluator"""
   return construct_intervals()