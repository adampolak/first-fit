--- a/original.py
+++ b/original.py
@@ -1,347 +1,351 @@
 # EVOLVE-BLOCK-START
 
 def construct_intervals(rounds=6,
                         rotate_starts=True,
                         reverse_block_parity=True,
                         interleave_blocks=True,
                         phase2_iters=2,
                         seed_count=1):
   """
   Crossover construction combining KT-style spine + diversified multi-seed micro phases.
 
   Parameters:
     rounds (int): desired KT expansion depth (predictive cap may reduce actual rounds).
     rotate_starts (bool): rotate among strong start templates when True.
     reverse_block_parity (bool): flip block order parity to diversify arrival order.
     interleave_blocks (bool): allow interleaving of translated blocks on selected rounds.
     phase2_iters (int): up to two delta-scale micro rounds (CAP-guarded).
     seed_count (int): optional small multi-seed (keeps early omega low but richer coupling).
 
   Returns:
     intervals: list of (l, r) integer tuples in FF presentation order.
   """
 
   # Hard capacity guard to keep total count < 10000
   CAP = 9800
 
   # Template bank for KT-like rounds (rotated)
   template_bank = [
     (2, 6, 10, 14),  # classic KT
     (1, 5, 9, 13),   # left-shift
     (3, 7, 11, 15),  # right-shift
     (4, 8, 12, 16),  # stretched-right
+    (0, 4, 8, 12),   # compressed-left
+    (1, 4, 9, 13),   # extra varied
   ]
 
   # Secondary small connector bank (diversified templates used by the light-bridge rounds)
   connector_bank = [
     ((1, 5), (12, 16), (4, 9), (8, 13)),
     ((0, 4), (11, 15), (3, 8), (7, 12)),
     ((1, 4), (6, 9), (3, 7), (9, 13)),
     ((2, 6), (7, 11), (0, 3), (10, 14)),
   ]
 
   # Seed initialization: either single unit interval (classic KT) or a few sparse seeds
   if seed_count <= 1:
     T = [(0, 1)]
   else:
     # deterministic sparse multi-seed, limit to avoid early clique blow-up
-    seeds = min(4, max(1, int(seed_count)))
-    step = 3
+    seeds = min(6, max(2, int(seed_count)))
+    step = 4
     T = [(i * step, i * step + 1) for i in range(seeds)]
 
   # Utility: compute span and guard minimal delta
   def _span_delta(current_T):
     lo = min(l for l, r in current_T)
     hi = max(r for l, r in current_T)
     delta = hi - lo
     if delta <= 0:
       delta = 1
     return lo, hi, int(delta)
 
   # Classic KT connectors (scale-preserving integer endpoints)
   def _append_kt_connectors(S, starts, delta, lo):
-    s0, s1, s2, s3 = starts
-    # scale by delta and shift by lo to keep integer coordinates consistent
+    if len(starts) >= 4:
+      s0, s1, s2, s3 = starts[0], starts[1], starts[2], starts[3]
+    else:
+      s0, s1, s2, s3 = 2, 6, 10, 14
     S.append(((s0 - 1) * delta + lo, (s1 - 1) * delta + lo))  # left cap
     S.append(((s2 + 2) * delta + lo, (s3 + 2) * delta + lo))  # right cap
     S.append(((s0 + 2) * delta + lo, (s2 - 1) * delta + lo))  # cross 1
     S.append(((s1 + 2) * delta + lo, (s3 - 1) * delta + lo))  # cross 2
 
   # Apply one KT-style round: translate blocks, optionally interleave/reverse, append connectors
   def _apply_kt_round(current_T, starts, do_interleave=False, reverse_order=False):
     lo, hi, delta = _span_delta(current_T)
 
     # Build four translated blocks (integer arithmetic)
     blocks = []
     for s in starts:
       base_off = s * delta - lo
       block = [(l + base_off, r + base_off) for (l, r) in current_T]
       blocks.append(block)
 
     S = []
     if do_interleave:
       order = list(range(4))
       if reverse_order:
         order.reverse()
       maxlen = max(len(b) for b in blocks)
       for i in range(maxlen):
         for idx in order:
           blk = blocks[idx]
           if i < len(blk):
             S.append(blk[i])
     else:
       if reverse_order:
         blocks = list(reversed(blocks))
       for blk in blocks:
         S.extend(blk)
 
     _append_kt_connectors(S, starts, delta, lo)
     return S
 
   # Predictive bound: KT growth per round is size -> 4*size + 4
   def _max_rounds_within_cap(initial_size, max_rounds):
     sz = initial_size
     done = 0
     for _ in range(max(0, int(max_rounds))):
       nxt = 4 * sz + 4
       if nxt > CAP:
         break
       sz = nxt
       done += 1
     return done, sz
 
   # Stage 1: KT spine with rotating templates and parity-based interleaving
   depth, _ = _max_rounds_within_cap(len(T), rounds)
   for ridx in range(depth):
     starts = template_bank[ridx % len(template_bank)] if rotate_starts else template_bank[0]
     do_inter = bool(interleave_blocks and (ridx % 2 == 0))
     rev = bool(reverse_block_parity and (ridx % 2 == 1))
     T = _apply_kt_round(T, starts, do_interleave=do_inter, reverse_order=rev)
     if len(T) >= CAP:
       return T[:CAP]
 
   # If nearly at capacity return baseline
   if len(T) >= CAP - 16:
     return T[:CAP]
 
   # Insert a few long-range caps near the tail (helps mixing late FF colors without raising omega much)
   def _cap_at(lo, delta, a_frac, b_frac):
     L = lo + max(1, int(round(a_frac * delta)))
     R = lo + max(1, int(round(b_frac * delta)))
     if R <= L:
       R = L + 1
     return (L, R)
 
   lo, hi, delta = _span_delta(T)
   tail_caps = [
     _cap_at(lo, delta, 0.08, 0.60),
     _cap_at(lo, delta, 0.25, 0.75),
     _cap_at(lo, delta, 0.75, 0.92)
   ]
   # Insert compactly near the tail (but capacity-guarded)
   room = CAP - len(T)
   if room > 0:
     for cap in tail_caps[:room]:
       T.append(cap)
 
   if len(T) >= CAP - 12:
     return T[:CAP]
 
   # Stage 2: delta-scale micro rounds - derive a thin seed and place translated micro-blocks in windows
   def _thin_seed(current_T, max_seed):
     n = len(current_T)
     if n == 0 or max_seed <= 0:
       return []
     step = max(1, n // max_seed)
     U = current_T[::step][:max_seed]
     return U
 
   def _build_delta_micro(current_T, budget, iter_id=0, alt=False):
     if not current_T or budget <= 8:
       return []
 
     glo = min(l for l, r in current_T)
     ghi = max(r for l, r in current_T)
     G = max(1, ghi - glo)
 
     # seed size chosen small to keep omega low
     base_seed = max(8, min(36, len(current_T) // 250))
     seed_sz = base_seed if not alt else max(8, min(40, len(current_T) // 220))
     U = _thin_seed(current_T, seed_sz)
     if not U:
       return []
 
     ulo = min(l for l, r in U)
 
     # windows: primary ones slightly shifted by iter_id; alternate windows distinct
     if not alt:
       shift = (iter_id % 3) * 0.02
       window_fracs = [
         (0.12 + shift, 0.22 + shift),
         (0.35 + shift, 0.45 + shift),
         (0.58 + shift, 0.68 + shift),
         (0.80 + shift, 0.90 + shift),
       ]
       # clamp
       window_fracs = [(max(0.05, min(0.90, a)), max(0.10, min(0.95, b))) for (a, b) in window_fracs]
     else:
       window_fracs = [(0.05, 0.15), (0.28, 0.38), (0.60, 0.70), (0.82, 0.92)]
 
     blocks = []
     for (fa, fb) in window_fracs:
       win_lo = glo + int(round(fa * G))
       base_off = win_lo - ulo
       block = [(l + base_off, r + base_off) for (l, r) in U]
       # parity-breaking reversal to diversify arrivals
       tag = iter_id + (1 if alt else 0)
       if ((int(round(fa * 100)) // 5) + tag) % 2 == 1:
         block = list(reversed(block))
       blocks.append(block)
 
     # Interleave micro-blocks with block order varying by iter_id
     micro = []
     block_order = list(range(len(blocks)))
     if (iter_id % 2) == 1:
       block_order.reverse()
     maxlen = max(len(b) for b in blocks)
     for i in range(maxlen):
       for idx in block_order:
         blk = blocks[idx]
         if i < len(blk):
           micro.append(blk[i])
 
     # Deterministic fractional connectors on micro-scale (keep them short relative to G)
     micro_connectors = [
       (glo + int(round(0.08 * G)), glo + int(round(0.30 * G))),
       (glo + int(round(0.60 * G)), glo + int(round(0.92 * G))),
       (glo + int(round(0.26 * G)), glo + int(round(0.56 * G))),
       (glo + int(round(0.44 * G)), glo + int(round(0.78 * G))),
     ]
     if alt:
       micro_connectors.append((glo + int(round(0.18 * G)), glo + int(round(0.84 * G))))
 
     for a, b in micro_connectors:
       if b > a:
         micro.append((a, b))
 
     # trim to budget
     if len(micro) > budget:
       micro = micro[:budget]
     return micro
 
   steps = min(max(0, int(phase2_iters)), 2)
   for iter_id in range(steps):
     room = CAP - len(T)
     if room <= 8:
       break
     micro = _build_delta_micro(T, room, iter_id=iter_id, alt=False)
     if not micro:
       break
     if len(micro) > room:
       micro = micro[:room]
     T.extend(micro)
 
   # Secondary alternate micro-phase to capture missed interactions
   room = CAP - len(T)
   if room > 8:
     microB = _build_delta_micro(T, room, iter_id=steps, alt=True)
     if microB:
       if len(microB) > room:
         microB = microB[:room]
       T.extend(microB)
 
   if len(T) >= CAP - 8:
     return T[:CAP]
 
   # Stage 3: light-bridge round inspired by diversified design:
   # use a small connector template, alternating block orders and short caps to press FF colors
   lo, hi, delta = _span_delta(T)
   if delta <= 0:
     return T[:CAP]
 
   # pick a connector template deterministically
   template = connector_bank[0]
   # adopt a small set of starts derived from the KT templates for diversity
   start_patterns = [
     (2, 6, 10, 14),
     (1, 5, 9, 13),
     (3, 7, 11, 15),
     (2, 4, 8, 12),
   ]
   starts = start_patterns[0]
 
   S = []
   # Choose block order variant depending on parity of current size to diversify ordering
   if len(T) % 3 == 0:
     block_order = list(starts)
   elif len(T) % 3 == 1:
     block_order = list(reversed(starts))
   else:
     block_order = list(starts[1:]) + [starts[0]]
 
   # build translated blocks (use small reversed sub-blocks occasionally)
   for i, st in enumerate(block_order):
     inner = T if ((len(T) + i) % 2 == 0) else list(reversed(T))
     base_off = delta * st - lo
     for (l, r) in inner:
       S.append((l + base_off, r + base_off))
     # add a tiny light-bridge interval tying this block to next (short to avoid omega growth)
     if i + 1 < len(block_order):
       nxt = block_order[i + 1]
       bstart = delta * (st + 0.5) - lo
       bend = delta * (nxt + 0.5) - lo
       # make bridge extremely short and integerized
       a = int(min(bstart, bend) + max(1, delta // 1000))
       b = int(max(bstart, bend) - max(1, delta // 1000))
       if b > a:
         S.append((a, b))
 
   # append small connector gadget (scaled)
   for (a, b) in template:
     A = int(round(a * delta))
     B = int(round(b * delta))
     if B > A:
       S.append((lo + A, lo + B))
 
   # add a few sparse short caps between translated blocks
   max_st = max(starts)
   step = max(2, int(max_st // 3))
   for j in range(2, max_st, step):
     a = int(lo + delta * (j - 0.4) + 1)
     b = int(lo + delta * (j + 0.6) - 1)
     if b > a:
       S.append((a, b))
 
   # Capacity guard and append
   room = CAP - len(T)
   if room > 0:
     if len(S) > room:
       S = S[:room]
     T.extend(S)
 
   # Final micro pins (optional, very short intervals to tie windows)
   if len(T) < CAP - 4:
     glo2 = min(l for l, r in T)
     ghi2 = max(r for l, r in T)
     G2 = max(1, ghi2 - glo2)
     eps = max(1, G2 // 512)
     pins = []
     # create a few pins at fractional positions
     for frac in (0.09, 0.27, 0.64, 0.83):
       mid = glo2 + int(round(frac * G2))
       pins.append((mid, mid + eps))
     room = CAP - len(T)
     if room > 0:
       pins = pins[:room]
       T.extend(pins)
 
   # Final trim
   if len(T) > CAP:
     T = T[:CAP]
   return T
 
 # EVOLVE-BLOCK-END
 
 def run_experiment(**kwargs):
   """Main called by evaluator"""
   return construct_intervals()