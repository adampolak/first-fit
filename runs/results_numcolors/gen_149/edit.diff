--- a/original.py
+++ b/original.py
@@ -1,113 +1,190 @@
 # EVOLVE-BLOCK-START
 
 def _span_delta(T):
   lo = min(l for l, _ in T)
   hi = max(r for _, r in T)
   delta = hi - lo
   if delta <= 0:
     delta = 1
   return lo, hi, delta
 
-def _build_blocks_sequential(T, starts, delta, lo, K=1):
+def _build_blocks_sequential(T, starts, delta, lo, K=1, interleave=False):
   """
-  Build four translated blocks sequentially. No interleaving. This ordering
-  is known to amplify FirstFit color pressure. K is a tunable spacing multiplier (default 1).
+  Build translated blocks from T at offsets given by starts.
+  - If interleave is False, append blocks sequentially (baseline).
+  - If interleave is True, interleave the four blocks round-robin to disrupt FF reuse.
+  K is a tunable spacing multiplier (default 1).
   """
-  S = []
+  # Build the four translated blocks first
+  blocks = []
   for s in starts:
     base = s * delta * K - lo
-    S.extend((l + base, r + base) for (l, r) in T)
+    block = [(l + base, r + base) for (l, r) in T]
+    blocks.append(block)
+
+  if not interleave:
+    S = []
+    for blk in blocks:
+      S.extend(blk)
+    return S
+
+  # Interleave blocks deterministically
+  S = []
+  maxlen = max((len(b) for b in blocks), default=0)
+  for i in range(maxlen):
+    for blk in blocks:
+      if i < len(blk):
+        S.append(blk[i])
   return S
 
 def _append_connectors(S, starts, delta, add_cross4=False):
   """
   Append the classic four connectors. Optionally add a single long-range cross4
   on the final round to improve pressure while keeping total size under CAP.
   """
   s0, s1, s2, s3 = starts
   S.append(((s0 - 1) * delta, (s1 - 1) * delta))  # left cap
   S.append(((s2 + 2) * delta, (s3 + 2) * delta))  # right cap
   S.append(((s0 + 2) * delta, (s2 - 1) * delta))  # cross 1
   S.append(((s1 + 2) * delta, (s3 - 1) * delta))  # cross 2
   if add_cross4:
     S.append(((s0 + 4) * delta, (s3 + 4) * delta))  # long-range cross (final-round only)
 
 def _append_micro_tail(T, max_extra=8):
   """
   Append a tiny tail of long caps near the end of T. This boosts FF late with minimal
   impact on omega. Caps are inserted near the end (rather than simply appended) to
   intersect many active colors while avoiding a single dense core.
   """
   if not T or max_extra <= 0:
     return T
   lo, hi, delta = _span_delta(T)
   d2 = max(1, delta // 4)
   # Symmetric, sparse long caps
   micro = [
       (lo + 1 * d2, lo + 5 * d2),
       (lo + 3 * d2, lo + 8 * d2),
       (hi - 6 * d2, hi - 2 * d2),
       (hi - 8 * d2, hi - 3 * d2),
   ]
   # Insert near the tail in a staggered fashion
   for i, interval in enumerate(micro[:max_extra]):
     pos = len(T) - (i * 2 + 1)
     if pos < 0:
       T.append(interval)
     else:
       T.insert(pos, interval)
   return T
 
 def construct_intervals(seed_count=1):
   """
   Construct a sequence of open intervals (l, r), in FirstFit arrival order,
   aiming to maximize FirstFit colors relative to the clique number.
 
-  Interface preserved from prior versions.
+  Enhancements:
+  - Parity-based interleaving of spine blocks (even rounds) to disrupt low-color reuse.
+  - A thin delta2 micro-round using windowed, interleaved translated seeds, capacity-guarded.
+  - Retain a tiny micro tail to sprinkle long caps at the very end.
   """
   CAP = 9800
 
   # Four-template spine bank: deterministic round-robin selection
   template_bank = [
     (2, 6, 10, 14),  # T1 classic KT
     (1, 5, 9, 13),   # T2 left-shifted
     (3, 7, 11, 15),  # T3 right-shifted
     (4, 8, 12, 16),  # T4 stretched right
   ]
 
   # Seed: keep single unit interval to avoid early omega inflation
   if seed_count <= 1:
     T = [(0, 1)]
   else:
     # Deterministic sparse multi-seed (guarded); still small to protect omega
     step = 3
     T = [(i * step, i * step + 1) for i in range(max(1, int(seed_count)))]
     T = T[:4]  # cap to 4 seeds deterministically
 
-  # Main spine: exactly six rounds when under CAP; sequential blocks; classic connectors.
+  # Main spine: exactly six rounds when under CAP; parity interleaving on even rounds.
   rounds = 6
   for ridx in range(rounds):
     lo, hi, delta = _span_delta(T)
     starts = template_bank[ridx % 4]
-    S = _build_blocks_sequential(T, starts, delta, lo, K=1)
+    S = _build_blocks_sequential(T, starts, delta, lo, K=1, interleave=(ridx % 2 == 0))
     # Add connectors; only the last round gets a single extra cross4 (keeps count < CAP)
     _append_connectors(S, starts, delta, add_cross4=(ridx == rounds - 1))
     T = S
     if len(T) >= CAP:
       # Should not happen with this recurrence, but guard anyway
       T = T[:CAP]
       return T
+
+  # Delta2-driven micro round: thin seed, four windows, interleaved, sparse connectors.
+  def _build_micro_delta_round(current_T, budget):
+    if not current_T or budget <= 8:
+      return []
+    glo, ghi, G = _span_delta(current_T)
+    # Thin, evenly spaced seed
+    n = len(current_T)
+    seed_sz = max(8, min(32, n // 300))
+    step = max(1, n // max(1, seed_sz))
+    U = [current_T[i] for i in range(0, n, step)][:seed_sz]
+    if not U:
+      return []
+    ulo = min(l for l, _ in U)
+
+    # Four windows across the global span, kept away from endpoints to avoid omega spikes
+    window_fracs = [(0.12, 0.22), (0.35, 0.45), (0.58, 0.68), (0.80, 0.90)]
+    blocks = []
+    for (fa, fb) in window_fracs:
+      win_lo = glo + int(round(fa * G))
+      base = win_lo - ulo
+      blocks.append([(l + base, r + base) for (l, r) in U])
+
+    # Interleave micro blocks
+    micro = []
+    maxlen = max(len(b) for b in blocks)
+    for i in range(maxlen):
+      for blk in blocks:
+        if i < len(blk):
+          micro.append(blk[i])
+
+    # Fractional-span connectors across windows
+    connectors = [
+      (glo + int(round(0.08 * G)), glo + int(round(0.30 * G))),
+      (glo + int(round(0.60 * G)), glo + int(round(0.92 * G))),
+      (glo + int(round(0.26 * G)), glo + int(round(0.56 * G))),
+      (glo + int(round(0.44 * G)), glo + int(round(0.78 * G))),
+    ]
+    for a, b in connectors:
+      if b > a:
+        micro.append((a, b))
+
+    # Trim to available budget
+    if len(micro) > budget:
+      micro = micro[:budget]
+    return micro
+
+  # Apply the micro-round if capacity allows
+  room = CAP - len(T)
+  if room > 8:
+    micro = _build_micro_delta_round(T, room)
+    if micro:
+      avail = CAP - len(T)
+      if len(micro) > avail:
+        micro = micro[:avail]
+      T.extend(micro)
 
   # Tiny micro tail: safe and capacity-bounded
   room = CAP - len(T)
   if room > 0:
     # Insert at most 8 extras or available room, whichever is smaller
     T = _append_micro_tail(T, max_extra=min(8, room))
 
   return T
 
 # EVOLVE-BLOCK-END
 
 def run_experiment(**kwargs):
   """Main called by evaluator"""
   return construct_intervals()