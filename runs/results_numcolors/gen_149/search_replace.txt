<NAME>
parity_interleave_plus_delta2_micro
</NAME>

<DESCRIPTION>
I introduce two targeted enhancements inspired by Kierstead–Trotter style scaffolds and recent lower-bound constructions.

1) Parity interleaving of spine blocks: On even-numbered spine rounds, the four translated blocks are interleaved rather than appended sequentially. This preserves the classic four-start structure while increasing FirstFit’s difficulty to recycle low colors due to tighter arrival-order coupling. It is a lightweight change known to raise FF without inflating the clique number.

2) A thin, capacity-guarded delta2 micro-round: After the six spine rounds, I add a deterministic micro-phase that samples a thin, evenly spaced seed from T, places four translated copies into well-separated windows across the global span, interleaves them, and adds sparse fractional-span connectors. This mirrors the effective micro-window gadget seen in prior strong variants and is strictly trimmed to the remaining budget (CAP). It increases cross-scale coupling and sustains FF pressure while avoiding omega spikes.

I retain the existing tiny micro tail (long caps) but run it after the micro-round so it fills only the remaining capacity. All changes are deterministic, keep the interval count under 9800, and are consistent with the program’s existing helpers and interfaces.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
def _build_blocks_sequential(T, starts, delta, lo, K=1):
  """
  Build four translated blocks sequentially. No interleaving. This ordering
  is known to amplify FirstFit color pressure. K is a tunable spacing multiplier (default 1).
  """
  S = []
  for s in starts:
    base = s * delta * K - lo
    S.extend((l + base, r + base) for (l, r) in T)
  return S
=======
def _build_blocks_sequential(T, starts, delta, lo, K=1, interleave=False):
  """
  Build translated blocks from T at offsets given by starts.
  - If interleave is False, append blocks sequentially (baseline).
  - If interleave is True, interleave the four blocks round-robin to disrupt FF reuse.
  K is a tunable spacing multiplier (default 1).
  """
  # Build the four translated blocks first
  blocks = []
  for s in starts:
    base = s * delta * K - lo
    block = [(l + base, r + base) for (l, r) in T]
    blocks.append(block)

  if not interleave:
    S = []
    for blk in blocks:
      S.extend(blk)
    return S

  # Interleave blocks deterministically
  S = []
  maxlen = max((len(b) for b in blocks), default=0)
  for i in range(maxlen):
    for blk in blocks:
      if i < len(blk):
        S.append(blk[i])
  return S
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
def construct_intervals(seed_count=1):
  """
  Construct a sequence of open intervals (l, r), in FirstFit arrival order,
  aiming to maximize FirstFit colors relative to the clique number.

  Interface preserved from prior versions.
  """
  CAP = 9800

  # Four-template spine bank: deterministic round-robin selection
  template_bank = [
    (2, 6, 10, 14),  # T1 classic KT
    (1, 5, 9, 13),   # T2 left-shifted
    (3, 7, 11, 15),  # T3 right-shifted
    (4, 8, 12, 16),  # T4 stretched right
  ]

  # Seed: keep single unit interval to avoid early omega inflation
  if seed_count <= 1:
    T = [(0, 1)]
  else:
    # Deterministic sparse multi-seed (guarded); still small to protect omega
    step = 3
    T = [(i * step, i * step + 1) for i in range(max(1, int(seed_count)))]
    T = T[:4]  # cap to 4 seeds deterministically

  # Main spine: exactly six rounds when under CAP; sequential blocks; classic connectors.
  rounds = 6
  for ridx in range(rounds):
    lo, hi, delta = _span_delta(T)
    starts = template_bank[ridx % 4]
    S = _build_blocks_sequential(T, starts, delta, lo, K=1)
    # Add connectors; only the last round gets a single extra cross4 (keeps count < CAP)
    _append_connectors(S, starts, delta, add_cross4=(ridx == rounds - 1))
    T = S
    if len(T) >= CAP:
      # Should not happen with this recurrence, but guard anyway
      T = T[:CAP]
      return T

  # Tiny micro tail: safe and capacity-bounded
  room = CAP - len(T)
  if room > 0:
    # Insert at most 8 extras or available room, whichever is smaller
    T = _append_micro_tail(T, max_extra=min(8, room))

  return T
=======
def construct_intervals(seed_count=1):
  """
  Construct a sequence of open intervals (l, r), in FirstFit arrival order,
  aiming to maximize FirstFit colors relative to the clique number.

  Enhancements:
  - Parity-based interleaving of spine blocks (even rounds) to disrupt low-color reuse.
  - A thin delta2 micro-round using windowed, interleaved translated seeds, capacity-guarded.
  - Retain a tiny micro tail to sprinkle long caps at the very end.
  """
  CAP = 9800

  # Four-template spine bank: deterministic round-robin selection
  template_bank = [
    (2, 6, 10, 14),  # T1 classic KT
    (1, 5, 9, 13),   # T2 left-shifted
    (3, 7, 11, 15),  # T3 right-shifted
    (4, 8, 12, 16),  # T4 stretched right
  ]

  # Seed: keep single unit interval to avoid early omega inflation
  if seed_count <= 1:
    T = [(0, 1)]
  else:
    # Deterministic sparse multi-seed (guarded); still small to protect omega
    step = 3
    T = [(i * step, i * step + 1) for i in range(max(1, int(seed_count)))]
    T = T[:4]  # cap to 4 seeds deterministically

  # Main spine: exactly six rounds when under CAP; parity interleaving on even rounds.
  rounds = 6
  for ridx in range(rounds):
    lo, hi, delta = _span_delta(T)
    starts = template_bank[ridx % 4]
    S = _build_blocks_sequential(T, starts, delta, lo, K=1, interleave=(ridx % 2 == 0))
    # Add connectors; only the last round gets a single extra cross4 (keeps count < CAP)
    _append_connectors(S, starts, delta, add_cross4=(ridx == rounds - 1))
    T = S
    if len(T) >= CAP:
      # Should not happen with this recurrence, but guard anyway
      T = T[:CAP]
      return T

  # Delta2-driven micro round: thin seed, four windows, interleaved, sparse connectors.
  def _build_micro_delta_round(current_T, budget):
    if not current_T or budget <= 8:
      return []
    glo, ghi, G = _span_delta(current_T)
    # Thin, evenly spaced seed
    n = len(current_T)
    seed_sz = max(8, min(32, n // 300))
    step = max(1, n // max(1, seed_sz))
    U = [current_T[i] for i in range(0, n, step)][:seed_sz]
    if not U:
      return []
    ulo = min(l for l, _ in U)

    # Four windows across the global span, kept away from endpoints to avoid omega spikes
    window_fracs = [(0.12, 0.22), (0.35, 0.45), (0.58, 0.68), (0.80, 0.90)]
    blocks = []
    for (fa, fb) in window_fracs:
      win_lo = glo + int(round(fa * G))
      base = win_lo - ulo
      blocks.append([(l + base, r + base) for (l, r) in U])

    # Interleave micro blocks
    micro = []
    maxlen = max(len(b) for b in blocks)
    for i in range(maxlen):
      for blk in blocks:
        if i < len(blk):
          micro.append(blk[i])

    # Fractional-span connectors across windows
    connectors = [
      (glo + int(round(0.08 * G)), glo + int(round(0.30 * G))),
      (glo + int(round(0.60 * G)), glo + int(round(0.92 * G))),
      (glo + int(round(0.26 * G)), glo + int(round(0.56 * G))),
      (glo + int(round(0.44 * G)), glo + int(round(0.78 * G))),
    ]
    for a, b in connectors:
      if b > a:
        micro.append((a, b))

    # Trim to available budget
    if len(micro) > budget:
      micro = micro[:budget]
    return micro

  # Apply the micro-round if capacity allows
  room = CAP - len(T)
  if room > 8:
    micro = _build_micro_delta_round(T, room)
    if micro:
      avail = CAP - len(T)
      if len(micro) > avail:
        micro = micro[:avail]
      T.extend(micro)

  # Tiny micro tail: safe and capacity-bounded
  room = CAP - len(T)
  if room > 0:
    # Insert at most 8 extras or available room, whichever is smaller
    T = _append_micro_tail(T, max_extra=min(8, room))

  return T
>>>>>>> REPLACE
</DIFF>