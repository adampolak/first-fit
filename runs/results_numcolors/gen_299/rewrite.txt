# EVOLVE-BLOCK-START

def construct_intervals(seed_count=1):
    """
    Improved KT-style spine + deterministic densification + dual micro-phases + cross-connectors.
    Input/Output identical to the prior program: returns a list of (l, r) integer tuples
    representing open intervals, in the presentation order for FirstFit.
    """

    # --- Tunable global parameters ---
    CAP = 9800                      # hard capacity guard (<10000)
    BASE_SEED = 0x9E3779B1          # deterministic base for per-round decisions
    spine_rounds = 6                # nominal KT rounds
    template_bank = [
        (2, 6, 10, 14),  # classic KT
        (1, 5, 9, 13),   # left-shifted
        (3, 7, 11, 15),  # right-shifted
        (4, 8, 12, 16),  # stretched-right
    ]

    # densify policy: every 'densify_every' rounds perform a small duplication with offset
    densify_every = 3               # frequency of densification
    densify_shift_factor = 6        # small offset divisor: shift = delta // densify_shift_factor + 1

    # micro-phase parameters
    micro_seed_max = 40             # maximal seed size for micro phases
    micro_iters_A = 2               # micro-phase A iterations
    micro_iters_B = 1               # micro-phase B iterations
    micro_windows_A = [(0.12, 0.22), (0.35, 0.45), (0.58, 0.68), (0.80, 0.90)]
    micro_windows_B = [(0.05, 0.15), (0.28, 0.38), (0.60, 0.70), (0.82, 0.92)]
    micro_blocker_eps_fraction = 80  # creates blockers of length delta//eps_fraction

    # final short pins
    final_pins = 6

    # --- Helpers ---
    def _span(T):
        lo = min(l for l, r in T)
        hi = max(r for l, r in T)
        delta = hi - lo
        if delta <= 0:
            delta = 1
        return lo, hi, delta

    def _per_round_seed(base, ridx):
        # simple deterministic mixing to derive per-round choices
        # using 32-bit mix; deterministic and reproducible
        x = (base + ridx * 0x9E3779B1) & 0xFFFFFFFF
        # xorshift-ish mixing
        x ^= (x << 13) & 0xFFFFFFFF
        x ^= (x >> 17) & 0xFFFFFFFF
        x ^= (x << 5) & 0xFFFFFFFF
        return x

    def _append_safe(target, items):
        """Append items to target respecting CAP; returns number appended."""
        can = CAP - len(target)
        if can <= 0:
            return 0
        add = items[:can]
        target.extend(add)
        return len(add)

    def _thin_seed(T, max_seed):
        n = len(T)
        if n == 0 or max_seed <= 0:
            return []
        step = max(1, n // max_seed)
        return T[::step][:max_seed]

    def _append_connectors(S, starts, delta, lo):
        # classic four connectors (anchored using lo)
        s0, s1, s2, s3 = starts
        con = [
            ((s0 - 1) * delta + lo, (s1 - 1) * delta + lo),
            ((s2 + 2) * delta + lo, (s3 + 2) * delta + lo),
            ((s0 + 2) * delta + lo, (s2 - 1) * delta + lo),
            ((s1 + 2) * delta + lo, (s3 - 1) * delta + lo),
        ]
        return con

    def apply_spine_round(curr_T, starts, do_interleave, reverse_order, densify=False, densify_shift=1):
        lo, hi, delta = _span(curr_T)
        blocks = []
        # build four translated blocks (base positions use integer arithmetic)
        for s in starts:
            base = s * delta - lo
            block = [(l + base, r + base) for (l, r) in curr_T]
            blocks.append(block)

        # optional reversed order for assembly
        assembled = []
        if do_interleave:
            order = list(range(4))
            if reverse_order:
                order.reverse()
            maxlen = max(len(b) for b in blocks)
            for i in range(maxlen):
                for idx in order:
                    blk = blocks[idx]
                    if i < len(blk):
                        assembled.append(blk[i])
        else:
            if reverse_order:
                for blk in reversed(blocks):
                    assembled.extend(blk)
            else:
                for blk in blocks:
                    assembled.extend(blk)

        # connectors anchored to this scale (use lo as offset)
        assembled.extend(_append_connectors([], starts, delta, lo))

        # densify: duplicate each block with a small offset (controlled to be tiny compared to delta)
        if densify:
            shift = max(1, delta // densify_shift + 1)
            densified = []
            for s in starts:
                base = s * delta - lo + shift
                block = [(l + base, r + base) for (l, r) in curr_T]
                densified.extend(block)
            # present densified duplicates right after the assembled spine-blocks to couple colors
            assembled.extend(densified)

        return assembled

    # --- Start building T (spine) ---
    T = [(0, 1)] if seed_count <= 1 else [(0, 1)]

    # Determine how many full KT rounds we can safely perform (size -> 4*size + 4)
    def max_rounds_within_cap(initial_size, max_rounds):
        sz = initial_size
        done = 0
        for _ in range(max_rounds):
            nxt = 4 * sz + 4
            if nxt > CAP:
                break
            sz = nxt
            done += 1
        return done

    depth = max_rounds_within_cap(len(T), spine_rounds)

    for ridx in range(depth):
        # deterministic per-round config
        seed = _per_round_seed(BASE_SEED, ridx)
        starts = template_bank[ridx % len(template_bank)]
        # interleave schedule: deterministic 4-cycle derived from seed bits
        interleave_cycle = ((seed >> 0) & 3)  # 0..3
        do_interleave = (interleave_cycle % 3 != 2)  # True most rounds, deterministic pattern
        reverse_order = ((seed >> 3) & 1) == 1
        densify = ((ridx + (seed & 7)) % densify_every == 0)  # deterministic densify choice
        # compute small shift for densification
        _, _, delta = _span(T)
        densify_shift = max(1, densify_shift_factor)

        # build this round and append (capacity-guarded)
        round_block = apply_spine_round(T, starts, do_interleave, reverse_order, densify=densify, densify_shift=densify_shift)
        _append_safe(T, round_block)
        if len(T) >= CAP:
            T = T[:CAP]
            return T

    # If we're already near capacity, return the spine baseline
    if len(T) >= CAP - 16:
        return T

    # --- Micro-phase A: deterministic thin-seed micro rounds with blockers ---
    def micro_round(current_T, window_fracs, iter_id=0):
        if not current_T:
            return []
        glo = min(l for l, r in current_T)
        ghi = max(r for l, r in current_T)
        G = max(1, ghi - glo)

        # adaptive thin seed (slightly larger to strengthen pressure)
        seed_sz = max(8, min(micro_seed_max, len(current_T) // 250))
        U = _thin_seed(current_T, seed_sz)
        if not U:
            return []

        ulo = min(l for l, r in U)
        # choose a deterministic block order rotation based on iter_id
        krot = iter_id % len(window_fracs)

        blocks = []
        for bi, (fa, fb) in enumerate(window_fracs):
            win_lo = glo + int(round(fa * G))
            base = win_lo - ulo
            block = [(l + base, r + base) for (l, r) in U]
            # shrink each interval slightly to create many short pins (keeps omega low)
            # but we keep integer lengths; create pins centered inside each interval
            # eps pinned length tuned from the current scale
            eps = max(1, G // micro_blocker_eps_fraction)
            shrunk = []
            for (l, r) in block:
                mid = (l + r) // 2
                L = mid - eps // 2
                R = L + eps
                if R > L:
                    shrunk.append((L, R))
            # deterministic internal reversal to increase coupling variety
            if ((bi + iter_id) % 2) == 1:
                shrunk = list(reversed(shrunk))
            # Add tiny blockers up front to occupy small colors early
            if shrunk:
                blk_left = shrunk[0]
                # create a tiny blocker near left and near right (if possible)
                blockers = []
                bsize = max(1, max(1, eps // 2))
                Lb = max(1, blk_left[0] - (eps + 1))
                blockers.append((Lb, Lb + bsize))
                if len(shrunk) > 1:
                    rb = shrunk[-1]
                    Rb = rb[1] + 1
                    blockers.append((Rb, Rb + bsize))
                # place blockers before shrunk pins so they claim small colors early
                shrunk = blockers + shrunk
            blocks.append(shrunk)

        # interleave blocks with deterministic rotation
        out = []
        order_idx = list(range(len(blocks)))
        order_idx = order_idx[krot:] + order_idx[:krot]
        maxlen = max(len(b) for b in blocks) if blocks else 0
        for i in range(maxlen):
            for idx in order_idx:
                blk = blocks[idx]
                if i < len(blk):
                    out.append(blk[i])

        # add small connectors: only cap connectors to avoid omega blow-up
        s0, s1, s2, s3 = (2, 6, 10, 14)
        left_cap = (glo + int(round(0.08 * G)), glo + int(round(0.30 * G)))
        right_cap = (glo + int(round(0.60 * G)), glo + int(round(0.92 * G)))
        out.append(left_cap)
        out.append(right_cap)
        return out

    # run a couple iterations of micro-phase A
    for it in range(micro_iters_A):
        room = CAP - len(T)
        if room <= 8:
            break
        microA = micro_round(T, micro_windows_A, iter_id=it)
        if microA:
            _append_safe(T, microA)
        if len(T) >= CAP:
            T = T[:CAP]
            return T

    # Immediately add a handful of deterministic long-range cross-scale connectors anchored to the spine
    def add_cross_anchor_connectors(current_T, try_count=4):
        if not current_T:
            return []
        lo, hi, delta = _span(current_T)
        conns = []
        # deterministic list of fractional spans chosen to connect many regions
        frac_pairs = [(0.02, 0.40), (0.20, 0.60), (0.35, 0.85), (0.10, 0.92)]
        for (a, b) in frac_pairs[:try_count]:
            L = lo + int(round(a * delta))
            R = lo + int(round(b * delta))
            if R > L:
                conns.append((L, R))
        return conns

    cross_conns = add_cross_anchor_connectors(T, try_count=4)
    if cross_conns:
        _append_safe(T, cross_conns)
    if len(T) >= CAP - 16:
        return T

    # --- Micro-phase B: alternate window families to capture missed interactions ---
    for it in range(micro_iters_B):
        room = CAP - len(T)
        if room <= 8:
            break
        microB = micro_round(T, micro_windows_B, iter_id=it + 100)  # different iter seed offset for variety
        if microB:
            _append_safe(T, microB)
        if len(T) >= CAP:
            T = T[:CAP]
            return T

    # Add a final set of connectors spanning different fractions if room allows
    room = CAP - len(T)
    if room > 4:
        lo, hi, delta = _span(T)
        extras = [
            (lo + int(round(0.18 * delta)), lo + int(round(0.48 * delta))),
            (lo + int(round(0.42 * delta)), lo + int(round(0.78 * delta))),
            (lo + int(round(0.05 * delta)), lo + int(round(0.95 * delta))),
        ]
        _append_safe(T, extras)

    # Final micro-pins: short intervals to consume remaining budget safely
    room = CAP - len(T)
    if room > 0:
        lo, hi, delta = _span(T)
        eps = max(1, delta // 200)
        centers = []
        # pick deterministic centers across the span
        for k in range(final_pins):
            centers.append(lo + (k + 1) * (delta // (final_pins + 1)))
        pins = []
        for c in centers:
            L = int(c - eps // 2)
            R = L + eps
            if R > L:
                pins.append((L, R))
        _append_safe(T, pins)

    # capacity trim
    if len(T) > CAP:
        T = T[:CAP]
    return T

# EVOLVE-BLOCK-END

def run_experiment(**kwargs):
    """Main called by evaluator"""
    return construct_intervals()