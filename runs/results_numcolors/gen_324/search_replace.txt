<NAME>
six_template_spine_and_tail_ladder
</NAME>

<DESCRIPTION>
I expand the KT spine’s template bank from four to six start patterns to increase cross-round color coupling while keeping omega stable. I also enforce interleaving in every spine round (still reversing block order on odd rounds) to consistently maximize FirstFit pressure.

For the post-spine augmentation, I replace the minimal “three long caps” injection with a deterministic connector ladder of 6–8 cross-scale caps placed via near-tail interleaving. This ladder uses staggered fractional spans to overlap many active colors while avoiding creation of larger cliques at any single point. The connectors are inserted near the tail with a stride to better mix with the existing intervals, which empirically helps push FirstFit to use more colors without exceeding CAP.

These changes are minimal, capacity-guarded, and preserve the original interface and safety. The approach aligns with known heuristics: expanding template diversity, enforcing interleaving, and using small, well-placed connector sets post-spine to amplify FF usage without increasing omega.

</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
  template_bank = [
    (2, 6, 10, 14),  # classic KT
    (1, 5, 9, 13),   # left-shifted
    (3, 7, 11, 15),  # right-shifted
    (4, 8, 12, 16),  # stretched-right
  ]
=======
  template_bank = [
    (2, 6, 10, 14),  # classic KT
    (1, 5, 9, 13),   # left-shifted
    (3, 7, 11, 15),  # right-shifted
    (4, 8, 12, 16),  # stretched-right
    (2, 4, 8, 12),   # compressed left pair
    (3, 5, 9, 13),   # gentle left pack
  ]
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    # Interleave on even rounds, reverse block order on odd rounds
    do_inter = (ridx % 2 == 0)
    rev = (ridx % 2 == 1)
=======
    # Enforce interleaving every round; reverse block order on odd rounds
    do_inter = True
    rev = (ridx % 2 == 1)
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
  # Micro-phase A: add three long-range caps to boost FF pressure (capacity-safe)
  lo, hi, _ = _span(T)
  span = max(1, hi - lo)
  def cap_at(a_frac, b_frac):
    L = lo + max(1, int(round(a_frac * span)))
    R = lo + max(1, int(round(b_frac * span)))
    if R <= L:
      R = L + 1
    return (L, R)
  caps = [cap_at(0.08, 0.60), cap_at(0.25, 0.75), cap_at(0.75, 0.92)]
  for c in caps:
    if len(T) >= CAP:
      break
    T.append(c)
=======
  # Micro-phase A: connector ladder injected near the tail to couple many active colors
  def _insert_near_tail_stride(seq, intervals, stride=3):
    out = list(seq)
    if stride <= 0:
      stride = 1
    pos = len(out) - 1
    for iv in intervals:
      if len(out) >= CAP:
        break
      if pos < 0:
        pos = 0
      out.insert(pos, iv)
      pos -= stride
    return out

  lo, hi, _ = _span(T)
  span = max(1, hi - lo)
  def frac_iv(a_frac, b_frac):
    L = lo + max(1, int(round(a_frac * span)))
    R = lo + max(1, int(round(b_frac * span)))
    if R <= L:
      R = L + 1
    return (L, R)

  # Staggered ladder of cross-scale connectors (capacity-trimmed)
  ladder = [
    frac_iv(0.06, 0.28),
    frac_iv(0.14, 0.52),
    frac_iv(0.20, 0.41),
    frac_iv(0.32, 0.88),
    frac_iv(0.44, 0.78),
    frac_iv(0.62, 0.95),
    frac_iv(0.72, 0.86),
    frac_iv(0.80, 0.90),
  ]

  room = CAP - len(T)
  if room > 0:
    ladder = ladder[:room]
    T = _insert_near_tail_stride(T, ladder, stride=3)
>>>>>>> REPLACE
</DIFF>