--- a/original.py
+++ b/original.py
@@ -1,403 +1,442 @@
 # EVOLVE-BLOCK-START
-
-def _span_delta(T):
-    """Return (lo, hi, delta) for current interval set T."""
-    lo = min(l for l, _ in T)
-    hi = max(r for _, r in T)
-    delta = hi - lo
-    if delta <= 0:
-        delta = 1
-    return lo, hi, delta
-
-def _svc_connectors(starts, delta):
-    """Produce four canonical connectors given the start-pattern and block delta."""
-    s0, s1, s2, s3 = starts
-    return [
-        ((s0 - 1) * delta, (s1 - 1) * delta),  # left cap
-        ((s2 + 2) * delta, (s3 + 2) * delta),  # right cap
-        ((s0 + 2) * delta, (s2 - 1) * delta),  # cross 1
-        ((s1 + 2) * delta, (s3 - 1) * delta),  # cross 2
-    ]
-
-def _translate_blocks(T, starts, delta, lo):
-    """Create four translated blocks from current T and a given start-pattern."""
-    blocks = []
-    for s in starts:
-        base = s * delta - lo
-        block = [(l + base, r + base) for (l, r) in T]
-        blocks.append(block)
-    return blocks
-
-def _assemble_from_blocks(blocks, interleave=False, reverse_order=False, round_seed=0):
-    """Flatten blocks into S, optionally interleaving. round_seed adds deterministic rotation."""
-    if not interleave:
-        if reverse_order:
-            blocks = list(reversed(blocks))
-        S = []
-        for blk in blocks:
-            S.extend(blk)
-        return S
-
-    # Interleave across blocks with a deterministic per-round rotation to break regularity
-    maxlen = max((len(b) for b in blocks), default=0)
-    order = list(range(len(blocks)))
-    if reverse_order:
-        order = list(reversed(order))
-    # rotate order deterministically by round_seed mod len(order)
-    if order:
-        krot = int(round_seed) % len(order)
-        order = order[krot:] + order[:krot]
-
-    S = []
-    for i in range(maxlen):
-        for idx in order:
-            blk = blocks[idx]
-            if i < len(blk):
-                S.append(blk[i])
-    return S
-
-def _apply_round(current_T, starts, do_interleave=False, reverse_order=False, round_seed=0):
-    """One KT-round: translate 4 blocks, assemble, then append connectors."""
-    lo, hi, delta = _span_delta(current_T)
-    # translate 4 blocks
-    blocks = _translate_blocks(current_T, starts, delta, lo)
-    S = _assemble_from_blocks(blocks, interleave=do_interleave, reverse_order=reverse_order, round_seed=round_seed)
-    # append canonical connectors
-    S += _svc_connectors(starts, delta)
-    return S
-
-def _insert_tail_caps(T, caps, cap_cap):
-    """Safely insert tail caps up to a cap_cap budget."""
-    room = cap_cap - len(T)
-    if room <= 0:
-        return T
-    for i, iv in enumerate(caps[:room]):
-        pos = len(T) - (i * 2 + 1)
-        if pos < 0:
-            T.append(iv)
-        else:
-            T.insert(pos, iv)
-    return T
 
 def construct_intervals(seed_count=1):
     """
-    Deterministic KT-spine with improved deterministic interleaving and a second micro-phase.
-    Produces a sequence of intervals for FirstFit with omega kept moderate.
-    Returns a list of (l, r) integer pairs with r > l, capped at 9800.
+    Adversarial FirstFit generator.
+    Input: seed_count (keeps deterministic variations).
+    Output: list of (l, r) integer tuples (open intervals) in the order they are presented.
+    Guarantees: max number of intervals <= CAP and final clique (opt) <= CLIQUE_LIMIT (10).
     """
+    import math
+    from bisect import bisect_left, bisect_right
+    from collections import defaultdict
+
     CAP = 9800
-    BASE_SEED = 7  # small deterministic seed used to derive per-round mixing flags
-
-    # Centralized per-round seed derivation (keeps decisions reproducible)
-    def _per_round_seed(base, ridx):
-        # small LCG-like mix to produce a stable 16-bit round value
-        return (base * 1664525 + ridx * 1013904223) & 0xFFFF
-
-    # Option to force interleaving on every KT round (empirically helpful)
-    ENFORCE_INTERLEAVE = True
-
-    # Deterministic rotate templates
-    template_bank = [
-        (2, 6, 10, 14),  # classic KT
-        (1, 5, 9, 13),   # left-shifted
-        (3, 7, 11, 15),  # right-shifted
-        (4, 8, 12, 16),  # stretched-right
-    ]
-
-    # Seed sequence
-    if seed_count <= 1:
-        T = [(0, 1)]
-    else:
-        step = 3
-        seeds = min(4, max(1, int(seed_count)))
-        T = [(i * step, i * step + 1) for i in range(seeds)]
-
-    # Stage 1: six KT-style rounds with deterministic per-round mixing
-    for ridx in range(6):
-        starts = template_bank[ridx % len(template_bank)]
-        nxt_size = 4 * len(T) + 4
-        if nxt_size > CAP:
+    CLIQUE_LIMIT = 10
+    rng_seed = int(seed_count) & 0x7FFFFFFF
+
+    # Deterministic RNG (small, fast)
+    class SimpleRNG:
+        def __init__(self, seed):
+            self.x = (seed ^ 0x9e3779b9) & 0xFFFFFFFF
+        def randint(self, a, b):
+            # xorshift-ish deterministic step
+            self.x ^= (self.x << 13) & 0xFFFFFFFF
+            self.x ^= (self.x >> 17) & 0xFFFFFFFF
+            self.x ^= (self.x << 5) & 0xFFFFFFFF
+            return a + (self.x % (b - a + 1))
+        def choice(self, seq):
+            if not seq:
+                return None
+            return seq[self.randint(0, len(seq) - 1)]
+        def shuffle(self, seq):
+            for i in range(len(seq)-1, 0, -1):
+                j = self.randint(0, i)
+                seq[i], seq[j] = seq[j], seq[i]
+
+    rng = SimpleRNG(rng_seed)
+
+    # Overlap test for open intervals (l1, r1) and (l2, r2)
+    def overlaps(a, b):
+        return a[0] < b[1] and b[0] < a[1]
+
+    # FirstFit color for a single candidate interval given current intervals with known colors
+    def candidate_firstfit_color(intervals, colors, candidate):
+        used = set()
+        cl, cr = candidate
+        for iv, col in zip(intervals, colors):
+            if iv[0] < cr and cl < iv[1]:
+                used.add(col)
+        c = 1
+        while c in used:
+            c += 1
+        return c
+
+    # Sweep-line to compute segment coverage (list of (seg_l, seg_r, count))
+    def compute_segments(intervals):
+        events = []
+        for l, r in intervals:
+            # ensure integer endpoints; open intervals: (l, r)
+            events.append((l, 1))
+            events.append((r, -1))
+        if not events:
+            return []
+        events.sort()
+        segments = []
+        cur = 0
+        last_x = events[0][0]
+        i = 0
+        n = len(events)
+        while i < n:
+            x = events[i][0]
+            # finalize segment [last_x, x) with count cur
+            if x > last_x and cur > 0:
+                segments.append((last_x, x, cur))
+            # process all events at x
+            while i < n and events[i][0] == x:
+                cur += events[i][1]
+                i += 1
+            last_x = x
+        # no trailing segment (open intervals)
+        return segments
+
+    # Fast max-coverage check when adding one candidate (uses segments recomputed on the fly)
+    def max_coverage_with_candidate(intervals, candidate):
+        # We build events for intervals + candidate
+        events = []
+        for l, r in intervals:
+            events.append((l, 1))
+            events.append((r, -1))
+        events.append((candidate[0], 1))
+        events.append((candidate[1], -1))
+        events.sort()
+        cur = 0
+        maxc = 0
+        i = 0
+        n = len(events)
+        while i < n:
+            x = events[i][0]
+            # process all events at x
+            while i < n and events[i][0] == x:
+                cur += events[i][1]
+                i += 1
+            if cur > maxc:
+                maxc = cur
+                # early exit if already exceeding limit
+                if maxc > CLIQUE_LIMIT:
+                    return maxc
+        return maxc
+
+    # Utility: find a "low-coverage" touch point inside interval iv (prefer endpoints + small shift)
+    def pick_touch_points_for_interval(iv, segments):
+        # prefer right endpoint - 0.5, left endpoint + 0.5, and mid
+        l, r = iv
+        candidates = []
+        if r - l >= 2:
+            candidates.append(r - 1)
+            candidates.append(l + 1)
+        mid = (l + r) // 2
+        candidates.append(mid)
+        # score them by coverage (we approximate by looking into segments)
+        def coverage_at(x):
+            for a, b, c in segments:
+                if a <= x < b:
+                    return c
+            return 0
+        scored = sorted(candidates, key=lambda x: coverage_at(x))
+        return scored
+
+    # Normalize intervals to integer endpoints and r > l
+    def normalize_intervals(ints):
+        out = []
+        for l, r in ints:
+            li = int(l)
+            ri = int(r)
+            if ri <= li:
+                ri = li + 1
+            out.append((li, ri))
+        return out
+
+    # Append helper to add interval and update colors incrementally
+    def append_interval(intervals, colors, iv):
+        # compute color for iv vs existing intervals
+        col = candidate_firstfit_color(intervals, colors, iv)
+        intervals.append(iv)
+        colors.append(col)
+        return col
+
+    # ---------- Build initial sparse anchors ----------
+    intervals = []
+    colors = []
+    # Reserve capacity slices: anchors + adversarial connectors + micro-phase
+    # We'll make a moderately large anchor set but not too large to leave room for connectors.
+    anchor_count = min(300, max(40, CAP // 40))  # heuristic: ~ CAP/40 or min 40, capped at 300
+    gap = 4096  # big spacing so anchors are isolated by default
+
+    base_shift = rng_seed % 37  # small deterministic offset for variety
+    for i in range(anchor_count):
+        if len(intervals) >= CAP:
             break
-        # derive deterministic per-round seed and use it for all per-round choices
-        round_val = _per_round_seed(BASE_SEED, ridx)
-        # enforce interleaving on every KT round for stronger cross-scale mixing
-        do_interleave = True if ENFORCE_INTERLEAVE else ((round_val % 2) == 0)
-        # use a bit derived from round_val to deterministically flip block order occasionally
-        reverse_order = ((round_val >> 3) & 1) == 1
-        # supply round_seed to _apply_round to rotate interleaving order deterministically
-        T = _apply_round(T, starts, do_interleave=do_interleave, reverse_order=reverse_order, round_seed=round_val)
-        if len(T) >= CAP:
-            return T[:CAP]
-
-    # Stage 1b (optional): early return guard
-    if len(T) >= CAP - 16:
-        return T[:CAP]
-
-    # Micro-phase A: tail caps to mix colors without exploding omega
-    lo, hi, delta = _span_delta(T)
-    tail_caps = [
-        (lo + max(1, int(round(delta * 0.08))), lo + max(1, int(round(delta * 0.60)))),
-        (lo + max(1, int(round(delta * 0.25))), lo + max(1, int(round(delta * 0.75)))),
-        (lo + max(1, int(round(delta * 0.75))), lo + max(1, int(round(delta * 0.92)))),
-    ]
-    T = _insert_tail_caps(T, tail_caps, CAP)
-
-    if len(T) >= CAP - 16:
-        return T[:CAP]
-
-    # Stage 2: delta2 micro-rounds with thin seeds
-    def _thin_seed(current_T, max_seed):
-        n = len(current_T)
-        if n == 0 or max_seed <= 0:
-            return []
-        step = max(1, n // max_seed)
-        return current_T[::step][:max_seed]
-
-    def _build_micro_round(current_T, budget, iter_id=0, alt=False, round_seed=0):
-        if not current_T or budget <= 8:
-            return []
-
-        glo = min(l for l, _ in current_T)
-        ghi = max(r for _, r in current_T)
-        G = max(1, ghi - glo)
-
-        # seed
-        seed_sz = max(8, min(40, len(current_T) // 250))
-        if alt:
-            seed_sz = max(8, min(64, len(current_T) // 200))
-        U = _thin_seed(current_T, seed_sz)
-        if not U:
-            return []
-
-        ulo = min(l for l, _ in U)
-
-        if not alt:
-            shift = ((round_seed + iter_id) % 3) * 0.02
-            window_fracs = [
-                (0.12 + shift, 0.22 + shift),
-                (0.35 + shift, 0.45 + shift),
-                (0.58 + shift, 0.68 + shift),
-                (0.80 + shift, 0.90 + shift),
-            ]
-            window_fracs = [
-                (max(0.05, min(0.90, a)),
-                 max(0.10, min(0.95, b)))
-                for (a, b) in window_fracs
-            ]
-        else:
-            window_fracs = [(0.05, 0.15), (0.28, 0.38), (0.60, 0.70), (0.82, 0.92)]
-
+        # anchor position widely spaced; tiny intervals of length 1
+        pos = (i * gap) + (base_shift % 7) + (i % 3)
+        iv = (pos, pos + 1)
+        append_interval(intervals, colors, iv)
+
+    # Precompute segments once for selection heuristics
+    segments = compute_segments(intervals)
+
+    # Build mapping color -> list of indices (representatives)
+    def build_color_reps(colors_list, intervals_list):
+        reps = {}
+        for idx, col in enumerate(colors_list):
+            if col not in reps:
+                reps[col] = idx
+        return reps
+
+    # ---------- Adversarial connector phase ----------
+    # Attempt to force new colors iteratively until we hit capacity or can't find a candidate
+    # Limit the number of connector attempts to avoid long run-time
+    max_connector_attempts = CAP - len(intervals) - 16  # leave some room for micro-phase
+    attempts_done = 0
+    stuck_rounds = 0
+
+    while len(intervals) < CAP - 32 and attempts_done < max_connector_attempts and stuck_rounds < 80:
+        attempts_done += 1
+        if not colors:
+            break
+        current_max_color = max(colors)
+        # small cap: do not try to push colors to absurd numbers beyond a cushion times CLIQUE_LIMIT
+        # but allow growth: target up to CLIQUE_LIMIT * 6 or CAP-based
+        reasonable_upper = max(CLIQUE_LIMIT * 6, 60)
+        if current_max_color >= reasonable_upper:
+            break
+
+        reps = build_color_reps(colors, intervals)
+        # We must pick for each color 1..current_max_color some representative interval to intersect
+        # If some color is missing (shouldn't happen), skip;
+        if any(c not in reps for c in range(1, current_max_color + 1)):
+            # rebuild mapping and continue
+            reps = build_color_reps(colors, intervals)
+            if any(c not in reps for c in range(1, current_max_color + 1)):
+                break
+
+        # collect representative intervals
+        rep_indices = [reps[c] for c in range(1, current_max_color + 1)]
+        rep_intervals = [intervals[idx] for idx in rep_indices]
+
+        # compute segments for current state once
+        segments = compute_segments(intervals)
+
+        # For better chances avoid representatives clustered around same spot:
+        # reorder reps by the segment coverage at their midpoints (prefer low coverage first)
+        def coverage_at_point(x):
+            for a, b, c in segments:
+                if a <= x < b:
+                    return c
+            return 0
+        rep_points = []
+        for iv in rep_intervals:
+            l, r = iv
+            mid = (l + r) // 2
+            rep_points.append((coverage_at_point(mid), iv))
+        rep_points.sort(key=lambda x: x[0])  # low coverage first
+        ordered_reps = [iv for _, iv in rep_points]
+
+        # Try a few variants to find a feasible connector forcing a new color
+        found = False
+        # We'll try simple variants: touching endpoints (right-1/left+1), midpoints, and sparse subset spanning
+        variants = []
+        # full-span variant (touch near endpoints of each rep)
+        variants.append(("full_touch", ordered_reps))
+        # sparse variant: sample every ceil(step) rep to reduce overlap density
+        step = max(1, len(ordered_reps) // 8)
+        variants.append(("sparse", ordered_reps[::step]))
+        # reversed order
+        variants.append(("rev", list(reversed(ordered_reps))))
+        # chunked spans (try multiple windows)
+        chunk = max(1, len(ordered_reps) // 4)
+        for cstart in range(0, len(ordered_reps), chunk):
+            variants.append(("chunk", ordered_reps[cstart:cstart + chunk]))
+
+        # Try each variant with some touch-point heuristics
+        for vname, reps_try in variants:
+            if found:
+                break
+            if not reps_try:
+                continue
+            # choose candidate touch points for each representative: try right-edge, left-edge, mid variants
+            # Build arrays of touch candidates per rep (1..3 choices)
+            touch_choices = []
+            for iv in reps_try:
+                l, r = iv
+                choices = []
+                # prefer to intersect near an endpoint to reduce length
+                if r - l >= 2:
+                    choices.append(r - 1)
+                    choices.append(l + 1)
+                choices.append((l + r) // 2)
+                # optionally include leftmost or rightmost extremes
+                choices = list(dict.fromkeys(choices))  # unique while preserving order
+                touch_choices.append(choices)
+
+            # We'll try a few combinations greedily: pick best point per rep by low coverage, then fallback to some random mixes
+            # 1) deterministic best-per-rep
+            sel_points = []
+            for choices in touch_choices:
+                # score by current coverage
+                best = None
+                best_cov = 10**9
+                for p in choices:
+                    cov = 0
+                    for a, b, c in segments:
+                        if a <= p < b:
+                            cov = c
+                            break
+                    if cov < best_cov:
+                        best_cov = cov
+                        best = p
+                sel_points.append(best)
+            if sel_points:
+                s = min(sel_points) - 1
+                e = max(sel_points) + 1
+                if e <= s:
+                    e = s + 1
+                candidate = (s, e)
+                # quick check: candidate must intersect at least one interval of each color in reps_try
+                ok_intersect_all = True
+                for iv in reps_try:
+                    if not overlaps(iv, candidate):
+                        ok_intersect_all = False
+                        break
+                if not ok_intersect_all:
+                    # try to extend slighty to ensure intersection
+                    candidate = (s - 1, e + 1)
+                # compute what color FirstFit would assign
+                target_color = candidate_firstfit_color(intervals, colors, candidate)
+                if target_color == current_max_color + 1:
+                    # ensure max coverage remains <= CLIQUE_LIMIT
+                    maxcov = max_coverage_with_candidate(intervals, candidate)
+                    if maxcov <= CLIQUE_LIMIT:
+                        # accept
+                        append_interval(intervals, colors, candidate)
+                        found = True
+                        stuck_rounds = 0
+                        break
+
+            # 2) random mixing tries (deterministic RNG)
+            mix_tries = 6
+            for _ in range(mix_tries):
+                sel_points = []
+                for choices in touch_choices:
+                    sel_points.append(rng.choice(choices))
+                s = min(sel_points) - rng.randint(0, 2) - 1
+                e = max(sel_points) + rng.randint(0, 2) + 1
+                if e <= s:
+                    e = s + 1
+                candidate = (s, e)
+                # check overlap with reps_try
+                ok_intersect_all = all(overlaps(iv, candidate) for iv in reps_try)
+                if not ok_intersect_all:
+                    continue
+                target_color = candidate_firstfit_color(intervals, colors, candidate)
+                if target_color == current_max_color + 1:
+                    maxcov = max_coverage_with_candidate(intervals, candidate)
+                    if maxcov <= CLIQUE_LIMIT:
+                        append_interval(intervals, colors, candidate)
+                        found = True
+                        stuck_rounds = 0
+                        break
+
+        if not found:
+            stuck_rounds += 1
+        # update segments occasionally for heuristics
+        if len(intervals) % 50 == 0:
+            segments = compute_segments(intervals)
+
+    # ---------- If adversary phase stalls, fill with safe micro patterns ----------
+    # We'll add fractional-window micro-blocks and towers that are designed to avoid increasing clique.
+    def micro_phase_fill(intervals, colors, cap_left):
+        if cap_left <= 0:
+            return
+        lo = 0
+        hi = 1
+        if intervals:
+            lo = min(l for l, _ in intervals)
+            hi = max(r for _, r in intervals)
+        span = max(1, hi - lo)
+        # four window fractions (offsets chosen to diversify)
+        windows = [(0.06, 0.14), (0.26, 0.34), (0.48, 0.62), (0.74, 0.86)]
+        # sample a small seed from existing intervals (or create synthetic if none)
+        seed = intervals[:min(32, max(8, len(intervals) // 200))] if intervals else [(0, 1)]
+        if not seed:
+            seed = [(0, 1)]
+        # create blocks scaled to windows
         blocks = []
-        for wi, (fa, fb) in enumerate(window_fracs):
-            win_lo = glo + int(round(fa * G))
-            base = win_lo - ulo
-            block = [(l + base, r + base) for (l, r) in U]
-            # small parity perturbation, but use round_seed to vary pattern deterministically
-            tag = iter_id + (round_seed % 5)
-            if ((int(round(fa * 100)) // 5) + tag + wi) % 2 == 1:
-                block = list(reversed(block))
+        for (fa, fb) in windows:
+            win_lo = lo + int(round(fa * span))
+            base_shift = win_lo - min(l for l, _ in seed)
+            # translate seed
+            block = [(l + base_shift, r + base_shift) for (l, r) in seed]
             blocks.append(block)
-
-        # interleave with deterministic rotation from round_seed
-        micro = _assemble_from_blocks(blocks, interleave=True, reverse_order=(iter_id % 2 == 1), round_seed=round_seed)
-
-        # connectors (micro-scale)
-        micro_connectors = [
-            (glo + int(round(0.08 * G)), glo + int(round(0.30 * G))),
-            (glo + int(round(0.60 * G)), glo + int(round(0.92 * G))),
-            (glo + int(round(0.26 * G)), glo + int(round(0.56 * G))),
-            (glo + int(round(0.44 * G)), glo + int(round(0.78 * G))),
-        ]
-        for a, b in micro_connectors:
-            if b > a:
-                micro.append((a, b))
-
-        if len(micro) > budget:
-            micro = micro[:budget]
-        return micro
-
-    # Run two main micro rounds (safe cap), with deterministic seeds
-    steps = 2
-    for it in range(steps):
-        room = CAP - len(T)
-        if room <= 8:
+        # interleave blocks
+        micro = []
+        maxlen = max(len(b) for b in blocks)
+        for i in range(maxlen):
+            for blk in blocks:
+                if i < len(blk):
+                    micro.append(blk[i])
+                    if len(micro) >= cap_left:
+                        break
+            if len(micro) >= cap_left:
+                break
+        # add a few connectors across windows (safe)
+        connectors = []
+        connectors.append((lo + int(0.02 * span), lo + int(0.18 * span)))
+        connectors.append((lo + int(0.36 * span), lo + int(0.62 * span)))
+        connectors.append((lo + int(0.68 * span), lo + int(0.94 * span)))
+        # append micro and connectors, validating clique bound
+        for iv in micro + connectors:
+            if len(intervals) >= CAP:
+                break
+            if max_coverage_with_candidate(intervals, iv) <= CLIQUE_LIMIT:
+                append_interval(intervals, colors, iv)
+        return
+
+    room = CAP - len(intervals)
+    # run a couple of micro fills to top up safely
+    micro_rounds = 6
+    for _ in range(micro_rounds):
+        room = CAP - len(intervals)
+        if room <= 0:
             break
-        round_val = (BASE_SEED * 97 + it * 43) & 0xFFFF
-        micro = _build_micro_round(T, room, iter_id=it, alt=False, round_seed=round_val)
-        if not micro:
-            break
-        if len(micro) > room:
-            micro = micro[:room]
-        T.extend(micro)
-
-    # Alternate micro family
-    room = CAP - len(T)
-    if room > 8:
-        round_val = (BASE_SEED * 113 + 2 * 59) & 0xFFFF
-        micro_alt = _build_micro_round(T, room, iter_id=2, alt=True, round_seed=round_val)
-        if micro_alt:
-            if len(micro_alt) > room:
-                micro_alt = micro_alt[:room]
-            T.extend(micro_alt)
-
-    # Stage 3: small pinning micro-phase (short intervals to cap omega)
-    if len(T) < CAP - 8:
-        glo2 = min(l for l, _ in T)
-        ghi2 = max(r for _, r in T)
-        G2 = max(1, ghi2 - glo2)
-        U2 = _thin_seed(T, max(8, min(24, len(T) // 400)))
-        if U2:
-            ulo2 = min(l for l, r in U2)
-            eps = max(1, G2 // 512)
-            windows2 = [(0.05, 0.15), (0.28, 0.38), (0.60, 0.70), (0.82, 0.92)]
-            blocks2 = []
-            for (fa, fb) in windows2:
-                win_lo2 = glo2 + int(round(fa * G2))
-                base2 = win_lo2 - ulo2
-                block = []
-                for idx, (l, r) in enumerate(U2):
-                    mid = (l + r) // 2
-                    L = mid + base2 - (eps // 2) + (idx % 3)
-                    R = L + eps
-                    if R > L:
-                        block.append((L, R))
-                blocks2.append(block)
-
-            micro2 = []
-            if blocks2:
-                maxlen2 = max(len(b) for b in blocks2)
-                order2 = [3, 1, 0, 2]
-                for i in range(maxlen2):
-                    for idx in order2:
-                        blk = blocks2[idx]
-                        if i < len(blk):
-                            micro2.append(blk[i])
-
-            caps2 = [
-                (glo2 + int(round(0.09 * G2)), glo2 + int(round(0.09 * G2)) + eps),
-                (glo2 + int(round(0.64 * G2)), glo2 + int(round(0.64 * G2)) + eps),
-            ]
-            for a, b in caps2:
-                if b > a:
-                    micro2.append((a, b))
-
-            room2 = CAP - len(T)
-            if room2 > 0:
-                if len(micro2) > room2:
-                    micro2 = micro2[:room2]
-                T.extend(micro2)
-
-    # Stage 4: tower-and-cap micro-phase (five towers with caps)
-    if len(T) < CAP - 12:
-        glo3 = min(l for l, r in T)
-        ghi3 = max(r for l, r in T)
-        G3 = max(1, ghi3 - glo3)
-
-        U3 = _thin_seed(T, max(12, min(36, len(T) // 300)))
-        if U3:
-            ulo3 = min(l for l, r in U3)
-            eps3 = max(1, G3 // 768)
-
-            towers = [(0.10, 0.18), (0.28, 0.36), (0.46, 0.54), (0.64, 0.72), (0.82, 0.90)]
-            levels = 3
-            tower_blocks = []
-            for t_idx, (fa, fb) in enumerate(towers):
-                win_lo3 = glo3 + int(round(fa * G3))
-                base3 = win_lo3 - ulo3
-                block = []
-                for idx, (l, r) in enumerate(U3):
-                    mid = (l + r) // 2
-                    for lv in range(levels):
-                        jitter = (idx + lv + t_idx) % 4
-                        L = mid + base3 - (eps3 // 2) + jitter + lv
-                        R = L + eps3
-                        if R > L:
-                            block.append((L, R))
-                tower_blocks.append(block)
-
-            tower_phase = []
-            if tower_blocks:
-                maxlen3 = max(len(b) for b in tower_blocks)
-                order3 = [0, 2, 4, 1, 3]
-                for i in range(maxlen3):
-                    for idx in order3:
-                        blk = tower_blocks[idx]
-                        if i < len(blk):
-                            tower_phase.append(blk[i])
-
-            caps3 = [
-                (glo3 + int(round(0.15 * G3)), glo3 + int(round(0.45 * G3))),
-                (glo3 + int(round(0.38 * G3)), glo3 + int(round(0.70 * G3))),
-                (glo3 + int(round(0.60 * G3)), glo3 + int(round(0.88 * G3))),
-            ]
-            for a, b in caps3:
-                if b > a:
-                    tower_phase.append((a, b))
-
-            room3 = CAP - len(T)
-            if room3 > 0 and tower_phase:
-                if len(tower_phase) > room3:
-                    tower_phase = tower_phase[:room3]
-                T.extend(tower_phase)
-
-    # SECOND MICRO-PHASE (compact, deterministic, cross-scale connectors)
-    room = CAP - len(T)
-    if room > 8:
-        glo4 = min(l for l, _ in T)
-        ghi4 = max(r for _, r in T)
-        G4 = max(1, ghi4 - glo4)
-        # windows chosen to be offset from earlier micro windows to capture new overlaps
-        window_fracs_b = [(0.06, 0.16), (0.30, 0.40), (0.54, 0.64), (0.78, 0.88)]
-        U4 = _thin_seed(T, max(8, min(28, len(T) // 260)))
-        if U4:
-            ulo4 = min(l for l, _ in U4)
-            blocks_b = []
-            for wi, (fa, fb) in enumerate(window_fracs_b):
-                win_lo = glo4 + int(round(fa * G4))
-                base = win_lo - ulo4
-                block = [(l + base, r + base) for (l, r) in U4]
-                if (BASE_SEED + wi) % 2 == 0:
-                    block = list(reversed(block))
-                blocks_b.append(block)
-            micro_b = _assemble_from_blocks(blocks_b, interleave=True, reverse_order=False, round_seed=(BASE_SEED * 3))
-            # add a few conservative long connectors tuned to full span to couple colors across the backbone
-            cross_connectors = [
-                (glo4 + int(round(0.12 * G4)), glo4 + int(round(0.66 * G4))),
-                (glo4 + int(round(0.20 * G4)), glo4 + int(round(0.82 * G4))),
-                (glo4 + int(round(0.36 * G4)), glo4 + int(round(0.90 * G4))),
-            ]
-            for a, b in cross_connectors:
-                if b > a:
-                    micro_b.append((a, b))
-            if len(micro_b) > room:
-                micro_b = micro_b[:room]
-            T.extend(micro_b)
-
-    # Final capacity guard
-    if len(T) > CAP:
-        T = T[:CAP]
-
-    # Normalize endpoints to integers with r > l
-    if not T:
-        return []
-    min_l = min(l for l, _ in T)
-    if min_l < 0:
-        T = [(l - min_l, r - min_l) for (l, r) in T]
-
-    intervals = []
-    for (l, r) in T:
-        li = int(l)
-        ri = int(r)
-        if ri <= li:
-            ri = li + 1
-        intervals.append((li, ri))
-
+        micro_phase_fill(intervals, colors, min(512, room))
+
+    # final small tower-and-cap fill (short intervals likely to touch many active colors)
+    def tower_fill(intervals, colors):
+        room = CAP - len(intervals)
+        if room <= 0:
+            return
+        lo = min((l for l, _ in intervals), default=0)
+        hi = max((r for _, r in intervals), default=1)
+        span = max(1, hi - lo)
+        towers = [(0.10, 0.18), (0.29, 0.37), (0.46, 0.54), (0.63, 0.71), (0.80, 0.88)]
+        seed = intervals[:min(32, max(8, len(intervals) // 200))] if intervals else [(0,1)]
+        for fa, fb in towers:
+            if len(intervals) >= CAP:
+                break
+            win_lo = lo + int(round(fa * span))
+            base_shift = win_lo - min(l for l, _ in seed)
+            block = []
+            eps = max(1, span // 512)
+            for idx, (l, r) in enumerate(seed):
+                mid = (l + r) // 2
+                L = mid + base_shift + (idx % 3)
+                R = L + eps
+                block.append((L, R))
+            # interleave block into intervals as long as safe
+            for iv in block:
+                if len(intervals) >= CAP:
+                    break
+                if max_coverage_with_candidate(intervals, iv) <= CLIQUE_LIMIT:
+                    append_interval(intervals, colors, iv)
+
+    tower_fill(intervals, colors)
+
+    # Final capacity guard and normalization
     if len(intervals) > CAP:
         intervals = intervals[:CAP]
+        colors = colors[:CAP]
+
+    intervals = normalize_intervals(intervals)
+
+    # ensure r > l and integer endpoints
+    if len(intervals) > CAP:
+        intervals = intervals[:CAP]
+
     return intervals
 
 # EVOLVE-BLOCK-END
 
 def run_experiment(**kwargs):
   """Main called by evaluator"""
   return construct_intervals()