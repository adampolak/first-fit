<NAME>
cross_scale_connectors_and_full_interleave
</NAME>

<DESCRIPTION>
I introduce two targeted changes inspired by cross-scale coupling strategies in online interval coloring:

1) Enable deterministic interleaving on every KT spine round. This amplifies color mixing across replicated blocks at each scale, consistently increasing FirstFit pressure without changing the underlying omega behavior of the KT construction.

2) Append a small, CAP-aware set of long-range cross-scale connectors after the micro-phases. These connectors are placed at fixed fractional spans of the current global delta and are designed to overlap different parts of the spine without creating a single large clique, thereby raising FF colors while keeping omega at most 10. The placement avoids concentrating all connectors around the same point, following the “connector” heuristics from the literature and prior best runs.

Both changes are deterministic and minimal, keep total intervals under CAP, and maintain the original interface. They aim to push the competitive ratio beyond the 2.30 plateau observed in prior variants.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
  for ridx in range(6):
    if 4 * len(T) + 4 > CAP:
      break
    starts = template_bank[ridx % len(template_bank)]
    # Interleave on even rounds; reverse block order on odd rounds
    do_inter = (ridx % 2 == 0)
    rev = (ridx % 2 == 1)
    T = _apply_round(T, starts, do_interleave=do_inter, reverse_order=rev)
=======
  for ridx in range(6):
    if 4 * len(T) + 4 > CAP:
      break
    starts = template_bank[ridx % len(template_bank)]
    # Always interleave blocks to maximize cross-block color mixing; reverse order on odd rounds
    do_inter = True
    rev = (ridx % 2 == 1)
    T = _apply_round(T, starts, do_interleave=do_inter, reverse_order=rev)
>>>>>>> REPLACE
<<<<<<< SEARCH
  room = CAP - len(T)
  if room > 8:
    microB = build_micro_delta_round(T, room, iter_id=1, alt=True)
    if microB:
      if len(microB) > room:
        microB = microB[:room]
      T.extend(microB)

  # Final capacity trim
  if len(T) > CAP:
    T = T[:CAP]
=======
  room = CAP - len(T)
  if room > 8:
    microB = build_micro_delta_round(T, room, iter_id=1, alt=True)
    if microB:
      if len(microB) > room:
        microB = microB[:room]
      T.extend(microB)

  # Deterministic cross-scale connectors anchored to current span (CAP-aware)
  room = CAP - len(T)
  if room > 0:
    lo2, hi2, delta2 = _span_delta(T)
    def _frac_iv(a_frac, b_frac):
      L = lo2 + max(1, int(round(a_frac * delta2)))
      R = lo2 + max(1, int(round(b_frac * delta2)))
      if R <= L:
        R = L + 1
      return (L, R)
    connectors2 = [
      _frac_iv(0.14, 0.52),
      _frac_iv(0.32, 0.88),
      _frac_iv(0.05, 0.47),
      _frac_iv(0.62, 0.95),
      _frac_iv(0.20, 0.41),
      _frac_iv(0.71, 0.89),
    ]
    if room < len(connectors2):
      connectors2 = connectors2[:room]
    T.extend(connectors2)

  # Final capacity trim
  if len(T) > CAP:
    T = T[:CAP]
>>>>>>> REPLACE

</DIFF>