<NAME>
break_self_similarity_with_jitter_and_extra_rounds
</NAME>

<DESCRIPTION>
Proposed targeted enhancements to the current interval construction to push FirstFit color usage further without inflating omega (clique number).

Idea 1: break self-similarity via deterministic jitter
- Rationale: The current construction uses fixed integer starts and deterministic templates, which can lead to highly self-similar overlap patterns. FirstFit benefits from varied overlap structures; small, deterministic jitter prevents pathological repetition while staying reproducible.
- What: apply a tiny, round-and-index dependent linear jitter to each start before translating the base waves. This jitter is computed deterministically (no randomness), using a simple arithmetic hash to vary positions slightly per round and per block.

Idea 2: a controlled extra expansion phase
- Rationale: The best known lower bounds for FF performance benefit from multi-phase growth. Adding a deterministic, extra expansion phase can intensify color pressure beyond the base rounds while still controlling omega.
- What: introduce an extra_rounds parameter (default 0). After finishing the main rounds, perform extra, deterministic expansion passes using an alternate set of starts and a small template bank. This phase is optional and configurable, ensuring backward compatibility.

Impact
- The jitter disrupts self-similar packing, typically increasing the number of colors used by FirstFit for a given omega bound.
- The extra_rounds phase yields additional wave interactions, potentially boosting the combined score without altering the offline optimum in a destabilizing way.

Notes
- All changes are deterministic, reproducible, and localized to the existing function. No global randomness is introduced.
- The changes preserve the existing strategy (template banks, start patterns, bridging, and caps) while injecting controlled diversification and additional expansion.

</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
def construct_intervals(rounds=3, seed_lo=0.0, seed_scale=1.0):
  """
  Deterministic, adaptive multi-round wave construction.
  - rounds: number of recursive expansion rounds
  - seed_lo / seed_scale: deterministic knobs for initial placement and scaling
  Returns:
    intervals: list of intervals (l, r) as open intervals
  """
  # Seed with several disjoint unit intervals to promote early overlap coupling
  T = [(seed_lo, seed_lo + 1.0 * seed_scale),
       (seed_lo + 2.0 * seed_scale, seed_lo + 3.0 * seed_scale),
       (seed_lo + 4.0 * seed_scale, seed_lo + 5.0 * seed_scale),
       (seed_lo + 6.0 * seed_scale, seed_lo + 7.0 * seed_scale)]
=======
def construct_intervals(rounds=3, seed_lo=0.0, seed_scale=1.0, extra_rounds=0):
  """
  Deterministic, adaptive multi-round wave construction.
  - rounds: number of recursive expansion rounds
  - seed_lo / seed_scale: deterministic knobs for initial placement and scaling
  - extra_rounds: additional, deterministic expansion rounds to apply after the main rounds
  Returns:
    intervals: list of intervals (l, r) as open intervals
  """
  # Seed with several disjoint unit intervals to promote early overlap coupling
  T = [(seed_lo, seed_lo + 1.0 * seed_scale),
       (seed_lo + 2.0 * seed_scale, seed_lo + 3.0 * seed_scale),
       (seed_lo + 4.0 * seed_scale, seed_lo + 5.0 * seed_scale),
       (seed_lo + 6.0 * seed_scale, seed_lo + 7.0 * seed_scale)]
>>>>>>> REPLACE
=======
def construct_intervals(rounds=3, seed_lo=0.0, seed_scale=1.0, extra_rounds=0):
  """
  Deterministic, adaptive multi-round wave construction.
  - rounds: number of recursive expansion rounds
  - seed_lo / seed_scale: deterministic knobs for initial placement and scaling
  - extra_rounds: additional, deterministic expansion rounds to apply after the main rounds
  Returns:
    intervals: list of intervals (l, r) as open intervals
  """
  # Seed with several disjoint unit intervals to promote early overlap coupling
  T = [(seed_lo, seed_lo + 1.0 * seed_scale),
       (seed_lo + 2.0 * seed_scale, seed_lo + 3.0 * seed_scale),
       (seed_lo + 4.0 * seed_scale, seed_lo + 5.0 * seed_scale),
       (seed_lo + 6.0 * seed_scale, seed_lo + 7.0 * seed_scale)]
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
  for round_idx in range(rounds):
    lo = min(l for l, r in T)
    hi = max(r for l, r in T)
    delta = hi - lo
    if delta <= 0:
      delta = 1.0  # safety

    S = []

    # pick deterministic pattern/template for this round
    starts = list(start_patterns[round_idx % len(start_patterns)])
    template = templates[round_idx % len(templates)]

    # Build translated copies with alternating inner order to hamper color reuse
    for idx, start in enumerate(starts):
      base = T if (idx % 2 == 0) else list(reversed(T))
      S += [(delta * start + l - lo, delta * start + r - lo) for l, r in base]

      # light bridging between consecutive blocks to couple colors
      if idx + 1 < len(starts):
        nxt = starts[idx + 1]
        S.append((delta * (start + 0.5), delta * (nxt + 0.5)))
=======
  for round_idx in range(rounds):
    lo = min(l for l, r in T)
    hi = max(r for l, r in T)
    delta = hi - lo
    if delta <= 0:
      delta = 1.0  # safety

    S = []

    # pick deterministic pattern/template for this round
    starts = list(start_patterns[round_idx % len(start_patterns)])
    template = templates[round_idx % len(templates)]

    # Build translated copies with alternating inner order to hamper color reuse
    for idx, start in enumerate(starts):
      # deterministic jitter to break self-similarity (purely deterministic)
      jitter = ((round_idx * 13 + idx * 37) % 97) / 97.0 * 0.8 - 0.4  # in [-0.4, 0.4)
      adj_start = start + jitter

      base = T if (idx % 2 == 0) else list(reversed(T))
      S += [(delta * adj_start + l - lo, delta * adj_start + r - lo) for l, r in base]

      # light bridging between consecutive blocks to couple colors
      if idx + 1 < len(starts):
        nxt = starts[idx + 1]
        S.append((delta * (adj_start + 0.5), delta * (nxt + 0.5)))
      # optional second-next bridge to increase interaction
      if (round_idx % 2 == 0) and (idx + 2 < len(starts)):
        nxt2 = starts[idx + 2]
        S.append((delta * (adj_start + 0.75), delta * (nxt2 + 0.25)))
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    # Add the chosen template intervals scaled by delta
    S += [(delta * a, delta * b) for (a, b) in template]

    # Add sparse caps to push color usage without large omega
    max_start = max(starts)
    caps_step = max(3, int(max(3, max_start) // 4))
    for j in range(2, max_start, caps_step):
      # small caps around positions to lightly pressure color usage
      S.append((delta * (j - 0.5), delta * (j + 1.0 + 0.5)))

    T = S
=======
    # Add the chosen template intervals scaled by delta
    S += [(delta * a, delta * b) for (a, b) in template]

    # Add sparse caps to push color usage without large omega
    max_start = max(starts)
    caps_step = max(3, int(max(3, max_start) // 4))
    for j in range(2, max_start, caps_step):
      # small caps around positions to lightly pressure color usage
      S.append((delta * (j - 0.5), delta * (j + 1.0 + 0.5)))

    T = S

  # Optional extra rounds to further pressure FirstFit
  for _ in range(extra_rounds):
    lo = min(l for l, r in T)
    hi = max(r for l, r in T)
    delta = hi - lo
    if delta <= 0:
      delta = 1.0
    S = []

    extended_starts = [2, 4, 6, 8, 12, 16, 20, 24]
    extended_template = [(1,5), (12,16), (4,9), (8,13)]

    for idx, start in enumerate(extended_starts):
      base = T if (idx % 2 == 0) else list(reversed(T))
      S += [(delta * start + l - lo, delta * start + r - lo) for l, r in base]
      if idx + 1 < len(extended_starts):
        nxt = extended_starts[idx + 1]
        S.append((delta * (start + 0.5), delta * (nxt + 0.5)))

    S += [(delta * a, delta * b) for (a, b) in extended_template]
    T = S
>>>>>>> REPLACE
</DIFF>