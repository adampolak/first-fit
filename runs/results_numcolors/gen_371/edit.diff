--- a/original.py
+++ b/original.py
@@ -1,254 +1,279 @@
 # EVOLVE-BLOCK-START
 
 def construct_intervals(enable_alt_microphase=True):
   """
-  Construct a sequence of intervals of real line,
-  in the order in which they are presented to FirstFit,
-  so that it maximizes the number of colors used by FirstFit
-  divided by the maximum number of intervals that cover a single point.
-
-  Deterministic KT-style backbone with two CAP-aware micro-phases and
-  carefully chosen connectors, keeping omega small (target <= 10).
+  Construct a sequence of intervals in FF order to maximize FirstFit/omega
+  while keeping omega <= ~10 (target). Deterministic, CAP-aware pipeline.
 
   Args:
-    enable_alt_microphase (bool): enable a second, alternate micro-phase.
+    enable_alt_microphase (bool): retain interface; enables the second micro-pass.
 
   Returns:
-    intervals: list of tuples, each tuple (l, r) represents an open interval from l to r.
+    List[(l, r)] integer open intervals (r > l).
   """
 
-  # Capacity guard to keep total intervals < 10000
+  # Global capacity guard (stay below evaluator hard bound)
   CAP = 9800
-
-  # Rotating six-start templates for the KT spine (expanded bank for more mixing)
-  template_bank = [
-    (2, 6, 10, 14),  # classic KT
-    (1, 5, 9, 13),   # left-shifted
-    (3, 7, 11, 15),  # right-shifted
-    (4, 8, 12, 16),  # stretched-right
-    (5, 9, 13, 17),  # extra right-shift
-    (6, 10, 14, 18), # extra classic-shift
+  BASE_SEED = 271828  # purely for deterministic choices; no RNG used
+
+  # Six-template bank for the backbone rotation (recommendation 1)
+  TEMPLATE_BANK_6 = [
+    (2, 6, 10, 14),  # T0 classic KT
+    (1, 5, 9, 13),   # T1 left-shifted
+    (3, 7, 11, 15),  # T2 right-shifted
+    (4, 8, 12, 16),  # T3 stretched-right
+    (5, 9, 13, 17),  # T4 extra right-shift
+    (2, 8, 12, 16),  # T5 inner symmetric
   ]
 
-  # Seed with a single unit interval
-  T = [(0, 1)]
-
-  # Helpers
-  def _span(current_T):
-    lo = min(l for l, r in current_T)
-    hi = max(r for l, r in current_T)
-    delta = hi - lo
-    if delta <= 0:
-      delta = 1
-    return lo, hi, delta
-
-  def _apply_round(current_T, starts, do_interleave=False, reverse_order=False):
-    lo, hi, delta = _span(current_T)
-
-    # Build four translated blocks
+  # Stage helpers
+  def span_delta(seq):
+    lo = min(l for l, r in seq)
+    hi = max(r for l, r in seq)
+    d = hi - lo
+    if d <= 0:
+      d = 1
+    return lo, hi, d
+
+  def replicate_blocks(seq, starts):
+    lo, hi, d = span_delta(seq)
     blocks = []
     for s in starts:
-      base = s * delta - lo
-      block = [(l + base, r + base) for (l, r) in current_T]
-      blocks.append(block)
-
-    # Interleaving policy: order derived from 'starts' to diversify per-round mixing
-    S = []
-    if do_interleave:
-      # define order by sorting block indices by start values (or reverse)
-      order = sorted(range(4), key=lambda i: starts[i], reverse=reverse_order)
-      maxlen = max(len(b) for b in blocks)
-      for i in range(maxlen):
-        for idx in order:
-          blk = blocks[idx]
-          if i < len(blk):
-            S.append(blk[i])
-    else:
-      if reverse_order:
-        blocks = list(reversed(blocks))
-      for blk in blocks:
-        S.extend(blk)
-
-    # Classic four connectors (Figure-4 style)
+      base = s * d - lo
+      blocks.append([(l + base, r + base) for (l, r) in seq])
+    return blocks, d
+
+  def interleave_blocks(blocks, order):
+    out = []
+    maxlen = max(len(b) for b in blocks) if blocks else 0
+    for i in range(maxlen):
+      for idx in order:
+        blk = blocks[idx]
+        if i < len(blk):
+          out.append(blk[i])
+    return out
+
+  def append_kt_connectors(dst, starts, delta):
     s0, s1, s2, s3 = starts
-    S.append(((s0 - 1) * delta, (s1 - 1) * delta))  # left cap
-    S.append(((s2 + 2) * delta, (s3 + 2) * delta))  # right cap
-    S.append(((s0 + 2) * delta, (s2 - 1) * delta))  # cross 1
-    S.append(((s1 + 2) * delta, (s3 - 1) * delta))  # cross 2
-    return S
-
-  # Stage 1: KT spine with rotation and parity policies, capacity-guarded
-  for ridx in range(12):
-    # Predict next size: sz -> 4*sz + 4
-    if 4 * len(T) + 4 > CAP:
-      break
-    starts = template_bank[ridx % len(template_bank)]
-    # Always interleave to maximize mixing; vary reverse order every third round
-    do_inter = True
-    rev = (ridx % 3 == 0)
-    T = _apply_round(T, starts, do_interleave=do_inter, reverse_order=rev)
-    # Spine-density boost: duplicate a small fraction of intervals shrunk slightly to increase FF pressure
-    if len(T) < CAP:
-      lo_s, hi_s, span_s = _span(T)
-      eps = max(1, span_s // 1000)
-      # boost up to 10 intervals or 20% of current T, staying within capacity
-      boost = min(20, CAP - len(T), len(T) // 5)
-      for (l_s, r_s) in T[:boost]:
-        if r_s - l_s > 2 * eps:
-          T.append((l_s + eps, r_s - eps))
-
-  # Early exit if nearly at capacity (before micro-phases)
-  if len(T) >= CAP - 8:
-    return T
-
-  # Spine densification: duplicate a thin seed of intervals with slight shrink to boost FF pressure
-  room = CAP - len(T)
-  if room > 16:
-    # Sample a larger seed of intervals uniformly from the KT spine
-    stride = max(1, len(T) // 100)
-    seed = [T[i] for i in range(0, len(T), stride)][:20]
-    lo_d, hi_d, span_d = _span(T)
-    eps = max(1, span_d // 1000)
-    densify = []
-    for (l, r) in seed:
-      if r - l > 2 * eps:
-        densify.append((l + eps, r - eps))
-    # Insert densified intervals if capacity allows
-    for iv in densify:
-      if len(T) >= CAP:
-        break
-      T.append(iv)
-
-  # Micro-phase A: add three long-range caps to boost FF pressure (capacity-safe)
-  lo, hi, _ = _span(T)
-  span = max(1, hi - lo)
-  def cap_at(a_frac, b_frac):
-    L = lo + max(1, int(round(a_frac * span)))
-    R = lo + max(1, int(round(b_frac * span)))
-    if R <= L:
-      R = L + 1
-    return (L, R)
-  caps = [cap_at(0.08, 0.60), cap_at(0.25, 0.75), cap_at(0.75, 0.92)]
-  for c in caps:
-    if len(T) >= CAP:
-      break
-    T.append(c)
-
-  # Micro-phase builder: thin-window replication with connectors
-  def build_micro_delta_round(current_T, budget, alt=False):
-    if not current_T or budget <= 8:
-      return []
-
-    glo = min(l for l, r in current_T)
-    ghi = max(r for l, r in current_T)
+    dst.append(((s0 - 1) * delta, (s1 - 1) * delta))  # left cap
+    dst.append(((s2 + 2) * delta, (s3 + 2) * delta))  # right cap
+    dst.append(((s0 + 2) * delta, (s2 - 1) * delta))  # cross 1
+    dst.append(((s1 + 2) * delta, (s3 - 1) * delta))  # cross 2
+
+  def normalize_and_cap(seq):
+    if not seq:
+      return []
+    # Shift to nonnegative if needed and coerce to integers
+    mn = min(l for l, r in seq)
+    if mn < 0:
+      seq = [(l - mn, r - mn) for (l, r) in seq]
+    out = []
+    for l, r in seq:
+      li = int(l)
+      ri = int(r)
+      if ri <= li:
+        ri = li + 1
+      out.append((li, ri))
+    if len(out) > CAP:
+      out = out[:CAP]
+    return out
+
+  # Deterministic per-round spine densification (recommendation 5)
+  def apply_density_multiplier(dst, center_frac=0.50, width_frac=0.20, mult=1.10, max_add=18):
+    if not dst:
+      return dst
+    lo, hi, d = span_delta(dst)
+    # Collect a central subset index range
+    n = len(dst)
+    c_idx = int(n * center_frac)
+    halfw = max(1, int(n * width_frac * 0.5))
+    left = max(0, c_idx - halfw)
+    right = min(n, c_idx + halfw)
+    subset = dst[left:right]
+
+    # Shrink-and-duplicate a sparse sample from subset, capped by max_add and CAP
+    if not subset:
+      return dst
+    stride = max(1, len(subset) // max(8, min(max_add, len(subset))))
+    sample = subset[::stride][:max_add]
+    eps = max(1, d // 1200)
+    additions = []
+    for (l, r) in sample:
+      # Keep inside span and shrink slightly to avoid omega spikes
+      nl = l + eps
+      nr = r - eps
+      if nr - nl > 0:
+        additions.append((nl, nr))
+    # Cap additions by remaining capacity
+    room = CAP - len(dst)
+    if room <= 0 or not additions:
+      return dst
+    if len(additions) > room:
+      additions = additions[:room]
+    dst.extend(additions)
+    return dst
+
+  # Two-pass micro-phase builder (recommendation 2)
+  def build_micro(seq, budget, windows, add_long_cross=False, seed_boost=False):
+    if not seq or budget <= 8:
+      return []
+    glo = min(l for l, r in seq)
+    ghi = max(r for l, r in seq)
     G = max(1, ghi - glo)
 
-    # Thin, evenly spaced seed
-    seed_sz = max(8, min(32, len(current_T) // 300))
-    if alt:
-      seed_sz = max(8, min(48, len(current_T) // 250))
-    stride = max(1, len(current_T) // max(1, seed_sz))
-    U = [current_T[i] for i in range(0, len(current_T), stride)][:seed_sz]
+    # Seed sizing depends on current length and pass type
+    base_seed = max(8, min(36, len(seq) // 290))
+    seed_sz = base_seed + (8 if seed_boost else 0)
+    seed_sz = min(seed_sz, 48)
+
+    stride = max(1, len(seq) // seed_sz)
+    U = [seq[i] for i in range(0, len(seq), stride)][:seed_sz]
     if not U:
       return []
-
     ulo = min(l for l, r in U)
 
-    # Four windows across the span (stay inside to control omega)
-    if not alt:
-      window_fracs = [(0.12, 0.22), (0.35, 0.45), (0.58, 0.68), (0.80, 0.90)]
-    else:
-      # expanded five-window family for alt-phase to increase cross-scale overlap
-      window_fracs = [(0.05, 0.15), (0.22, 0.32), (0.45, 0.55), (0.68, 0.78), (0.82, 0.92)]
-
-    # Build translated micro-blocks aligned to these windows
+    # Build translated blocks for each window
     blocks = []
-    for (fa, fb) in window_fracs:
+    for (fa, fb) in windows:
+      fa = max(0.05, min(0.90, fa))
+      fb = max(0.10, min(0.95, fb))
       win_lo = glo + int(round(fa * G))
       base = win_lo - ulo
       block = [(l + base, r + base) for (l, r) in U]
-      # Internal reversal on alternating pattern for alt-phase to diversify
-      if alt and int(round(fa * 100)) // 5 % 2 == 1:
+      # Alternate reversal by window parity to break symmetry
+      tag = (int(round(fa * 100)) // 5) % 2
+      if tag == 1:
         block = list(reversed(block))
       blocks.append(block)
 
-    # Interleave micro-blocks to maximize FF mixing
-    micro = []
-    maxlen = max(len(b) for b in blocks)
-    if not alt:
-      # forward interleave
-      for i in range(maxlen):
-        for blk in blocks:
-          if i < len(blk):
-            micro.append(blk[i])
-    else:
-      # reverse interleave
-      for i in range(maxlen):
-        for blk in reversed(blocks):
-          if i < len(blk):
-            micro.append(blk[i])
-
-    # Fractional-span connectors at the micro scale
+    # Deterministic interleaving order based on base seed and window count
+    order = list(range(len(blocks)))
+    if (BASE_SEED + len(blocks)) % 3 == 0:
+      order.reverse()
+    micro = interleave_blocks(blocks, order)
+
+    # Fractional-span connectors at micro scale
     micro_connectors = [
-      (glo + int(round(0.08 * G)), glo + int(round(0.30 * G))),  # left cap
-      (glo + int(round(0.60 * G)), glo + int(round(0.92 * G))),  # right cap
-      (glo + int(round(0.26 * G)), glo + int(round(0.56 * G))),  # cross 1
-      (glo + int(round(0.44 * G)), glo + int(round(0.78 * G))),  # cross 2
+      (glo + int(round(0.08 * G)), glo + int(round(0.30 * G))),
+      (glo + int(round(0.60 * G)), glo + int(round(0.92 * G))),
+      (glo + int(round(0.26 * G)), glo + int(round(0.56 * G))),
+      (glo + int(round(0.44 * G)), glo + int(round(0.78 * G))),
     ]
     for a, b in micro_connectors:
       if b > a:
         micro.append((a, b))
 
-    # A long cross to tie distant colors (alt-phase only)
-    if alt:
+    # Optional single long cross (guarded)
+    if add_long_cross:
       a = glo + int(round(0.18 * G))
       b = glo + int(round(0.84 * G))
       if b > a:
         micro.append((a, b))
 
-    # Trim to available budget
     if len(micro) > budget:
       micro = micro[:budget]
     return micro
 
-  # Micro-phase B: one safeguarded micro-round (empirically strong for 2.30-tier results)
+  # Post-spine deterministic long-range connectors (recommendation 3)
+  def build_long_range_connectors(seq, at_most=6):
+    if not seq or at_most <= 0:
+      return []
+    lo, hi, d = span_delta(seq)
+    # Choose 4â€“6 connectors anchored to global span; endpoints reproducible from BASE_SEED
+    picks = []
+    anchors = [
+      (0.12, 0.62),
+      (0.22, 0.78),
+      (0.38, 0.86),
+      (0.48, 0.90),
+      (0.30, 0.70),
+      (0.15, 0.85),
+    ]
+    # Deterministic rotation
+    rot = (BASE_SEED // 7) % len(anchors)
+    for i in range(min(at_most, len(anchors))):
+      a_frac, b_frac = anchors[(rot + i) % len(anchors)]
+      L = lo + max(1, int(round(a_frac * d)))
+      R = lo + max(1, int(round(b_frac * d)))
+      if R > L:
+        picks.append((L, R))
+    # Guard return by CAP budget where appended
+    return picks
+
+  # Backbone: six rounds with deterministic interleaving schedule (recommendation 4)
+  T = [(0, 1)]  # seed
+  for ridx in range(6):
+    # Predict size growth: sz -> 4*sz + 4
+    nxt = 4 * len(T) + 4
+    if nxt > CAP:
+      break
+    starts = TEMPLATE_BANK_6[(BASE_SEED + ridx) % len(TEMPLATE_BANK_6)]
+    blocks, delta = replicate_blocks(T, starts)
+
+    # Interleave on even rounds; sequential with reverse on odd rounds
+    if ridx % 2 == 0:
+      order = sorted(range(4), key=lambda i: starts[i])  # deterministic forward
+      S = interleave_blocks(blocks, order)
+    else:
+      order = list(reversed(range(4)))  # reversed sequential
+      S = []
+      for i in order:
+        S.extend(blocks[i])
+
+    # Append KT connectors for this round
+    append_kt_connectors(S, starts, delta)
+
+    # Apply per-round density multiplier to a central subset (conservative)
+    S = apply_density_multiplier(S, center_frac=0.50, width_frac=0.18, mult=1.10, max_add=14)
+
+    # Capacity clamp after each round
+    if len(S) > CAP:
+      S = S[:CAP]
+
+    T = S
+
+  # Two-pass micro-phase budgeting anchored to the backbone (recommendation 2)
+  # Pass-1 windows A; Pass-2 windows B, non-overlapping families
+  windows_A = [(0.12, 0.22), (0.35, 0.45), (0.58, 0.68), (0.80, 0.90)]
+  windows_B = [(0.06, 0.14), (0.28, 0.38), (0.54, 0.64), (0.74, 0.84)]
+
+  # Budget split: allocate remaining CAP deterministically 55% for pass-1, 45% for pass-2
   room = CAP - len(T)
   if room > 8:
-    micro = build_micro_delta_round(T, room, alt=False)
-    if micro:
-      if len(micro) > room:
-        micro = micro[:room]
-      T.extend(micro)
-
-  # Micro-phase C: alternate window family + long cross (guarded, optional)
+    bud1 = int(room * 0.55)
+    bud2 = room - bud1
+    # Build pass-1 (no long cross, moderate seed)
+    micro1 = build_micro(T, bud1, windows_A, add_long_cross=False, seed_boost=False)
+    if micro1:
+      avail = CAP - len(T)
+      if len(micro1) > avail:
+        micro1 = micro1[:avail]
+      T.extend(micro1)
+
   room = CAP - len(T)
   if enable_alt_microphase and room > 8:
-    micro_alt = build_micro_delta_round(T, room, alt=True)
-    if micro_alt:
-      if len(micro_alt) > room:
-        micro_alt = micro_alt[:room]
-      T.extend(micro_alt)
-
-  # Final global wide caps: layered wide intervals to boost FF without raising omega much
+    # Pass-2 (long cross enabled, slightly boosted seed)
+    bud2 = room  # use remaining room
+    micro2 = build_micro(T, bud2, windows_B, add_long_cross=True, seed_boost=True)
+    if micro2:
+      avail = CAP - len(T)
+      if len(micro2) > avail:
+        micro2 = micro2[:avail]
+      T.extend(micro2)
+
+  # Deterministic long-range connectors appended after micro-phases (recommendation 3)
   room = CAP - len(T)
-  if room > 3:
-    lo_f, hi_f, span_f = _span(T)
-    eps_f = max(1, span_f // 200)
-    for k in range(3):
-      if len(T) >= CAP:
-        break
-      L = lo_f + eps_f * (k + 1)
-      R = hi_f - eps_f * (k + 1)
-      if R > L:
-        T.append((L, R))
-  # Final capacity trim
-  if len(T) > CAP:
-    T = T[:CAP]
-
-  return T
+  if room > 0:
+    lr = build_long_range_connectors(T, at_most=min(6, room))
+    if lr:
+      add = lr[:room]
+      T.extend(add)
+
+  # Final normalization and capacity enforcement
+  return normalize_and_cap(T)
 
 # EVOLVE-BLOCK-END
 
 def run_experiment(**kwargs):
   """Main called by evaluator"""
   return construct_intervals()