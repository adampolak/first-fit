<NAME>
spine_expand_rotate_and_long_connectors
</NAME>

<DESCRIPTION>
I propose three focused changes to raise FirstFit pressure while keeping omega modest:

1. Expand the spine template bank from 4 to 6 templates and rotate through them. This increases variety of relative translations across rounds so colors mix in more diverse ways (inspired by recommendation 3).
2. Increase the frequency and variety of interleaving: instead of interleaving every 2nd round, interleave on a 3-round cadence and vary the block order deterministically by round index. This enforces deterministic, richer interleaving patterns (recommendation 1).
3. After completing the spine rounds, append a small set of deterministic long-range connectors that span scaled positions across the final spine span. These connectors are capacity-guarded and intended to couple color classes across distant regions without raising omega much (recommendation 4).

The edit is local and conservative: it keeps the existing micro-phases and capacity guards but changes the template bank, the interleaving cadence and ordering, and adds a short deterministic connector pass. These changes should produce more cross-coupling of colors and so increase FF usage relative to OPT.

Below is an exact SEARCH/REPLACE diff for the EVOLVE block. Only the block between EVOLVE-BLOCK-START and EVOLVE-BLOCK-END is replaced.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
def construct_intervals():
  """
  Construct a sequence of intervals of real line,
  in the order in which they are presented to FirstFit,
  so that it maximizes the number of colors used by FirstFit
  divided by the maximum number of intervals that cover a single point

  The initial implementation uses the construction from
  Figure 4 in https://arxiv.org/abs/1506.00192

  Returns:
    intervals: list of tuples, each tuple (l, r) represents an open interval from l to r
  """

  # Capacity guard to keep total intervals < 10000
  CAP = 9800

  # Rotate among four strong start-pattern templates to couple colors across rounds
  template_bank = [
    (2, 6, 10, 14),  # classic KT
    (1, 5, 9, 13),   # left-shifted
    (3, 7, 11, 15),  # right-shifted
    (4, 8, 12, 16),  # stretched-right
  ]

  T = [(0, 1)]
  for round_idx in range(6):
    starts = template_bank[round_idx % 4]
    lo = min(l for l, r in T)
    hi = max(r for l, r in T)
    delta = hi - lo if hi > lo else 1
    # build translated blocks
    blocks = []
    for start in starts:
      blocks.append([(delta * start + l - lo, delta * start + r - lo) for l, r in T])
    S = []
    # Interleave on even rounds, sequential on odd rounds
    if round_idx % 2 == 0:
      maxlen = max(len(b) for b in blocks)
      for i in range(maxlen):
        for blk in blocks:
          if i < len(blk):
            S.append(blk[i])
    else:
      for blk in blocks:
        S.extend(blk)
    # connectors based on the active starts
    s0, s1, s2, s3 = starts
    connectors = [
      (delta * (s0 - 1), delta * (s1 - 1)),  # left cap
      (delta * (s2 + 2), delta * (s3 + 2)),  # right cap
      (delta * (s0 + 2), delta * (s2 - 1)),  # cross 1
      (delta * (s1 + 2), delta * (s3 - 1)),  # cross 2
    ]
    for a, b in connectors:
      S.append((a, b))
    T = S

  # Stage 2: Two delta2-driven micro extension rounds (thin sampling; four-start translations).
  # Skip if near capacity.
  if len(T) < CAP - 16:
    def thin_seed(current_T, max_seed):
      n = len(current_T)
      if n == 0 or max_seed <= 0:
        return []
      step = max(1, n // max_seed)
      return current_T[::step][:max_seed]

    def micro_round(current_T, round_id, budget):
      if budget <= 0 or not current_T:
        return []
      glo = min(l for l, r in current_T)
      ghi = max(r for l, r in current_T)
      G = max(1, ghi - glo)
      # Use half-scale to avoid expanding the global span too aggressively
      delta2 = max(1, G // 2)

      # Thin seed: bounded and deterministic size to respect budget
      per_block_target = max(8, min(64, budget // 12))
      U = thin_seed(current_T, per_block_target)
      if not U:
        return []

      # Build four translated blocks using the same 4-start template,
      # with deterministic parity-based internal reversal
      blocks = []
      ulo = min(l for l, r in U)
      s0, s1, s2, s3 = template_bank[0]
      for s in (s0, s1, s2, s3):
        base = s * delta2 - ulo
        block = [(l + base, r + base) for (l, r) in U]
        if ((s // 2) % 2) == (round_id % 2):
          block = list(reversed(block))
        blocks.append(block)

      micro = []
      # Parity-based interleaving across blocks
      maxlen = max(len(b) for b in blocks)
      if round_id % 2 == 0:
        for i in range(maxlen):
          for blk in blocks:
            if i < len(blk):
              micro.append(blk[i])
      else:
        for i in range(maxlen):
          for blk in reversed(blocks):
            if i < len(blk):
              micro.append(blk[i])

      # Deterministic connectors at delta2 scale, including a longer cross3
      connectors = [
        ((s0 - 1) * delta2 + glo, (s1 - 1) * delta2 + glo),  # left cap
        ((s2 + 2) * delta2 + glo, (s3 + 2) * delta2 + glo),  # right cap
        ((s0 + 2) * delta2 + glo, (s2 - 1) * delta2 + glo),  # cross 1
        ((s1 + 2) * delta2 + glo, (s3 - 1) * delta2 + glo),  # cross 2
        ((s0 + 3) * delta2 + glo, (s3 + 3) * delta2 + glo),  # cross3 (long range)
      ]
      micro.extend(connectors)

      # Sparse micro caps to press FirstFit locally without raising omega much
      cap1 = (glo + (delta2 // 4), glo + int(1.8 * delta2))
      cap2 = (glo + int(0.9 * delta2), glo + int(2.6 * delta2))
      mid = glo + G // 2
      cap3 = (mid - max(1, delta2 // 8), mid + max(1, delta2 // 8))
      for cap in (cap1, cap2, cap3):
        if cap[1] > cap[0]:
          micro.append(cap)

      # Enforce budget
      if len(micro) > budget:
        micro = micro[:budget]
      return micro

    remaining = CAP - len(T)
    mr1 = micro_round(T, round_id=0, budget=max(0, remaining // 2))
    if mr1:
      room = CAP - len(T)
      if len(mr1) > room:
        mr1 = mr1[:room]
      T.extend(mr1)

    remaining = CAP - len(T)
    mr2 = micro_round(T, round_id=1, budget=max(0, remaining))
    if mr2:
      room = CAP - len(T)
      if len(mr2) > room:
        mr2 = mr2[:room]
      T.extend(mr2)

    # Micro-phase C: deterministic four-window augmentation (CAP-guarded)
    if len(T) < CAP - 8:
      def window_phase(current_T, budget, iter_id=0):
        if budget <= 0 or not current_T:
          return []
        glo = min(l for l, r in current_T)
        ghi = max(r for l, r in current_T)
        G = max(1, ghi - glo)

        # Thin, evenly spaced seed to limit omega growth
        seed_sz = max(8, min(32, budget // 4))
        U = thin_seed(current_T, seed_sz)
        if not U:
          return []
        ulo = min(l for l, r in U)

        # Four interior windows to avoid end-stack cliques
        window_fracs = [(0.15, 0.25), (0.32, 0.42), (0.58, 0.68), (0.82, 0.92)]
        blocks = []
        for (fa, fb) in window_fracs:
          win_lo = glo + int(round(fa * G))
          base = win_lo - ulo
          block = [(l + base, r + base) for (l, r) in U]
          # small deterministic reversal to break symmetry
          if (((int(fa * 100)) // 5 + iter_id) % 2) == 1:
            block = list(reversed(block))
          blocks.append(block)

        # Interleave the window blocks
        micro = []
        maxlen = max(len(b) for b in blocks)
        order = list(range(len(blocks)))
        if iter_id % 2 == 1:
          order.reverse()
        for i in range(maxlen):
          for idx in order:
            blk = blocks[idx]
            if i < len(blk):
              micro.append(blk[i])

        # Fractional-span connectors across windows
        micro_connectors = [
          (glo + int(round(0.18 * G)), glo + int(round(0.36 * G))),
          (glo + int(round(0.40 * G)), glo + int(round(0.62 * G))),
          (glo + int(round(0.66 * G)), glo + int(round(0.90 * G))),
          (glo + int(round(0.24 * G)), glo + int(round(0.84 * G))),  # long cross
        ]
        for a, b in micro_connectors:
          if b > a:
            micro.append((a, b))

        if len(micro) > budget:
          micro = micro[:budget]
        return micro

      remaining = CAP - len(T)
      microC = window_phase(T, budget=min(196, remaining), iter_id=2)
      if microC:
        room = CAP - len(T)
        if len(microC) > room:
          microC = microC[:room]
        T.extend(microC)

  return T

  # return [  # Figure 3, OPT=2, FF=4
  #   (2,3),
  #   (6,7),
  #   (10,11),
  #   (14,15),
  #   (1,5),
  #   (12,16),
  #   (4,9),
  #   (8,13),
  # ]

# EVOLVE-BLOCK-END
=======
def construct_intervals():
  """
  Construct a sequence of intervals of real line,
  in the order in which they are presented to FirstFit,
  so that it maximizes the number of colors used by FirstFit
  divided by the maximum number of intervals that cover a single point

  The initial implementation uses the construction from
  Figure 4 in https://arxiv.org/abs/1506.00192

  Returns:
    intervals: list of tuples, each tuple (l, r) represents an open interval from l to r
  """

  # Capacity guard to keep total intervals < 10000
  CAP = 9800

  # Expand the template bank to 6 templates to diversify translations across rounds
  template_bank = [
    (2, 6, 10, 14),  # classic KT
    (1, 5, 9, 13),   # left-shifted
    (3, 7, 11, 15),  # right-shifted
    (4, 8, 12, 16),  # stretched-right
    (2, 5, 11, 14),  # mixed
    (1, 6, 10, 15),  # alternate coupling
  ]

  T = [(0, 1)]
  for round_idx in range(6):
    starts = template_bank[round_idx % len(template_bank)]
    lo = min(l for l, r in T)
    hi = max(r for l, r in T)
    delta = hi - lo if hi > lo else 1
    # build translated blocks
    blocks = []
    for start in starts:
      blocks.append([(delta * start + l - lo, delta * start + r - lo) for l, r in T])
    S = []
    # Interleave more diversely: use a 3-round cadence and vary block order deterministically
    if round_idx % 3 == 0:
      maxlen = max(len(b) for b in blocks)
      # derive a deterministic order based on round index to break repeated symmetries
      order = list(range(len(blocks)))
      # rotate order by round_idx to vary which blocks are prioritized
      rot = round_idx % len(order)
      order = order[rot:] + order[:rot]
      for i in range(maxlen):
        for idx in order:
          blk = blocks[idx]
          if i < len(blk):
            S.append(blk[i])
    else:
      # occasionally reverse the block sequence to change relative arrivals
      if (round_idx % 3) == 2:
        for blk in reversed(blocks):
          S.extend(blk)
      else:
        for blk in blocks:
          S.extend(blk)
    # connectors based on the active starts (kept but shifted slightly to mix phases)
    s0, s1, s2, s3 = starts[0], starts[1], starts[2], starts[3]
    connectors = [
      (delta * (s0 - 1), delta * (s1 - 1)),  # left cap
      (delta * (s2 + 2), delta * (s3 + 2)),  # right cap
      (delta * (s0 + 2), delta * (s2 - 1)),  # cross 1
      (delta * (s1 + 2), delta * (s3 - 1)),  # cross 2
    ]
    for a, b in connectors:
      S.append((a, b))
    T = S

  # After spine: deterministic long-range connector pass to couple distant color classes.
  # This is capacity-guarded and small (doesn't increase omega much but mixes colors).
  if len(T) < CAP - 8:
    lo = min(l for l, r in T)
    hi = max(r for l, r in T)
    span = max(1, hi - lo)
    # place a handful of scaled connectors at fractional positions across the span
    long_connectors = []
    fracs = [0.05, 0.22, 0.40, 0.58, 0.76, 0.90]
    # connect each frac to a later fraction to create long overlaps
    for i in range(len(fracs) - 1):
      a = lo + int(round(fracs[i] * span))
      b = lo + int(round(fracs[i + 2 if i + 2 < len(fracs) else -1] * span))
      if b <= a:
        b = a + max(1, span // 100)
      long_connectors.append((a, b))
    # Add one very long connector stretching across central region
    mid_a = lo + int(round(0.12 * span))
    mid_b = lo + int(round(0.88 * span))
    if mid_b > mid_a:
      long_connectors.append((mid_a, mid_b))

    # Append connectors without exceeding CAP
    room = CAP - len(T)
    for conn in long_connectors:
      if room <= 0:
        break
      T.append(conn)
      room -= 1

  # Stage 2: Two delta2-driven micro extension rounds (thin sampling; four-start translations).
  # Skip if near capacity.
  if len(T) < CAP - 16:
    def thin_seed(current_T, max_seed):
      n = len(current_T)
      if n == 0 or max_seed <= 0:
        return []
      step = max(1, n // max_seed)
      return current_T[::step][:max_seed]

    def micro_round(current_T, round_id, budget):
      if budget <= 0 or not current_T:
        return []
      glo = min(l for l, r in current_T)
      ghi = max(r for l, r in current_T)
      G = max(1, ghi - glo)
      # Use half-scale to avoid expanding the global span too aggressively
      delta2 = max(1, G // 2)

      # Thin seed: bounded and deterministic size to respect budget
      per_block_target = max(8, min(64, budget // 12))
      U = thin_seed(current_T, per_block_target)
      if not U:
        return []

      # Build four translated blocks using the same 4-start template,
      # with deterministic parity-based internal reversal
      blocks = []
      ulo = min(l for l, r in U)
      s0, s1, s2, s3 = template_bank[0]
      for s in (s0, s1, s2, s3):
        base = s * delta2 - ulo
        block = [(l + base, r + base) for (l, r) in U]
        if ((s // 2) % 2) == (round_id % 2):
          block = list(reversed(block))
        blocks.append(block)

      micro = []
      # Parity-based interleaving across blocks
      maxlen = max(len(b) for b in blocks)
      if round_id % 2 == 0:
        for i in range(maxlen):
          for blk in blocks:
            if i < len(blk):
              micro.append(blk[i])
      else:
        for i in range(maxlen):
          for blk in reversed(blocks):
            if i < len(blk):
              micro.append(blk[i])

      # Deterministic connectors at delta2 scale, including a longer cross3
      connectors = [
        ((s0 - 1) * delta2 + glo, (s1 - 1) * delta2 + glo),  # left cap
        ((s2 + 2) * delta2 + glo, (s3 + 2) * delta2 + glo),  # right cap
        ((s0 + 2) * delta2 + glo, (s2 - 1) * delta2 + glo),  # cross 1
        ((s1 + 2) * delta2 + glo, (s3 - 1) * delta2 + glo),  # cross 2
        ((s0 + 3) * delta2 + glo, (s3 + 3) * delta2 + glo),  # cross3 (long range)
      ]
      micro.extend(connectors)

      # Sparse micro caps to press FirstFit locally without raising omega much
      cap1 = (glo + (delta2 // 4), glo + int(1.8 * delta2))
      cap2 = (glo + int(0.9 * delta2), glo + int(2.6 * delta2))
      mid = glo + G // 2
      cap3 = (mid - max(1, delta2 // 8), mid + max(1, delta2 // 8))
      for cap in (cap1, cap2, cap3):
        if cap[1] > cap[0]:
          micro.append(cap)

      # Enforce budget
      if len(micro) > budget:
        micro = micro[:budget]
      return micro

    remaining = CAP - len(T)
    mr1 = micro_round(T, round_id=0, budget=max(0, remaining // 2))
    if mr1:
      room = CAP - len(T)
      if len(mr1) > room:
        mr1 = mr1[:room]
      T.extend(mr1)

    remaining = CAP - len(T)
    mr2 = micro_round(T, round_id=1, budget=max(0, remaining))
    if mr2:
      room = CAP - len(T)
      if len(mr2) > room:
        mr2 = mr2[:room]
      T.extend(mr2)

    # Micro-phase C: deterministic four-window augmentation (CAP-guarded)
    if len(T) < CAP - 8:
      def window_phase(current_T, budget, iter_id=0):
        if budget <= 0 or not current_T:
          return []
        glo = min(l for l, r in current_T)
        ghi = max(r for l, r in current_T)
        G = max(1, ghi - glo)

        # Thin, evenly spaced seed to limit omega growth
        seed_sz = max(8, min(32, budget // 4))
        U = thin_seed(current_T, seed_sz)
        if not U:
          return []
        ulo = min(l for l, r in U)

        # Four interior windows to avoid end-stack cliques
        window_fracs = [(0.15, 0.25), (0.32, 0.42), (0.58, 0.68), (0.82, 0.92)]
        blocks = []
        for (fa, fb) in window_fracs:
          win_lo = glo + int(round(fa * G))
          base = win_lo - ulo
          block = [(l + base, r + base) for (l, r) in U]
          # small deterministic reversal to break symmetry
          if (((int(fa * 100)) // 5 + iter_id) % 2) == 1:
            block = list(reversed(block))
          blocks.append(block)

        # Interleave the window blocks
        micro = []
        maxlen = max(len(b) for b in blocks)
        order = list(range(len(blocks)))
        if iter_id % 2 == 1:
          order.reverse()
        for i in range(maxlen):
          for idx in order:
            blk = blocks[idx]
            if i < len(blk):
              micro.append(blk[i])

        # Fractional-span connectors across windows
        micro_connectors = [
          (glo + int(round(0.18 * G)), glo + int(round(0.36 * G))),
          (glo + int(round(0.40 * G)), glo + int(round(0.62 * G))),
          (glo + int(round(0.66 * G)), glo + int(round(0.90 * G))),
          (glo + int(round(0.24 * G)), glo + int(round(0.84 * G))),  # long cross
        ]
        for a, b in micro_connectors:
          if b > a:
            micro.append((a, b))

        if len(micro) > budget:
          micro = micro[:budget]
        return micro

      remaining = CAP - len(T)
      microC = window_phase(T, budget=min(196, remaining), iter_id=2)
      if microC:
        room = CAP - len(T)
        if len(microC) > room:
          microC = microC[:room]
        T.extend(microC)

  return T

  # return [  # Figure 3, OPT=2, FF=4
  #   (2,3),
  #   (6,7),
  #   (10,11),
  #   (14,15),
  #   (1,5),
  #   (12,16),
  #   (4,9),
  #   (8,13),
  # ]

# EVOLVE-BLOCK-END
>>>>>>> REPLACE
</DIFF>