# EVOLVE-BLOCK-START

def construct_intervals(rounds=3,
                        seed_lo=0.0,
                        seed_scale=1.0,
                        rotate_starts=True,
                        reverse_block_parity=True,
                        interleave_blocks=True,
                        phase2_micro=True):
    """
    Rotating multiscale wave construction.

    Same interface as the original program. Returns a list of open intervals
    (l, r) in the presentation order to FirstFit.
    """

    # Safety cap to avoid producing too many intervals
    MAX_INTERVALS = 9000

    # --- Seed spine: four disjoint unit intervals to create early color diversity ---
    T = [
        (seed_lo + 0.0 * seed_scale, seed_lo + 1.0 * seed_scale),
        (seed_lo + 2.0 * seed_scale, seed_lo + 3.0 * seed_scale),
        (seed_lo + 4.0 * seed_scale, seed_lo + 5.0 * seed_scale),
        (seed_lo + 6.0 * seed_scale, seed_lo + 7.0 * seed_scale)
    ]

    # --- Rotating start patterns (deterministic rotation) ---
    start_patterns = [
        (2, 6, 10, 14),
        (1, 5, 9, 13),
        (3, 7, 11, 15),
        (2, 4, 8, 12),
    ]

    # --- Template bank (4-interval connectors) ---
    template_bank = [
        ((1.0, 5.0), (12.0, 16.0), (4.0, 9.0), (8.0, 13.0)),
        ((0.5, 4.5), (11.0, 15.0), (3.5, 8.5), (7.0, 12.0)),
        ((1.0, 4.0), (6.0, 9.0), (3.0, 7.0), (9.0, 13.0)),
        ((2.0, 6.0), (7.0, 11.0), (0.0, 3.0), (10.0, 14.0))
    ]

    # knobs controlling micro behavior
    bridge_frac = 0.42   # where bridges sit inside a block
    bridge_len_frac = 0.06
    micro_caps = (0.22, 0.50, 0.78)

    # Helper: interleave blocks in round-robin
    def interleave_block_lists(blocks, round_idx):
        if not interleave_blocks or len(blocks) == 1:
            # concatenate
            res = []
            for b in blocks:
                res.extend(b)
            return res

        maxlen = max(len(b) for b in blocks)
        # change visitation order every round to vary arrival ordering
        order = list(range(len(blocks)))
        if round_idx % 3 == 1:
            order = order[::-1]
        elif round_idx % 3 == 2:
            order = order[1:] + order[:1]
        res = []
        for i in range(maxlen):
            for idx in order:
                blk = blocks[idx]
                if i < len(blk):
                    res.append(blk[i])
        return res

    # Main multiscale rounds
    for round_idx in range(max(1, int(rounds))):
        # Bounds and scale for this round
        lo = min(l for l, r in T)
        hi = max(r for l, r in T)
        span = hi - lo if hi > lo else 1.0

        # choose starts and template deterministically
        starts = list(start_patterns[round_idx % len(start_patterns)]) if rotate_starts else list(start_patterns[0])
        template = template_bank[round_idx % len(template_bank)]

        # optionally drop to 3-start variant some rounds (deterministic)
        if round_idx % 2 == 0:
            starts = starts[:3]

        # Build blocks (each block is a translated clone of T)
        blocks = []
        for bi, s in enumerate(starts):
            # alternate reversal parity
            if reverse_block_parity and ((round_idx + bi) % 2 == 1):
                base = list(reversed(T))
            else:
                base = T
            shift = span * s - lo
            block = [(l + shift, r + shift) for (l, r) in base]
            blocks.append(block)

        # Interleave block lists to force many active colors
        S = interleave_block_lists(blocks, round_idx)

        # Add short interior bridges between adjacent starts to couple colors across blocks
        for idx in range(len(starts) - 1):
            s = starts[idx]
            nxt = starts[idx + 1]
            b_lo = span * (s + bridge_frac) - lo
            b_hi = b_lo + max(bridge_len_frac * span, 0.18)
            # place bridges so they sit in the interior of both blocks' translated regions
            S.append((b_lo, b_hi))

        # Add the template gadget at global scale (keeps omega modest but pressures FF)
        for (a, b) in template:
            S.append((span * a, span * b))

        # Add a small "micro" gadget placed inside the middle block to couple colors across layers
        mid = starts[len(starts) // 2]
        micro_scale = 0.18
        for (a, b) in template:
            S.append((span * (mid + micro_scale * a), span * (mid + micro_scale * b)))

        # Add short sparse caps between block starts â€” structured so they don't create huge cliques
        max_start = max(starts) if starts else 1
        step = max(2, int(max(1, max_start // 3)))
        for j in range(2, max_start, step):
            a = span * (j - 0.35) - lo
            b = span * (j + 0.55) - lo
            # shorten slightly
            S.append((a + 0.01 * span, b - 0.01 * span))

        # Finalize T for next round
        T = S

        # Safety: abort if too many intervals
        if len(T) > MAX_INTERVALS:
            # truncate to most recent MAX_INTERVALS items deterministically
            T = T[-MAX_INTERVALS:]
            break

    # Phase 2: denser, smaller-delta coupling rounds (a short fine phase)
    if phase2_micro:
        lo = min(l for l, r in T)
        hi = max(r for l, r in T)
        delta = hi - lo if hi > lo else 1.0
        delta2 = max(1.0, delta / 4.0)
        # small cycle of starts for phase 2
        fine_starts = (1, 4, 7)
        blocks = []
        for bi, s in enumerate(fine_starts):
            # scale down the large T content into denser clones
            scale_factor = delta2 / max(1.0, delta)
            if reverse_block_parity and (bi % 2 == 1):
                base = list(reversed(T))
            else:
                base = T
            shift = delta2 * s - lo
            block = [(l * scale_factor + shift, r * scale_factor + shift) for (l, r) in base]
            blocks.append(block)
        # interleave these fine blocks
        S = interleave_block_lists(blocks, round_idx + 1)
        # add small fine bridges and a cap coupler
        for idx in range(len(fine_starts) - 1):
            st = fine_starts[idx]
            b_lo = delta2 * (st + 0.28)
            b_hi = b_lo + max(0.03 * delta2, 0.12)
            S.append((b_lo, b_hi))
        S.append((delta2 * (fine_starts[0] + 0.35), delta2 * (fine_starts[-1] - 0.35)))
        T = S

    # Append a few micro caps presented last to hit many active colors late
    if phase2_micro:
        lo = min(l for l, r in T)
        hi = max(r for l, r in T)
        span = hi - lo if hi > lo else 1.0
        micros = []
        for frac in micro_caps:
            center = lo + frac * span
            w = max(0.04 * span, 0.3)
            micros.append((center - 0.5 * w, center + 0.5 * w))
        # add micros near the end (they are presented last)
        T.extend(micros)

    # Final safety trim & normalization: shift so minimum left endpoint >= 0
    if T:
        min_l = min(l for l, r in T)
        if min_l < 0:
            T = [(l - min_l, r - min_l) for (l, r) in T]

    # If still too many, keep a deterministic suffix to maintain recent pressure
    if len(T) > MAX_INTERVALS:
        T = T[-MAX_INTERVALS:]

    # Return intervals as float tuples (open intervals)
    return T

# EVOLVE-BLOCK-END

def run_experiment(**kwargs):
    """Main called by evaluator"""
    return construct_intervals(**kwargs)