--- a/original.py
+++ b/original.py
@@ -1,160 +1,157 @@
 # EVOLVE-BLOCK-START
 
 def construct_intervals(max_intervals=9800,
                         depth=6,
                         rotate_starts=True,
                         reverse_block_parity=False,
                         interleave_blocks=False,
                         micro_phase=False):
   """
   Rotated four-block Kiersteadâ€“Trotter style expansion with adaptive depth cap
-  and optional micro-phase gadgets.
+  and an optional safeguarded micro-phase of sparse caps.
 
   Returns a list of (l, r) integer tuples (open intervals) in the order they
   should be presented to FirstFit.
 
   Parameters:
     max_intervals (int): hard cap on the total number of intervals produced.
     depth (int): nominal recursion depth (will be adaptively capped to respect max_intervals).
     rotate_starts (bool): rotate the four translated starts across rounds to disrupt repeating overlap patterns.
     reverse_block_parity (bool): reverse the order of T for every odd block within a round to mix color usage.
     interleave_blocks (bool): interleave blocks round-robin to maximize color mixing.
-    micro_phase (bool): append a small micro-phase at the end to sprinkle sparse long caps.
+    micro_phase (bool): append a very small safeguarded micro-phase at the end with sparse long caps.
 
   Returns:
     intervals: list of tuples, each tuple (l, r) represents an open interval from l to r
   """
+
+  # Capacity guard to keep total < max_intervals
+  CAP = int(max_intervals)
+
   # Deterministic four-pattern cycle (four starts per round)
   start_patterns = [
     (2, 6, 10, 14),  # classic 4-wave
     (1, 5, 9, 13),   # left-shifted
     (3, 7, 11, 15),  # right-shifted
     (2, 4, 8, 12),   # compressed variant
   ]
 
   # Seed with a single unit interval; keep small to allow many rounds within budget
   T = [(0, 1)]
 
-  # Adaptive depth cap given max_intervals (prefer six rounds if budget allows)
-  depth = max(6, int(depth))
-  size = 1
+  # Predictive size accounting to cap the number of full rounds.
+  # KT growth per round: size -> 4*size + 4 (four translated copies + four connectors)
+  def round_next_size(sz):
+    return 4 * sz + 4
+
+  depth = max(0, int(depth))
+  size = len(T)
   allowed = 0
-  # Each round grows size via size -> 4*size + 4 (four translated copies + four connectors)
-  while allowed < depth:
-    next_size = size * 4 + 4
-    if next_size > max_intervals:
+  for _ in range(depth):
+    nxt = round_next_size(size)
+    if nxt > CAP:
       break
-    size = next_size
+    size = nxt
     allowed += 1
-  depth = allowed if allowed > 0 else 0
+  depth = allowed
 
-  for round_idx in range(depth):
-    lo = min(l for l, r in T)
-    hi = max(r for l, r in T)
+  def apply_round(current_T, starts, do_interleave):
+    # Compute span and delta (integers)
+    lo = min(l for l, r in current_T)
+    hi = max(r for l, r in current_T)
     delta = hi - lo
     if delta <= 0:
       delta = 1
 
-    starts = start_patterns[round_idx % len(start_patterns)] if rotate_starts else start_patterns[0]
-
-    # Build four translated blocks (with optional reversal to mix colors)
+    # Build translated blocks
     blocks = []
     for b_idx, s in enumerate(starts):
-      block_src = T[::-1] if (reverse_block_parity and (b_idx % 2 == 1)) else T
+      # Optional reverse parity for odd-indexed block to disrupt symmetry
+      src = current_T[::-1] if (reverse_block_parity and (b_idx % 2 == 1)) else current_T
       base = s * delta - lo
-      block = [(l + base, r + base) for (l, r) in block_src]
+      block = [(l + base, r + base) for (l, r) in src]
       blocks.append(block)
 
-    # Interleave blocks round-robin to maximize mixing of colors
+    # Combine blocks: interleave or sequential
     S = []
-    if interleave_blocks:
+    if do_interleave:
       maxlen = max(len(b) for b in blocks)
       order = list(range(len(blocks)))
-      if round_idx % 2 == 1:
-        order = order[::-1]
-      krot = round_idx % len(order)
-      order = order[krot:] + order[:krot]
+      # small deterministic rotation by round parity for variety
       for i in range(maxlen):
         for idx in order:
           blk = blocks[idx]
           if i < len(blk):
             S.append(blk[i])
     else:
       for blk in blocks:
         S.extend(blk)
 
-    # Deterministic connectors to propagate colors while avoiding large cliques
+    # Classic KT connectors based on the first four starts
     s0, s1, s2, s3 = starts[:4]
     connectors = [
       ((s0 - 1) * delta, (s1 - 1) * delta),  # left cap
       ((s2 + 2) * delta, (s3 + 2) * delta),  # right cap
       ((s0 + 2) * delta, (s2 - 1) * delta),  # cross 1
       ((s1 + 2) * delta, (s3 - 1) * delta),  # cross 2
     ]
-    for a, b in connectors:
-      S.append((a, b))
+    S.extend(connectors)
+    return S
 
-    T = S
+  # Main KT rounds
+  for round_idx in range(depth):
+    if not T:
+      break
+    # Choose starts (rotate if requested)
+    starts = start_patterns[round_idx % len(start_patterns)] if rotate_starts else start_patterns[0]
+    # Apply round; by default keep sequential blocks which has shown strong performance
+    T = apply_round(T, starts, do_interleave=bool(interleave_blocks))
 
-  # Optional micro-phase: sprinkle a few sparse long-range caps near the end
-  if micro_phase and depth < 6 and len(T) + 8 <= max_intervals:
+    # Capacity guard mid-process
+    if len(T) > CAP:
+      T = T[:CAP]
+      break
+
+  # Optional safeguarded micro-phase: add a tiny number of long caps if requested
+  if micro_phase and T and len(T) + 2 <= CAP:
     lo = min(l for l, r in T)
     hi = max(r for l, r in T)
-    delta = max(1, hi - lo)
-    d2 = max(1, delta // 4)
-    micro = [
+    span = max(1, hi - lo)
+    d2 = max(1, span // 3)
+    # Two sparse caps away from densest core, inspired by the safer scaffold
+    micro_caps = [
       (lo + 1 * d2, lo + 5 * d2),
       (hi - 6 * d2, hi - 2 * d2),
-      (lo + 3 * d2, lo + 8 * d2),
-      (hi - 8 * d2, hi - 3 * d2),
     ]
-    for i, it in enumerate(micro):
-      insert_pos = len(T) - (i * 2 + 1)
-      if insert_pos < 0:
-        T.append(it)
-      else:
-        T.insert(insert_pos, it)
-
-    # Two-phase micro expansion: two mini-rounds at finer scale to boost FF pressure
-    for mini in range(2):
-      # recompute bounds and sub-delta
-      lo2 = min(l for l, r in T)
-      hi2 = max(r for l, r in T)
-      delta2 = max(1, (hi2 - lo2) // 2)
-      # translate two mini-block copies and add two mini-connectors
-      mini_blocks = []
-      for s in (1, 3):
-        base2 = s * delta2 - lo2
-        mini_blocks += [(l + base2, r + base2) for (l, r) in T[:min(len(T), d2)]]
-      # mini-connectors
-      mini_conn = [
-        (lo2 + delta2, lo2 + 2 * delta2),
-        (hi2 - 3 * delta2, hi2 - delta2),
-      ]
-      T = mini_blocks + T + mini_conn
+    # Insert near the end to influence late FF assignments without densifying cliques
+    for i, itv in enumerate(micro_caps):
+      pos = max(0, len(T) - 1 - i)
+      T.insert(pos, itv)
 
   # Normalize to non-negative integers
   if not T:
     return []
   min_l = min(l for l, r in T)
   if min_l < 0:
-    T = [(l - min_l, r - min_l) for l, r in T]
+    T = [(l - min_l, r - min_l) for (l, r) in T]
 
+  # Ensure integer open intervals and monotone right > left
   intervals = []
   for (l, r) in T:
-    li = int(round(l))
-    ri = int(round(r))
+    li = int(l)
+    ri = int(r)
     if ri <= li:
       ri = li + 1
     intervals.append((li, ri))
 
-  if len(intervals) > max_intervals:
-    intervals = intervals[:max_intervals]
+  # Final capacity trim
+  if len(intervals) > CAP:
+    intervals = intervals[:CAP]
 
   return intervals
 
 # EVOLVE-BLOCK-END
 
 def run_experiment(**kwargs):
   """Main called by evaluator"""
   return construct_intervals()