<NAME>phase2_delta_coupling</NAME>

<DESCRIPTION>
Introduce a lightweight, deterministic phase-2 delta-coupled layer to each expansion round. After constructing the four translated blocks for a given round and appending the standard four connectors, we optionally append a second set of four translated blocks generated from the original previous-block template but scaled by a smaller delta (delta2 = max(1, delta // 3)) and placed at starts (2, 6, 10, 14). This injects additional cross-round pressure on FirstFit, potentially increasing the number of colors used without blowing up the omega bound, thereby aiming to improve the combined score. The phase-2 layer is controlled by a new phase2 flag (default enabled) and guarded by a cap check to ensure we stay within max_intervals.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
def construct_intervals(max_intervals=9800,
                        depth=6,
                        rotate_starts=True,
                        reverse_block_parity=True,   # kept for interface; not used in the classic recipe
                        interleave_blocks=False,     # default to sequential, which empirically boosts FF
                        micro_phase=True):
    """
    Classic four-start, six-round recursive construction with 4 connectors per round.
    This reliably yields a high FF/omega ratio under the 10k-interval budget.

    Parameters:
      max_intervals (int): overall cap on number of intervals.
      depth (int): requested rounds (we will try to reach at least 6 if budget allows).
      rotate_starts (bool): cycle through deterministic four-pattern start templates.
      reverse_block_parity (bool): retained for compatibility (unused).
      interleave_blocks (bool): retained for compatibility (unused; sequential is used).
      micro_phase (bool): optional post-phase small caps (skipped if 6 rounds are used).

    Returns:
      intervals: list[(l, r)] of open intervals with integer endpoints, in arrival order.
    """
    # Deterministic four-pattern cycle (ascending starts)
    start_patterns = [
        (2, 6, 10, 14),  # classic 4-wave
        (1, 5, 9, 13),   # left-shifted
        (3, 7, 11, 15),  # right-shifted
        (2, 4, 8, 12),   # compressed variant
    ]

    # We prefer six rounds if budget allows, regardless of 'depth' (while respecting the cap).
    target_rounds = max(6, int(depth))

    # Compute allowed rounds under the cap for the 4x + 4 recurrence
    rounds_allowed, _ = _rounds_allowed_under_cap(
        max_intervals=max_intervals,
        base_size=1,
        per_round_copies=4,
        per_round_connectors=4,
        target_rounds=target_rounds
    )
    # If for some reason we can't fit 1 round (extremely small cap), bail out early
    if rounds_allowed <= 0:
        return [(0, 1)]

    # Seed: a single unit interval; this keeps omega small and enables many rounds within budget
    T = [(0, 1)]

    # Main expansion
    for round_idx in range(rounds_allowed):
        lo = min(l for l, r in T)
        hi = max(r for l, r in T)
        delta = hi - lo
        if delta <= 0:
            delta = 1

        starts = start_patterns[round_idx % len(start_patterns)] if rotate_starts else start_patterns[0]

        # Build four translated blocks in sequential order (no interleaving)
        S = _build_translated_blocks(T, delta, lo, starts)

        # Append the four deterministic connectors
        _append_connectors(S, delta, starts)

        T = S

    # Optional micro-phase: only if we did not reach 6 rounds
    # (The 6-round construction already achieves a strong ratio; extra caps may disrupt it.)
    if micro_phase and rounds_allowed < 6:
        lo = min(l for l, r in T)
        hi = max(r for l, r in T)
        delta = max(1, hi - lo)
        d2 = max(1, delta // 4)
        micro = [
            (lo + 1 * d2, lo + 5 * d2),
            (hi - 6 * d2, hi - 2 * d2),
            (lo + 3 * d2, lo + 8 * d2),
            (hi - 8 * d2, hi - 3 * d2),
        ]
        # Insert these near the end to touch many active colors
        for i, it in enumerate(micro):
            pos = len(T) - (2 * i + 1)
            if 0 <= pos < len(T):
                T.insert(pos, it)
            else:
                T.append(it)

    # Normalize and truncate if needed
    intervals = _normalize_non_negative_ints(T, cap=max_intervals)
    return intervals
=======
def construct_intervals(max_intervals=9800,
                        depth=6,
                        rotate_starts=True,
                        reverse_block_parity=True,   # kept for interface; not used in the classic recipe
                        interleave_blocks=False,     # default to sequential, which empirically boosts FF
                        micro_phase=True,
                        phase2=True):
    """
    Classic four-start, six-round recursive construction with 4 connectors per round.
    This reliably yields a high FF/omega ratio under the 10k-interval budget.
    Additionally, when phase2 is True, a small phase-2 delta-coupled layer is appended each round
    to increase FirstFit pressure without significantly increasing omega.

    Parameters:
      max_intervals (int): overall cap on number of intervals.
      depth (int): requested rounds (we will try to reach at least 6 if budget allows).
      rotate_starts (bool): cycle through deterministic four-pattern start templates.
      reverse_block_parity (bool): retained for compatibility (unused).
      interleave_blocks (bool): retained for compatibility (unused; sequential is used).
      micro_phase (bool): optional post-phase small caps (skipped if 6 rounds are used).
      phase2 (bool): enable or disable the cheap phase-2 delta-coupled layer.

    Returns:
      intervals: list[(l, r)] of open intervals with integer endpoints, in arrival order.
    """
    # Deterministic four-pattern cycle (ascending starts)
    start_patterns = [
        (2, 6, 10, 14),  # classic 4-wave
        (1, 5, 9, 13),   # left-shifted
        (3, 7, 11, 15),  # right-shifted
        (2, 4, 8, 12),   # compressed variant
    ]

    # We prefer six rounds if budget allows, regardless of 'depth' (while respecting the cap).
    target_rounds = max(6, int(depth))

    # Compute allowed rounds under the cap for the 4x + 4 recurrence
    rounds_allowed, _ = _rounds_allowed_under_cap(
        max_intervals=max_intervals,
        base_size=1,
        per_round_copies=4,
        per_round_connectors=4,
        target_rounds=target_rounds
    )
    # If for some reason we can't fit 1 round (extremely small cap), bail out early
    if rounds_allowed <= 0:
        return [(0, 1)]

    # Seed: a single unit interval; this keeps omega small and enables many rounds within budget
    T = [(0, 1)]

    # Main expansion
    for round_idx in range(rounds_allowed):
        lo = min(l for l, r in T)
        hi = max(r for l, r in T)
        delta = hi - lo
        if delta <= 0:
            delta = 1

        starts = start_patterns[round_idx % len(start_patterns)] if rotate_starts else start_patterns[0]

        # Build four translated blocks in sequential order (no interleaving)
        original_T = T  # snapshot for potential phase2
        S = _build_translated_blocks(original_T, delta, lo, starts)

        # Append the four deterministic connectors
        _append_connectors(S, delta, starts)

        # Optional Phase-2 delta coupling: inject four translated copies of the original T
        if phase2:
            delta2 = max(1, delta // 3)
            phase2_blocks = _build_translated_blocks(original_T, delta2, lo, (2, 6, 10, 14))
            # Ensure we do not exceed the cap
            if len(S) + len(phase2_blocks) <= max_intervals:
                S.extend(phase2_blocks)

        T = S

    # Optional micro-phase: only if we did not reach 6 rounds
    # (The 6-round construction already achieves a strong ratio; extra caps may disrupt it.)
    if micro_phase and rounds_allowed < 6:
        lo = min(l for l, r in T)
        hi = max(r for l, r in T)
        delta = max(1, hi - lo)
        d2 = max(1, delta // 4)
        micro = [
            (lo + 1 * d2, lo + 5 * d2),
            (hi - 6 * d2, hi - 2 * d2),
            (lo + 3 * d2, lo + 8 * d2),
            (hi - 8 * d2, hi - 3 * d2),
        ]
        # Insert these near the end to touch many active colors
        for i, it in enumerate(micro):
            pos = len(T) - (2 * i + 1)
            if 0 <= pos < len(T):
                T.insert(pos, it)
            else:
                T.append(it)

    # Normalize and truncate if needed
    intervals = _normalize_non_negative_ints(T, cap=max_intervals)
    return intervals
>>>>>>> REPLACE
</DIFF>