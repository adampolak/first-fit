--- a/original.py
+++ b/original.py
@@ -1,58 +1,83 @@
 # EVOLVE-BLOCK-START
 
 def construct_intervals():
-  """
-  Construct a sequence of intervals of real line,
-  in the order in which they are presented to FirstFit,
-  so that it maximizes the number of colors used by FirstFit
-  divided by the maximum number of intervals that cover a single point
+    """
+    Construct a deterministic sequence of open intervals in presentation order.
+    This version keeps the same multiplicative 4-branch recursion (so the
+    total count stays comparable to the strong prior examples) but
+    diversifies arrival order, clone order, and connector templates across
+    iterations to make FirstFit reuse less effective.
 
-  The initial implementation uses the construction from
-  Figure 4 in https://arxiv.org/abs/1506.00192
+    Returns:
+        intervals: list of tuples (l, r) representing open intervals.
+    """
+    # Target recursion depth (6 is a practical sweet spot: ~9556 intervals for
+    # the classic 4-branch + 4-connectors growth). Keep fixed for reproducibility.
+    depth = 6
 
-  Returns:
-    intervals: list of tuples, each tuple (l, r) represents an open interval from l to r
-  """
+    # Base seed
+    T = [(0.0, 1.0)]
 
-  # parameterize recursion depth and branching factor for stronger blow-up
-  depth = 4
-  branching = 7
-  T = [(0, 1)]
-  for _ in range(depth):
-    lo = min(l for l, r in T)
-    hi = max(r for l, r in T)
-    delta = hi - lo
-    S = []
-    # insert scaled copies at offsets [2,6,10,...] based on branching
-    starts = [2 + 4 * i for i in range(branching)]
-    for start in starts:
-      S += [(delta * start + l - lo, delta * start + r - lo) for l, r in T]
-    # adjacent connectors to propagate FirstFit colors between neighbors
-    for i in range(branching - 1):
-      a = delta * (1 + 4 * i)
-      b = delta * (5 + 4 * i)
-      S.append((a, b))
-    # cross connectors to couple nonâ€adjacent blocks without raising clique
-    for i in range(branching - 2):
-      a = delta * (4 + 4 * i)
-      b = delta * (9 + 4 * i)
-      S.append((a, b))
-    T = S
-  return T
+    # A cycle of 4 start-patterns (each has 4 block starts -> branching=4)
+    start_patterns = [
+        (2, 6, 10, 14),
+        (1, 5, 9, 13),
+        (3, 7, 11, 15),
+        (2, 4, 8, 12),
+    ]
 
-  # return [  # Figure 3, OPT=2, FF=4
-  #   (2,3),
-  #   (6,7),
-  #   (10,11),
-  #   (14,15),
-  #   (1,5),
-  #   (12,16),
-  #   (4,9),
-  #   (8,13),
-  # ]
+    # A small bank of 4-connector templates (each template adds exactly 4 intervals)
+    # We pick one per iteration to vary coupling without increasing per-iteration cost.
+    template_bank = [
+        ((1, 5), (12, 16), (4, 9), (8, 13)),   # classical gadget
+        ((0, 4), (5, 9), (2, 6), (7, 11)),
+        ((1, 4), (6, 9), (3, 7), (9, 13)),
+        ((2, 6), (7, 11), (0, 3), (10, 14)),
+    ]
+
+    for it in range(depth):
+        lo = min(l for l, r in T)
+        hi = max(r for l, r in T)
+        span = hi - lo
+
+        # pick a start pattern from the cycle
+        starts = list(start_patterns[it % len(start_patterns)])
+
+        # vary the order in which blocks are appended to S; this changes arrival order
+        if it % 3 == 0:
+            block_order = starts
+        elif it % 3 == 1:
+            block_order = list(reversed(starts))
+        else:
+            # rotate by 1 to alter interleaving
+            block_order = starts[1:] + starts[:1]
+
+        S = []
+        for idx, st in enumerate(block_order):
+            # alternate clone insertion order to break symmetry:
+            # sometimes append copies of T in forward order, sometimes reversed.
+            if (it + idx) % 2 == 0:
+                clone_order = T
+            else:
+                clone_order = list(reversed(T))
+
+            base_off = span * st - lo
+            for (l, r) in clone_order:
+                S.append((l + base_off, r + base_off))
+
+        # append exactly 4 connectors chosen from the template bank (keeps per-iteration
+        # additive cost constant so total size remains in the same growth family)
+        template = template_bank[it % len(template_bank)]
+        for (a, b) in template:
+            S.append((span * a, span * b))
+
+        # update for next iteration
+        T = S
+
+    return T
 
 # EVOLVE-BLOCK-END
 
 def run_experiment(**kwargs):
   """Main called by evaluator"""
   return construct_intervals()