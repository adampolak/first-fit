<NAME>
alternating_bridges_microcaps
</NAME>

<DESCRIPTION>
I introduce three targeted changes to increase FirstFit’s color usage while keeping the clique number small and the interval count modest:

1) Alternating block order with thin bridges:
- For each translated block, I alternate the inner order (T vs reversed(T)). This is a standard trick to hamper FirstFit’s color reuse across blocks.
- I add slim “bridges” between consecutive blocks that couple colors across waves without stacking many intervals at a single point (keeps omega controlled). The bridges start and end strictly inside the two blocks to avoid creating large local cliques at endpoints.

2) Embedded micro-gadget near the middle block:
- In addition to the global 4-interval gadget, I embed a scaled micro-copy inside the median block. This increases color pressure locally without significantly raising omega, and it strengthens coupling between blocks.

3) Sparse caps with deterministic spacing:
- I replace the prior ad-hoc extra caps with a sparse, deterministic set of caps spaced across the span. They lightly pressure FirstFit while avoiding dense overlaps.

I also slightly adjust the later-round starts to control the number of intervals (better combined score). Overall, these changes implement the “spine + waves + bridges + caps” heuristic and should improve the combined score by pushing FF colors up with limited growth in omega and interval count.

</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
def construct_intervals(rounds=2):
  """
  Construct a sequence of intervals of real line,
  in the order in which they are presented to FirstFit,
  so that it tends to maximize the number of colors used by FirstFit
  divided by the maximum number of intervals that cover a single point
  through a recursive wave construction.

  The construction generalizes the two-round pattern used in Figure 4 of
  https://arxiv.org/abs/1506.00192 to a multi-round recursive expansion.

  Returns:
    intervals: list of tuples, each tuple (l, r) represents an open interval from l to r
  """
  T = [(0, 1)]
  for round_idx in range(rounds):
    lo = min(l for l, r in T)
    hi = max(r for l, r in T)
    delta = hi - lo
    S = []
    # In earlier rounds we apply a compact set of shifts; in later rounds,
    # we widen the set of shifts to inject more waves and increase color usage.
    # Density-increasing starts: first round uses a core set, subsequent rounds add more starts
    if round_idx == 0:
      starts = [2, 4, 6, 8, 10, 12, 14, 16]
    else:
      starts = [2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 24, 28]
    for start in starts:
      S += [(delta * start + l - lo, delta * start + r - lo) for l, r in T]
    # additional local blocks to create overlapping waves without increasing omega too much
    S += [
      (delta * 1, delta * 5),
      (delta * 12, delta * 16),
      (delta * 4, delta * 9),
      (delta * 8, delta * 13),
      # extra caps to push color usage further without bloating omega
      (delta * 0.5, delta * 2.0),
      (delta * 14.0, delta * 15.0)
    ]
    T = S
  return T
=======
def construct_intervals(rounds=2):
  """
  Construct a sequence of intervals presented to FirstFit to push color usage
  while keeping the clique number small, using alternating block order,
  thin bridges, and an embedded micro-gadget.

  Inspired by recursive gadgets in https://arxiv.org/abs/1506.00192.
  """
  T = [(0, 1)]
  for round_idx in range(rounds):
    lo = min(l for l, r in T)
    hi = max(r for l, r in T)
    delta = hi - lo if hi > lo else 1.0
    S = []

    # Compact starts in early round; slightly sparser, offset pattern later to limit blow-up
    if round_idx == 0:
      starts = [2, 4, 6, 8, 10, 12, 14, 16]
    else:
      starts = [2, 4, 6, 8, 10, 12, 15, 18, 22, 26]

    # Alternating inner order and thin bridges between consecutive blocks
    for idx, start in enumerate(starts):
      base = T if (idx % 2 == 0) else list(reversed(T))
      S += [(delta * start + l - lo, delta * start + r - lo) for (l, r) in base]
      if idx + 1 < len(starts):
        nxt = starts[idx + 1]
        # bridge starts/ends well inside blocks to couple colors without spiking omega
        S.append((delta * (start + 0.6), delta * (nxt + 0.4)))

    # Core 4-interval gadget (global scale)
    gadget = [(1.0, 5.0), (12.0, 16.0), (4.0, 9.0), (8.0, 13.0)]
    S += [(delta * a, delta * b) for (a, b) in gadget]

    # Embedded micro-gadget near the median start to frustrate color reuse
    mid = starts[len(starts) // 2]
    micro_scale = 0.25
    S += [(delta * (mid + a * micro_scale), delta * (mid + b * micro_scale)) for (a, b) in gadget]

    # Sparse caps to add gentle pressure without increasing clique size much
    max_start = max(starts)
    step = max(3, max_start // 5)
    for j in range(2, max_start, step):
      S.append((delta * (j - 0.5), delta * (j + 1.2)))

    T = S
  return T
>>>>>>> REPLACE

</DIFF>