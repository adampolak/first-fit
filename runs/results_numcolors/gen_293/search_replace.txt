<NAME>
sprinkled_connectors_and_micro_interleave
</NAME>

<DESCRIPTION>
I propose to increase FirstFit pressure without increasing the clique number by strategically interleaving the “connector” intervals within the main KT spine blocks and within the micro-phases, instead of appending them in a single tail burst. This uses arrival-order engineering to make connectors interact earlier with already-occupied colors, which tends to raise FirstFit’s color usage while keeping omega unchanged.

Concretely:
- In the main six KT rounds, distribute the four classic connectors across the assembled block sequence at four evenly spaced positions rather than appending them at the end.
- In micro-phase B (delta-driven micro round), interleave its fractional-span connectors into the interleaved micro-block stream at quartile positions and also change the block interleave order to [0, 2, 1, 3] to break symmetry and couple colors across layers.
- In micro-phase C (pin-based micro round), interleave the cap-pins into the stream near even thirds rather than appending them, to better couple across windows without inflating omega.
- In micro-phase D, interleave its long-range connectors across the micro-block stream at spaced positions.

These are targeted, deterministic changes that do not alter the structural parameters (delta, starts, or counts) and remain CAP-safe. They aim to increase the competitive ratio beyond the 2.30 plateau observed, by increasing FF color conflicts earlier in the sequence while preserving the clique bound (still governed by the KT scaffolding and careful window placement).
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # connectors based on the active starts
    s0, s1, s2, s3 = starts
    connectors = [
      (delta * (s0 - 1), delta * (s1 - 1)),  # left cap
      (delta * (s2 + 2), delta * (s3 + 2)),  # right cap
      (delta * (s0 + 2), delta * (s2 - 1)),  # cross 1
      (delta * (s1 + 2), delta * (s3 - 1)),  # cross 2
    ]
    for a, b in connectors:
      S.append((a, b))
    T = S
=======
    # connectors based on the active starts
    s0, s1, s2, s3 = starts
    connectors = [
      (delta * (s0 - 1), delta * (s1 - 1)),  # left cap
      (delta * (s2 + 2), delta * (s3 + 2)),  # right cap
      (delta * (s0 + 2), delta * (s2 - 1)),  # cross 1
      (delta * (s1 + 2), delta * (s3 - 1)),  # cross 2
    ]
    # Sprinkle connectors inside S at spaced positions to increase FF coupling
    inj = [(a, b) for (a, b) in connectors if b > a]
    if inj:
      L = len(S)
      slots = sorted(set([max(0, min(L, L // 6)),
                          max(0, min(L, L // 2)),
                          max(0, min(L, (5 * L) // 6)),
                          max(0, min(L, L - 1))]))
      for k, pos in enumerate(slots):
        if k >= len(inj):
          break
        S.insert(min(pos + k, len(S)), inj[k])
      for extra in inj[len(slots):]:
        S.append(extra)
    T = S
>>>>>>> REPLACE
<<<<<<< SEARCH
      # Interleave the micro-blocks
      micro = []
      maxlen = max(len(b) for b in micro_blocks)
      for i in range(maxlen):
        for blk in micro_blocks:
          if i < len(blk):
            micro.append(blk[i])

      # Fractional-span connectors at the delta2 scale
      micro_connectors = [
        (glo + int(round(0.08 * G)), glo + int(round(0.30 * G))),
        (glo + int(round(0.60 * G)), glo + int(round(0.92 * G))),
        (glo + int(round(0.26 * G)), glo + int(round(0.56 * G))),
        (glo + int(round(0.44 * G)), glo + int(round(0.78 * G))),
      ]
      for a, b in micro_connectors:
        if b > a:
          micro.append((a, b))
=======
      # Interleave the micro-blocks with a nontrivial order to break symmetry
      micro = []
      maxlen = max(len(b) for b in micro_blocks)
      block_order = [0, 2, 1, 3]
      for i in range(maxlen):
        for idx in block_order:
          blk = micro_blocks[idx]
          if i < len(blk):
            micro.append(blk[i])

      # Fractional-span connectors at the delta2 scale, sprinkled inside the stream
      micro_connectors = [
        (glo + int(round(0.08 * G)), glo + int(round(0.30 * G))),
        (glo + int(round(0.60 * G)), glo + int(round(0.92 * G))),
        (glo + int(round(0.26 * G)), glo + int(round(0.56 * G))),
        (glo + int(round(0.44 * G)), glo + int(round(0.78 * G))),
      ]
      inj = [(a, b) for (a, b) in micro_connectors if b > a]
      if inj:
        Lm = len(micro)
        slots = sorted(set([max(0, min(Lm, Lm // 4)),
                            max(0, min(Lm, Lm // 2)),
                            max(0, min(Lm, (3 * Lm) // 4))]))
        for k, pos in enumerate(slots):
          if k >= len(inj):
            break
          micro.insert(min(pos + k, len(micro)), inj[k])
        for extra in inj[len(slots):]:
          micro.append(extra)
>>>>>>> REPLACE
<<<<<<< SEARCH
      # Very short cap-pins to tie windows without inflating omega
      caps2 = [
        (glo2 + int(round(0.09 * G2)), glo2 + int(round(0.09 * G2)) + eps),
        (glo2 + int(round(0.64 * G2)), glo2 + int(round(0.64 * G2)) + eps),
      ]
      for a, b in caps2:
        if b > a:
          micro2.append((a, b))
=======
      # Very short cap-pins to tie windows without inflating omega (sprinkled)
      caps2 = [
        (glo2 + int(round(0.09 * G2)), glo2 + int(round(0.09 * G2)) + eps),
        (glo2 + int(round(0.64 * G2)), glo2 + int(round(0.64 * G2)) + eps),
      ]
      inj2 = [(a, b) for (a, b) in caps2 if b > a]
      if inj2:
        L2 = len(micro2)
        slots2 = sorted(set([max(0, min(L2, L2 // 3)),
                             max(0, min(L2, (2 * L2) // 3))]))
        for k, pos in enumerate(slots2):
          if k >= len(inj2):
            break
          micro2.insert(min(pos + k, len(micro2)), inj2[k])
        for extra in inj2[len(slots2):]:
          micro2.append(extra)
>>>>>>> REPLACE
<<<<<<< SEARCH
      # Long-range, pairwise-disjoint connectors to avoid omega spikes
      connectors3 = [
        (glo3 + int(round(0.06 * G3)), glo3 + int(round(0.28 * G3))),
        (glo3 + int(round(0.41 * G3)), glo3 + int(round(0.59 * G3))),
        (glo3 + int(round(0.72 * G3)), glo3 + int(round(0.95 * G3))),
      ]
      for a, b in connectors3:
        if b > a:
          micro3.append((a, b))
=======
      # Long-range, pairwise-disjoint connectors to avoid omega spikes (sprinkled)
      connectors3 = [
        (glo3 + int(round(0.06 * G3)), glo3 + int(round(0.28 * G3))),
        (glo3 + int(round(0.41 * G3)), glo3 + int(round(0.59 * G3))),
        (glo3 + int(round(0.72 * G3)), glo3 + int(round(0.95 * G3))),
      ]
      inj3 = [(a, b) for (a, b) in connectors3 if b > a]
      if inj3:
        L3 = len(micro3)
        slots3 = sorted(set([max(0, min(L3, L3 // 5)),
                             max(0, min(L3, (2 * L3) // 5)),
                             max(0, min(L3, (4 * L3) // 5))]))
        for k, pos in enumerate(slots3):
          if k >= len(inj3):
            break
          micro3.insert(min(pos + k, len(micro3)), inj3[k])
        for extra in inj3[len(slots3):]:
          micro3.append(extra)
>>>>>>> REPLACE

</DIFF>