<NAME>
add_third_fine_micro_round_and_cross4
</NAME>

<DESCRIPTION>
Extend the micro‐phase by introducing a third “fine” micro round at quarter scale to add extra coupling late in the sequence, and generalize `micro_round` with a `scale_div` parameter and optional `starts_override`. Also add a “cross4” connector in micro rounds. These fine‐scale intervals overlap many active FirstFit colors without increasing the clique number, pushing FirstFit to consume additional colors.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    def micro_round(current_T, round_id, budget):
      if budget <= 0 or not current_T:
        return []
      glo = min(l for l, r in current_T)
      ghi = max(r for l, r in current_T)
      G = max(1, ghi - glo)
      # Use half-scale to avoid expanding the global span too aggressively
      delta2 = max(1, G // 2)

      # Thin seed: bounded and deterministic size to respect budget
      per_block_target = max(8, min(64, budget // 12))
      U = thin_seed(current_T, per_block_target)
      if not U:
        return []

      # Build four translated blocks using the same 4-start template,
      # with deterministic parity-based internal reversal
      blocks = []
      ulo = min(l for l, r in U)
      for s in starts:
        base = s * delta2 - ulo
        block = [(l + base, r + base) for (l, r) in U]
        if ((s // 2) % 2) == (round_id % 2):
          block = list(reversed(block))
        blocks.append(block)

      micro = []
      # Parity-based interleaving across blocks
      maxlen = max(len(b) for b in blocks)
      if round_id % 2 == 0:
        for i in range(maxlen):
          for blk in blocks:
            if i < len(blk):
              micro.append(blk[i])
      else:
        for i in range(maxlen):
          for blk in reversed(blocks):
            if i < len(blk):
              micro.append(blk[i])

      # Deterministic connectors at delta2 scale, including a longer cross3
      s0, s1, s2, s3 = starts
      connectors = [
        ((s0 - 1) * delta2 + glo, (s1 - 1) * delta2 + glo),  # left cap
        ((s2 + 2) * delta2 + glo, (s3 + 2) * delta2 + glo),  # right cap
        ((s0 + 2) * delta2 + glo, (s2 - 1) * delta2 + glo),  # cross 1
        ((s1 + 2) * delta2 + glo, (s3 - 1) * delta2 + glo),  # cross 2
        ((s0 + 3) * delta2 + glo, (s3 + 3) * delta2 + glo),  # cross3 (long range)
      ]
      micro.extend(connectors)

      # Sparse micro caps to press FirstFit locally without raising omega much
      cap1 = (glo + (delta2 // 4), glo + int(1.8 * delta2))
      cap2 = (glo + int(0.9 * delta2), glo + int(2.6 * delta2))
      mid = glo + G // 2
      cap3 = (mid - max(1, delta2 // 8), mid + max(1, delta2 // 8))
      for cap in (cap1, cap2, cap3):
        if cap[1] > cap[0]:
          micro.append(cap)

      # Enforce budget
      if len(micro) > budget:
        micro = micro[:budget]
      return micro
=======
    def micro_round(current_T, round_id, budget, scale_div=2, starts_override=None):
      if budget <= 0 or not current_T:
        return []
      glo = min(l for l, r in current_T)
      ghi = max(r for l, r in current_T)
      G = max(1, ghi - glo)
      # Use reduced scale to avoid expanding the global span too aggressively
      delta2 = max(1, G // max(1, scale_div))

      # Thin seed: bounded and deterministic size to respect budget
      per_block_target = max(8, min(64, budget // 12))
      U = thin_seed(current_T, per_block_target)
      if not U:
        return []

      # Determine starts pattern
      use_starts = starts_override if starts_override is not None else starts

      # Build translated blocks using the use_starts template,
      # with deterministic parity-based internal reversal
      blocks = []
      ulo = min(l for l, r in U)
      for s in use_starts:
        base = s * delta2 - ulo
        block = [(l + base, r + base) for (l, r) in U]
        if ((s // 2) % 2) == (round_id % 2):
          block = list(reversed(block))
        blocks.append(block)

      micro = []
      # Parity-based interleaving across blocks
      maxlen = max(len(b) for b in blocks)
      if round_id % 2 == 0:
        for i in range(maxlen):
          for blk in blocks:
            if i < len(blk):
              micro.append(blk[i])
      else:
        for i in range(maxlen):
          for blk in reversed(blocks):
            if i < len(blk):
              micro.append(blk[i])

      # Deterministic connectors at delta2 scale, including a longer cross3 and cross4
      s0, s1, s2, s3 = use_starts
      connectors = [
        ((s0 - 1) * delta2 + glo, (s1 - 1) * delta2 + glo),  # left cap
        ((s2 + 2) * delta2 + glo, (s3 + 2) * delta2 + glo),  # right cap
        ((s0 + 2) * delta2 + glo, (s2 - 1) * delta2 + glo),  # cross 1
        ((s1 + 2) * delta2 + glo, (s3 - 1) * delta2 + glo),  # cross 2
        ((s0 + 3) * delta2 + glo, (s3 + 3) * delta2 + glo),  # cross3 (long range)
        ((s0 + 4) * delta2 + glo, (s3 + 4) * delta2 + glo),  # cross4 (extra fine coupler)
      ]
      micro.extend(connectors)

      # Sparse micro caps to press FirstFit locally without raising omega much
      cap1 = (glo + (delta2 // 4), glo + int(1.8 * delta2))
      cap2 = (glo + int(0.9 * delta2), glo + int(2.6 * delta2))
      mid = glo + G // 2
      cap3 = (mid - max(1, delta2 // 8), mid + max(1, delta2 // 8))
      for cap in (cap1, cap2, cap3):
        if cap[1] > cap[0]:
          micro.append(cap)

      # Enforce budget
      if len(micro) > budget:
        micro = micro[:budget]
      return micro
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    remaining = CAP - len(T)
    mr2 = micro_round(T, round_id=1, budget=max(0, remaining))
    if mr2:
      room = CAP - len(T)
      if len(mr2) > room:
        mr2 = mr2[:room]
      T.extend(mr2)

  return T
=======
    remaining = CAP - len(T)
    mr2 = micro_round(T, round_id=1, budget=max(0, remaining))
    if mr2:
      room = CAP - len(T)
      if len(mr2) > room:
        mr2 = mr2[:room]
      T.extend(mr2)

    # Stage 3: Additional fine micro round at quarter-scale for extra FF pressure
    remaining = CAP - len(T)
    if remaining > 0:
      mr3 = micro_round(T, round_id=2, budget=remaining, scale_div=4, starts_override=(3,7,11,15))
      if mr3:
        room = CAP - len(T)
        if len(mr3) > room:
          mr3 = mr3[:room]
        T.extend(mr3)

  return T
>>>>>>> REPLACE
</DIFF>