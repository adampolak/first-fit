--- a/original.py
+++ b/original.py
@@ -1,180 +1,168 @@
 # EVOLVE-BLOCK-START
 
 def construct_intervals(rounds=6,
                         rotate_starts=True,
+                        interleave_blocks=True,
                         reverse_block_parity=True,
-                        interleave_blocks=True,
-                        phase2_iters=1,
+                        phase2_iters=2,
                         cross4_enabled=True):
-  """
-  Rotating-template KT spine with fractional-window micro phases.
-  Returns intervals (l, r) in FirstFit presentation order.
-  """
+    """
+    Merged KTâ€“spine + near-tail caps + two-phase micro rounds.
+    Returns a list of (l, r) intervals in the order presented to FirstFit.
+    """
+    CAP = 9800
 
-  # Capacity guard to keep total intervals < 10000
-  CAP = 9800
+    # Four main KT-templates (rotated each round if enabled)
+    spine_starts = (2, 6, 10, 14)
+    template_bank = [
+        (2, 6, 10, 14),
+        (1, 5, 9, 13),
+        (3, 7, 11, 15),
+        (4, 8, 12, 16),
+    ]
 
-  # Start template(s)
-  spine_starts = (2, 6, 10, 14)
-  template_bank = [
-    (2, 6, 10, 14),  # classic KT
-    (1, 5, 9, 13),   # left-shifted
-    (3, 7, 11, 15),  # right-shifted
-    (4, 8, 12, 16),  # stretched-right
-  ]
+    # Helpers
+    def _span(T):
+        lo = min(l for l, _ in T)
+        hi = max(r for _, r in T)
+        delta = hi - lo
+        return lo, hi, delta if delta > 0 else 1
 
-  # Seed with one unit interval
-  T = [(0, 1)]
+    def _append_connectors(S, starts, delta, cross4=False):
+        s0, s1, s2, s3 = starts
+        S.append(((s0 - 1) * delta, (s1 - 1) * delta))
+        S.append(((s2 + 2) * delta, (s3 + 2) * delta))
+        S.append(((s0 + 2) * delta, (s2 - 1) * delta))
+        S.append(((s1 + 2) * delta, (s3 - 1) * delta))
+        if cross4:
+            S.append(((s0 + 4) * delta, (s3 + 4) * delta))
 
-  # Helpers
-  def _span(current_T):
-    lo = min(l for l, r in current_T)
-    hi = max(r for l, r in current_T)
-    delta = hi - lo
-    if delta <= 0:
-      delta = 1
-    return lo, hi, delta
+    def _apply_round(T, starts, do_interleave, reverse_order, add_cross4):
+        lo, hi, delta = _span(T)
+        # build blocks
+        blocks = []
+        for s in starts:
+            shift = s * delta - lo
+            blocks.append([(l + shift, r + shift) for (l, r) in T])
+        # assemble
+        S = []
+        if do_interleave:
+            order = list(range(4))
+            if reverse_order:
+                order.reverse()
+            m = max(len(b) for b in blocks)
+            for i in range(m):
+                for idx in order:
+                    blk = blocks[idx]
+                    if i < len(blk):
+                        S.append(blk[i])
+        else:
+            blks = list(reversed(blocks)) if reverse_order else blocks
+            for blk in blks:
+                S.extend(blk)
+        _append_connectors(S, starts, delta, cross4=add_cross4)
+        return S
 
-  def _apply_round(current_T, starts, do_interleave=False, reverse_order=False, add_cross4=False):
-    lo, hi, delta = _span(current_T)
+    def _insert_near_tail(T, caps):
+        out = list(T)
+        for i, iv in enumerate(caps):
+            pos = len(out) - (2*i + 1)
+            if pos < 0:
+                out.append(iv)
+            else:
+                out.insert(pos, iv)
+        return out
 
-    # Build four translated blocks
-    blocks = []
-    for s in starts:
-      base = s * delta - lo
-      block = [(l + base, r + base) for (l, r) in current_T]
-      blocks.append(block)
+    def build_micro_delta_round(T, budget, iter_id=0):
+        if budget <= 8 or not T:
+            return []
+        glo, ghi, G = *_span(T),
+        G = max(1, G)
+        # pick thin seed
+        seed_sz = max(8, min(32, len(T)//300))
+        step = max(1, len(T)//seed_sz)
+        U = T[::step][:seed_sz]
+        ulo = min(l for l, _ in U)
+        # choose window family (alternate on second round)
+        if iter_id % 2 == 0:
+            shift = (iter_id % 3) * 0.02
+            fracs = [(0.12+shift,0.22+shift),(0.35+shift,0.45+shift),
+                     (0.58+shift,0.68+shift),(0.80+shift,0.90+shift)]
+        else:
+            fracs = [(0.05,0.15),(0.28,0.38),(0.60,0.70),(0.82,0.92)]
+        # clamp fractions
+        fracs = [ (max(0.05,a), min(0.95,b)) for a,b in fracs ]
+        # build micro blocks
+        blocks = []
+        for fa, fb in fracs:
+            win_lo = glo + int(round(fa*G))
+            shift = win_lo - ulo
+            blk = [(l+shift, r+shift) for (l,r) in U]
+            # optional reversal for mixing
+            if ((int(fa*100)//5) + iter_id) % 2:
+                blk.reverse()
+            blocks.append(blk)
+        # interleave
+        micro = []
+        m = max(len(b) for b in blocks)
+        order = list(range(4))
+        if iter_id % 2: order.reverse()
+        for i in range(m):
+            for idx in order:
+                if i < len(blocks[idx]):
+                    micro.append(blocks[idx][i])
+        # connectors
+        con = [
+            (glo+int(round(0.08*G)), glo+int(round(0.30*G))),
+            (glo+int(round(0.60*G)), glo+int(round(0.92*G))),
+            (glo+int(round(0.26*G)), glo+int(round(0.56*G))),
+            (glo+int(round(0.44*G)), glo+int(round(0.78*G))),
+        ]
+        if iter_id % 2:
+            con.append((glo+int(round(0.18*G)), glo+int(round(0.84*G))))
+        for a,b in con:
+            if b>a:
+                micro.append((a,b))
+        return micro[:budget]
 
-    # Interleaving policy
-    S = []
-    if do_interleave:
-      order = list(range(4))
-      if reverse_order:
-        order.reverse()
-      maxlen = max(len(b) for b in blocks)
-      for i in range(maxlen):
-        for idx in order:
-          blk = blocks[idx]
-          if i < len(blk):
-            S.append(blk[i])
-    else:
-      if reverse_order:
-        blocks = list(reversed(blocks))
-      for blk in blocks:
-        S.extend(blk)
+    # --- Stage 1: KT-spine ---
+    T = [(0,1)]
+    for ridx in range(int(rounds)):
+        if 4*len(T)+4 > CAP:
+            break
+        starts = template_bank[ridx%4] if rotate_starts else spine_starts
+        do_int = interleave_blocks and (ridx%2==0)
+        rev   = reverse_block_parity and (ridx%2==1)
+        last  = (ridx==int(rounds)-1) and cross4_enabled
+        T = _apply_round(T, starts, do_int, rev, add_cross4=last)
+        if len(T)>=CAP:
+            T = T[:CAP]
+            return T
 
-    # Classic four connectors
-    s0, s1, s2, s3 = starts
-    S.append(((s0 - 1) * delta, (s1 - 1) * delta))  # left cap
-    S.append(((s2 + 2) * delta, (s3 + 2) * delta))  # right cap
-    S.append(((s0 + 2) * delta, (s2 - 1) * delta))  # cross 1
-    S.append(((s1 + 2) * delta, (s3 - 1) * delta))  # cross 2
+    # near-tail caps
+    lo,hi,delta = _span(T)
+    caps = []
+    for a,b in ((0.08,0.60),(0.25,0.75),(0.75,0.92)):
+        L = lo+max(1,int(round(a*(hi-lo))))
+        R = lo+max(1,int(round(b*(hi-lo))))
+        if R<=L: R=L+1
+        caps.append((L,R))
+    T = _insert_near_tail(T, caps)
+    if len(T)>=CAP-8:
+        return T[:CAP]
 
-    # Optional long-range cross (kept conservative: disabled when rotating templates)
-    if add_cross4:
-      S.append(((s0 + 4) * delta, (s3 + 4) * delta))
-    return S
-
-  # Stage 1: KT spine with rotation and parity policies, capacity-guarded
-  for ridx in range(max(0, int(rounds))):
-    # Predict next size: sz -> 4*sz + 4
-    if 4 * len(T) + 4 > CAP:
-      break
-    starts = template_bank[ridx % len(template_bank)] if rotate_starts else spine_starts
-    do_inter = bool(interleave_blocks and (ridx % 2 == 0))
-    rev = bool(reverse_block_parity and (ridx % 2 == 1))
-    # Add cross4 only on final executed round and only if not rotating templates (safer)
-    add_c4 = False  # default safer choice
-    T = _apply_round(T, starts, do_interleave=do_inter, reverse_order=rev, add_cross4=add_c4)
-
-  # Early exit if nearly at capacity
-  if len(T) >= CAP - 8:
-    return T
-
-  # Micro-phase A: add three long-range caps to boost FF pressure (capacity-safe)
-  lo, hi, delta = _span(T)
-  def cap_at(a_frac, b_frac):
-    L = lo + max(1, int(round(a_frac * (hi - lo))))
-    R = lo + max(1, int(round(b_frac * (hi - lo))))
-    if R <= L:
-      R = L + 1
-    return (L, R)
-  caps = [cap_at(0.08, 0.60), cap_at(0.25, 0.75), cap_at(0.75, 0.92)]
-  for c in caps:
-    if len(T) >= CAP:
-      break
-    T.append(c)
-
-  # Micro-phase B: thin delta2-style fractional-window round(s), capacity-guarded
-  def build_micro_delta_round(current_T, budget):
-    if not current_T or budget <= 8:
-      return []
-
-    glo = min(l for l, r in current_T)
-    ghi = max(r for l, r in current_T)
-    G = max(1, ghi - glo)
-
-    # Thin, evenly spaced seed
-    seed_sz = max(8, min(32, len(current_T) // 300))
-    stride = max(1, len(current_T) // max(1, seed_sz))
-    U = [current_T[i] for i in range(0, len(current_T), stride)][:seed_sz]
-    if not U:
-      return []
-
-    ulo = min(l for l, r in U)
-
-    # Four windows across the span (stay inside to control omega)
-    window_fracs = [(0.12, 0.22), (0.35, 0.45), (0.58, 0.68), (0.80, 0.90)]
-
-    # Build translated micro-blocks aligned to these windows
-    blocks = []
-    for (fa, fb) in window_fracs:
-      win_lo = glo + int(round(fa * G))
-      base = win_lo - ulo
-      block = [(l + base, r + base) for (l, r) in U]
-      blocks.append(block)
-
-    # Interleave micro-blocks to maximize FF mixing
-    micro = []
-    maxlen = max(len(b) for b in blocks)
-    for i in range(maxlen):
-      for blk in blocks:
-        if i < len(blk):
-          micro.append(blk[i])
-
-    # Fractional-span connectors at the micro scale
-    micro_connectors = [
-      (glo + int(round(0.08 * G)), glo + int(round(0.30 * G))),  # left cap
-      (glo + int(round(0.60 * G)), glo + int(round(0.92 * G))),  # right cap
-      (glo + int(round(0.26 * G)), glo + int(round(0.56 * G))),  # cross 1
-      (glo + int(round(0.44 * G)), glo + int(round(0.78 * G))),  # cross 2
-    ]
-    for a, b in micro_connectors:
-      if b > a:
-        micro.append((a, b))
-
-    # Trim to available budget
-    if len(micro) > budget:
-      micro = micro[:budget]
-    return micro
-
-  # Respect requested phase2_iters but guard to at most two micro-rounds; default 1
-  steps = min(max(0, int(phase2_iters)), 2)
-  for _ in range(steps):
-    room = CAP - len(T)
-    if room <= 8:
-      break
-    micro = build_micro_delta_round(T, room)
-    if not micro:
-      break
-    if len(micro) > room:
-      micro = micro[:room]
-    T.extend(micro)
-
-  return T
+    # --- Stage 2: micro rounds ---
+    steps = min(int(phase2_iters), 2)
+    for i in range(steps):
+        room = CAP - len(T)
+        if room<=8: break
+        micro = build_micro_delta_round(T, room, iter_id=i)
+        if not micro: break
+        T.extend(micro)
+    return T[:CAP]
 
 # EVOLVE-BLOCK-END
 
 def run_experiment(**kwargs):
   """Main called by evaluator"""
   return construct_intervals()