--- a/original.py
+++ b/original.py
@@ -1,258 +1,293 @@
 # EVOLVE-BLOCK-START
 
 def construct_intervals(enable_alt_microphase=True):
   """
-  Construct a sequence of intervals of real line,
-  in the order in which they are presented to FirstFit,
-  so that it maximizes the number of colors used by FirstFit
-  divided by the maximum number of intervals that cover a single point.
-
-  Deterministic KT-style backbone with two CAP-aware micro-phases and
-  carefully chosen connectors, keeping omega small (target <= 10).
-
-  Args:
-    enable_alt_microphase (bool): enable a second, alternate micro-phase.
+  Construct a deterministic sequence of open intervals for FirstFit.
+
+  Same inputs/outputs as the prior program:
+    enable_alt_microphase (bool): whether to run the second micro-phase pass.
 
   Returns:
-    intervals: list of tuples, each tuple (l, r) represents an open interval from l to r.
+    list of (l, r) integer tuples representing open intervals in arrival order.
   """
 
-  # Capacity guard to keep total intervals < 10000
+  # Capacity guard (keep < 10000)
   CAP = 9800
 
-  # Rotating six-start templates for the KT spine (expanded bank for more mixing)
+  # Expanded template bank (six templates) to rotate across rounds
   template_bank = [
-    (2, 6, 10, 14),  # classic KT
-    (1, 5, 9, 13),   # left-shifted
-    (3, 7, 11, 15),  # right-shifted
-    (4, 8, 12, 16),  # stretched-right
-    (5, 9, 13, 17),  # extra right-shift
-    (6, 10, 14, 18), # extra classic-shift
+    (2, 6, 10, 14),
+    (1, 5, 9, 13),
+    (3, 7, 11, 15),
+    (4, 8, 12, 16),
+    (5, 9, 13, 17),
+    (6, 10, 14, 18),
   ]
+
+  # Deterministic interleaving schedule: interleave on rounds with idx % 3 != 0,
+  # reverse-block-order on rounds where idx % 4 == 1 (deterministic pattern).
+  def should_interleave(round_idx):
+    return (round_idx % 3) != 0
+
+  def should_reverse(round_idx):
+    return (round_idx % 4) == 1
 
   # Seed with a single unit interval
   T = [(0, 1)]
 
-  # Helpers
-  def _span(current_T):
-    lo = min(l for l, r in current_T)
-    hi = max(r for l, r in current_T)
+  # Utility: compute span and delta (nonzero)
+  def span_info(intervals):
+    lo = min(l for l, r in intervals)
+    hi = max(r for l, r in intervals)
     delta = hi - lo
     if delta <= 0:
       delta = 1
     return lo, hi, delta
 
-  def _apply_round(current_T, starts, do_interleave=False, reverse_order=False):
-    lo, hi, delta = _span(current_T)
+  # Apply a KT-like round with given starts (4-tuple)
+  def apply_spine_round(current_T, starts, do_interleave=False, reverse_order=False):
+    lo, hi, delta = span_info(current_T)
 
     # Build four translated blocks
     blocks = []
     for s in starts:
       base = s * delta - lo
       block = [(l + base, r + base) for (l, r) in current_T]
       blocks.append(block)
 
-    # Interleaving policy: order derived from 'starts' to diversify per-round mixing
+    # Determine block output order using deterministic ordering function
     S = []
     if do_interleave:
-      # define order by sorting block indices by start values (or reverse)
       order = sorted(range(4), key=lambda i: starts[i], reverse=reverse_order)
       maxlen = max(len(b) for b in blocks)
       for i in range(maxlen):
         for idx in order:
           blk = blocks[idx]
           if i < len(blk):
             S.append(blk[i])
     else:
       if reverse_order:
         blocks = list(reversed(blocks))
       for blk in blocks:
         S.extend(blk)
 
-    # Classic four connectors (Figure-4 style)
+    # Classic four connectors (Figure-4 style) using delta-scaled positions
     s0, s1, s2, s3 = starts
-    S.append(((s0 - 1) * delta, (s1 - 1) * delta))  # left cap
-    S.append(((s2 + 2) * delta, (s3 + 2) * delta))  # right cap
-    S.append(((s0 + 2) * delta, (s2 - 1) * delta))  # cross 1
-    S.append(((s1 + 2) * delta, (s3 - 1) * delta))  # cross 2
+    # left cap, right cap, cross1, cross2
+    S.append(((s0 - 1) * delta, (s1 - 1) * delta))
+    S.append(((s2 + 2) * delta, (s3 + 2) * delta))
+    S.append(((s0 + 2) * delta, (s2 - 1) * delta))
+    S.append(((s1 + 2) * delta, (s3 - 1) * delta))
+
     return S
 
-  # Stage 1: KT spine with rotation and parity policies, capacity-guarded
-  for ridx in range(8):
-    # Predict next size: sz -> 4*sz + 4
-    if 4 * len(T) + 4 > CAP:
+  # Predictive round count: we don't want to overshoot CAP
+  # Growth: size -> 4*size + 4 per round
+  def rounds_we_can_do(initial_size, max_rounds):
+    sz = initial_size
+    done = 0
+    for r in range(max_rounds):
+      nxt = 4 * sz + 4
+      if nxt > CAP:
+        break
+      sz = nxt
+      done += 1
+    return done
+
+  # Stage 1: KT-like spine with rotation through 6 templates.
+  max_spine_rounds = 8  # try up to 8, but will be clipped by CAP-aware check
+  can_do = rounds_we_can_do(len(T), max_spine_rounds)
+  for ridx in range(can_do):
+    starts = template_bank[ridx % len(template_bank)]
+    inter = should_interleave(ridx)
+    rev = should_reverse(ridx)
+    T = apply_spine_round(T, starts, do_interleave=inter, reverse_order=rev)
+
+    # CAP-guard break
+    if len(T) >= CAP - 12:
       break
-    starts = template_bank[ridx % len(template_bank)]
-    # Interleave on even rounds, reverse block order on odd rounds
-    do_inter = (ridx % 2 == 0)
-    rev = (ridx % 2 == 1)
-    T = _apply_round(T, starts, do_interleave=do_inter, reverse_order=rev)
-
-  # Early exit if nearly at capacity (before micro-phases)
+
+    # Per-round deterministic density multiplier applied to a small central subset
+    # (increases local pressure without exploding omega). Apply only on selected rounds.
+    if ridx % 2 == 0 and len(T) < CAP - 32:
+      # pick a small central window and clone-shrink a few intervals
+      lo, hi, delta = span_info(T)
+      center = lo + delta // 2
+      # sample up to 6 intervals near the center
+      sampled = [iv for iv in T if iv[0] <= center <= iv[1]]
+      # fall back to uniformly spaced sample if none
+      if not sampled:
+        step = max(1, len(T) // 100)
+        sampled = [T[i] for i in range(0, len(T), step)][:6]
+      densified = []
+      shrink = max(1, delta // 2048)
+      for (l, r) in sampled[:6]:
+        if r - l > 2 * shrink:
+          densified.append((l + shrink, r - shrink))
+      # insert densified intervals near the end (preserve arrival mixing)
+      for iv in densified:
+        if len(T) >= CAP:
+          break
+        T.append(iv)
+
+  # Early exit if near capacity
   if len(T) >= CAP - 8:
-    return T
-
-  # Spine densification: duplicate a thin seed of intervals with slight shrink to boost FF pressure
-  room = CAP - len(T)
-  if room > 16:
-    # Sample a small seed of intervals uniformly from the KT spine
-    stride = max(1, len(T) // 100)
-    seed = [T[i] for i in range(0, len(T), stride)][:10]
-    lo_d, hi_d, span_d = _span(T)
-    eps = max(1, span_d // 1000)
-    densify = []
-    for (l, r) in seed:
-      if r - l > 2 * eps:
-        densify.append((l + eps, r - eps))
-    # Insert densified intervals if capacity allows
-    for iv in densify:
-      if len(T) >= CAP:
-        break
-      T.append(iv)
-
-  # Micro-phase A: add three long-range caps to boost FF pressure (capacity-safe)
-  lo, hi, _ = _span(T)
-  span = max(1, hi - lo)
-  def cap_at(a_frac, b_frac):
-    L = lo + max(1, int(round(a_frac * span)))
-    R = lo + max(1, int(round(b_frac * span)))
-    if R <= L:
-      R = L + 1
-    return (L, R)
-  caps = [cap_at(0.08, 0.60), cap_at(0.25, 0.75), cap_at(0.75, 0.92)]
-  for c in caps:
-    if len(T) >= CAP:
-      break
-    T.append(c)
-
-  # Micro-phase builder: thin-window replication with connectors
-  def build_micro_delta_round(current_T, budget, alt=False):
+    return T[:CAP]
+
+  # Micro-phase budget splitting: deterministic two-pass split (approx 60/40)
+  remaining = CAP - len(T)
+  passA_budget = max(8, int(round(0.60 * remaining)))
+  passB_budget = remaining - passA_budget
+
+  # Micro-phase builder: thin-window replication plus local connectors.
+  # Two families: primary (shifted) and alternate (offset windows + long cross).
+  def build_micro_pass(current_T, budget, pass_id=0, alt=False):
     if not current_T or budget <= 8:
       return []
 
     glo = min(l for l, r in current_T)
     ghi = max(r for l, r in current_T)
     G = max(1, ghi - glo)
 
-    # Thin, evenly spaced seed
-    seed_sz = max(8, min(32, len(current_T) // 300))
-    if alt:
-      seed_sz = max(8, min(40, len(current_T) // 250))
-    stride = max(1, len(current_T) // max(1, seed_sz))
-    U = [current_T[i] for i in range(0, len(current_T), stride)][:seed_sz]
+    # thin evenly spaced seed U
+    base_seed = max(8, min(40, len(current_T) // (220 if alt else 300)))
+    stride = max(1, len(current_T) // max(1, base_seed))
+    U = [current_T[i] for i in range(0, len(current_T), stride)][:base_seed]
     if not U:
       return []
 
     ulo = min(l for l, r in U)
 
-    # Four windows across the span (stay inside to control omega)
+    # window families
     if not alt:
-      window_fracs = [(0.12, 0.22), (0.35, 0.45), (0.58, 0.68), (0.80, 0.90)]
+      # primary windows have a tiny deterministic shift per pass_id
+      shift = (pass_id % 3) * 0.015
+      window_fracs = [
+        (0.12 + shift, 0.22 + shift),
+        (0.35 + shift, 0.45 + shift),
+        (0.58 + shift, 0.68 + shift),
+        (0.80 + shift, 0.90 + shift),
+      ]
     else:
-      window_fracs = [(0.05, 0.15), (0.28, 0.38), (0.60, 0.70), (0.82, 0.92)]
-
-    # Build translated micro-blocks aligned to these windows
+      # alternate windows are offset to avoid stacking
+      window_fracs = [
+        (0.05, 0.15),
+        (0.28, 0.38),
+        (0.60, 0.70),
+        (0.82, 0.92),
+      ]
+
+    # clamp windows inside (0.03, 0.97)
+    window_fracs = [(max(0.03, a), min(0.97, b)) for (a, b) in window_fracs]
+
     blocks = []
-    for (fa, fb) in window_fracs:
+    for idx, (fa, fb) in enumerate(window_fracs):
       win_lo = glo + int(round(fa * G))
       base = win_lo - ulo
       block = [(l + base, r + base) for (l, r) in U]
-      # Internal reversal on alternating pattern for alt-phase to diversify
-      if alt and int(round(fa * 100)) // 5 % 2 == 1:
+      # occasionally reverse internally to break symmetry deterministically
+      if (idx + pass_id) % 2 == 1:
         block = list(reversed(block))
       blocks.append(block)
 
-    # Interleave micro-blocks to maximize FF mixing
+    # Interleave blocks to maximize mixing; pass_id determines order
     micro = []
     maxlen = max(len(b) for b in blocks)
-    if not alt:
-      # forward interleave
-      for i in range(maxlen):
-        for blk in blocks:
-          if i < len(blk):
-            micro.append(blk[i])
-    else:
-      # reverse interleave
-      for i in range(maxlen):
-        for blk in reversed(blocks):
-          if i < len(blk):
-            micro.append(blk[i])
-
-    # Fractional-span connectors at the micro scale
+    order = list(range(len(blocks)))
+    if pass_id % 2 == 1:
+      order.reverse()
+    for i in range(maxlen):
+      for j in order:
+        blk = blocks[j]
+        if i < len(blk):
+          micro.append(blk[i])
+
+    # micro-scale connectors (to tie windows)
     micro_connectors = [
-      (glo + int(round(0.08 * G)), glo + int(round(0.30 * G))),  # left cap
-      (glo + int(round(0.60 * G)), glo + int(round(0.92 * G))),  # right cap
-      (glo + int(round(0.26 * G)), glo + int(round(0.56 * G))),  # cross 1
-      (glo + int(round(0.44 * G)), glo + int(round(0.78 * G))),  # cross 2
+      (glo + int(round(0.08 * G)), glo + int(round(0.30 * G))),
+      (glo + int(round(0.60 * G)), glo + int(round(0.92 * G))),
+      (glo + int(round(0.26 * G)), glo + int(round(0.56 * G))),
+      (glo + int(round(0.44 * G)), glo + int(round(0.78 * G))),
     ]
     for a, b in micro_connectors:
       if b > a:
         micro.append((a, b))
 
-    # A long cross to tie distant colors (alt-phase only)
+    # alternate pass gets a long cross connector to tie distant colors
     if alt:
-      a = glo + int(round(0.18 * G))
-      b = glo + int(round(0.84 * G))
-      if b > a:
-        micro.append((a, b))
-
-    # Trim to available budget
+      long_a = glo + int(round(0.18 * G))
+      long_b = glo + int(round(0.84 * G))
+      if long_b > long_a:
+        micro.append((long_a, long_b))
+
+    # Trim to budget deterministically (take the prefix)
     if len(micro) > budget:
       micro = micro[:budget]
     return micro
 
-  # Micro-phase B: one safeguarded micro-round (empirically strong for 2.30-tier results)
+  # Execute micro-phase A (primary)
+  microA = build_micro_pass(T, passA_budget, pass_id=0, alt=False)
+  if microA:
+    take = min(len(microA), CAP - len(T))
+    if take > 0:
+      T.extend(microA[:take])
+
+  # Optionally execute micro-phase B (alternate)
+  if enable_alt_microphase:
+    room = CAP - len(T)
+    if room > 8:
+      microB = build_micro_pass(T, passB_budget, pass_id=1, alt=True)
+      if microB:
+        take = min(len(microB), CAP - len(T))
+        if take > 0:
+          T.extend(microB[:take])
+
+  # Final long-range deterministic connectors (4 small connectors)
+  if len(T) < CAP:
+    lo, hi, delta = span_info(T)
+    span = max(1, delta)
+    # Choose deterministic fractional anchors
+    anchors = [0.02, 0.12, 0.28, 0.44]
+    for a_frac in anchors:
+      a = lo + int(round(a_frac * span))
+      b = hi - int(round((a_frac + 0.01) * span))  # slightly asymmetric to avoid exact sym
+      if b > a and len(T) < CAP:
+        T.append((a, b))
+
+  # Final tower-pins: short staggered intervals in interior windows
   room = CAP - len(T)
   if room > 8:
-    micro = build_micro_delta_round(T, room, alt=False)
-    if micro:
-      if len(micro) > room:
-        micro = micro[:room]
-      T.extend(micro)
-
-  # Micro-phase C: alternate window family + long cross (guarded, optional)
-  room = CAP - len(T)
-  if enable_alt_microphase and room > 8:
-    micro_alt = build_micro_delta_round(T, room, alt=True)
-    if micro_alt:
-      if len(micro_alt) > room:
-        micro_alt = micro_alt[:room]
-      T.extend(micro_alt)
-
-  # Micro-phase D: tower pins (short, staggered intervals) to increase FF pressure
-  # without inflating omega; placed in four interior windows and spaced to be disjoint.
-  room = CAP - len(T)
-  if room > 8:
-    glo = min(l for l, r in T)
-    ghi = max(r for l, r in T)
-    G = max(1, ghi - glo)
+    lo, hi, delta = span_info(T)
+    G = max(1, delta)
     eps = max(1, G // 4096)  # very short pins
     windows = [0.14, 0.31, 0.66, 0.83]
-    # Limit per-window pins to keep total bounded and spacing clean
-    max_per_win = max(4, min(64, room // max(1, len(windows))))
-    stride = max(2 * eps + 3, 3)
+    # deterministic per-window count based on remaining capacity
+    per_win = max(1, min(64, room // len(windows)))
+    stride = max(2 * eps + 2, 3)
     pins = []
     for wi, w in enumerate(windows):
-      base = glo + int(round(w * G))
-      start = base - (max_per_win // 2) * stride + (wi % 3)
-      for j in range(max_per_win):
+      base = lo + int(round(w * G))
+      # start offset deterministically from wi to avoid alignment
+      start = base - (per_win // 2) * stride + (wi % 3)
+      for j in range(per_win):
         L = start + j * stride
         R = L + eps
         if R > L:
           pins.append((L, R))
+    # append deterministic prefix up to room
     if pins:
       if len(pins) > room:
         pins = pins[:room]
       T.extend(pins)
 
-  # Final capacity trim
+  # Final trim to CAP
   if len(T) > CAP:
     T = T[:CAP]
 
   return T
 
 # EVOLVE-BLOCK-END
 
 def run_experiment(**kwargs):
   """Main called by evaluator"""
   return construct_intervals()