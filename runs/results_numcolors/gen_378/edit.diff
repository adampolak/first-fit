--- a/original.py
+++ b/original.py
@@ -1,231 +1,158 @@
 # EVOLVE-BLOCK-START
 
 def construct_intervals(enable_alt_microphase=True):
-  """
-  Construct a sequence of intervals of real line,
-  in the order in which they are presented to FirstFit,
-  so that it maximizes the number of colors used by FirstFit
-  divided by the maximum number of intervals that cover a single point.
+    """
+    Six-template KT spine + density boosts + two-pass micro-phases + final long connectors.
+    Returns list of (l, r) open intervals for FirstFit presentation.
+    """
+    CAP = 9800
 
-  Deterministic KT-style backbone with two CAP-aware micro-phases and
-  carefully chosen connectors, keeping omega small (target <= 10).
+    # Six strong start-pattern templates
+    template_bank = [
+        (2, 6, 10, 14),
+        (1, 5, 9, 13),
+        (3, 7, 11, 15),
+        (4, 8, 12, 16),
+        (2, 4, 8, 12),
+        (3, 5, 9, 13),
+    ]
 
-  Args:
-    enable_alt_microphase (bool): enable a second, alternate micro-phase.
+    # Helpers
+    def _span(T):
+        lo = min(l for l, _ in T)
+        hi = max(r for _, r in T)
+        d = hi - lo
+        return lo, hi, d if d > 0 else 1
 
-  Returns:
-    intervals: list of tuples, each tuple (l, r) represents an open interval from l to r.
-  """
+    def _apply_round(T_prev, starts, do_interleave):
+        lo, hi, d = _span(T_prev)
+        # Build four translated blocks
+        blocks = []
+        for s in starts:
+            base = s * d - lo
+            blocks.append([(l + base, r + base) for (l, r) in T_prev])
+        # Interleave if requested
+        S = []
+        if do_interleave:
+            order = list(range(4))
+            maxlen = max(len(b) for b in blocks)
+            for i in range(maxlen):
+                for idx in order:
+                    blk = blocks[idx]
+                    if i < len(blk):
+                        S.append(blk[i])
+        else:
+            for blk in blocks:
+                S.extend(blk)
+        # Classic connectors
+        s0, s1, s2, s3 = starts
+        S.append(((s0 - 1) * d, (s1 - 1) * d))
+        S.append(((s2 + 2) * d, (s3 + 2) * d))
+        S.append(((s0 + 2) * d, (s2 - 1) * d))
+        S.append(((s1 + 2) * d, (s3 - 1) * d))
+        return S
 
-  # Capacity guard to keep total intervals < 10000
-  CAP = 9800
+    def density_boost(T_prev, factor=0.05, max_boost=200):
+        lo, hi, d = _span(T_prev)
+        # central window
+        mid_lo = lo + int(d * (0.5 - factor/2))
+        mid_hi = lo + int(d * (0.5 + factor/2))
+        # sample a few in the center
+        U = [iv for iv in T_prev if iv[0] >= mid_lo and iv[1] <= mid_hi][:max_boost]
+        eps = max(1, int(d * 0.005))
+        new = []
+        for (l, r) in U:
+            if r - l > 2 * eps:
+                new.append((l + eps, r - eps))
+        return new
 
-  # Rotating four-start templates for the KT spine
-  template_bank = [
-    (2, 6, 10, 14),  # classic KT
-    (1, 5, 9, 13),   # left-shifted
-    (3, 7, 11, 15),  # right-shifted
-    (4, 8, 12, 16),  # stretched-right
-  ]
+    def build_micro(T_prev, window_fracs, add_long=False):
+        lo, hi, D = _span(T_prev)
+        # thin seed
+        seed_sz = max(8, min(32, len(T_prev)//250))
+        step = max(1, len(T_prev)//seed_sz)
+        U = [T_prev[i] for i in range(0, len(T_prev), step)][:seed_sz]
+        if not U:
+            return []
+        ulo = min(l for l, _ in U)
+        # build blocks over windows
+        blocks = []
+        for (fa, fb) in window_fracs:
+            win = lo + int(fa*D)
+            base = win - ulo
+            blk = [(l+base, r+base) for (l, r) in U]
+            blocks.append(blk)
+        # full interleave
+        micro = []
+        mlen = max(len(b) for b in blocks)
+        for i in range(mlen):
+            for blk in blocks:
+                if i < len(blk):
+                    micro.append(blk[i])
+        # small connectors
+        for (fa, fb) in [(0.08,0.30),(0.60,0.92),(0.26,0.56),(0.44,0.78)]:
+            A = lo + int(fa*D)
+            B = lo + int(fb*D)
+            if B > A:
+                micro.append((A,B))
+        # optional long cross
+        if add_long:
+            A = lo + int(0.18*D)
+            B = lo + int(0.84*D)
+            if B > A:
+                micro.append((A,B))
+        return micro
 
-  # Seed with a single unit interval
-  T = [(0, 1)]
+    # --- Stage 1: six-template spine + density boosts ---
+    T = [(0,1)]
+    for ridx in range(6):
+        if 4*len(T)+4 > CAP:
+            break
+        starts = template_bank[ridx % len(template_bank)]
+        do_int = (ridx % 2 == 0)
+        T = _apply_round(T, starts, do_int)
+        # per-round density boost
+        if len(T) < CAP*0.8:
+            boost = density_boost(T)
+            room = CAP - len(T)
+            if room <= 0: break
+            T.extend(boost[:room])
 
-  # Helpers
-  def _span(current_T):
-    lo = min(l for l, r in current_T)
-    hi = max(r for l, r in current_T)
-    delta = hi - lo
-    if delta <= 0:
-      delta = 1
-    return lo, hi, delta
+    # early exit if near CAP
+    if len(T) >= CAP - 16:
+        return T[:CAP]
 
-  def _apply_round(current_T, starts, do_interleave=False, reverse_order=False):
-    lo, hi, delta = _span(current_T)
+    # --- Stage 2A: micro-phase pass 1 ---
+    windows1 = [(0.12,0.22),(0.35,0.45),(0.58,0.68),(0.80,0.90)]
+    room = CAP - len(T)
+    if room > 8:
+        mic1 = build_micro(T, windows1, add_long=False)
+        T.extend(mic1[:room])
 
-    # Build four translated blocks
-    blocks = []
-    for s in starts:
-      base = s * delta - lo
-      block = [(l + base, r + base) for (l, r) in current_T]
-      blocks.append(block)
+    # --- Stage 2B: micro-phase pass 2 (alternate windows) ---
+    if enable_alt_microphase and len(T) < CAP - 8:
+        windows2 = [(0.05,0.15),(0.28,0.38),(0.60,0.70),(0.82,0.92)]
+        room = CAP - len(T)
+        mic2 = build_micro(T, windows2, add_long=True)
+        T.extend(mic2[:room])
 
-    # Interleaving policy (round-robin across blocks)
-    S = []
-    if do_interleave:
-      order = list(range(4))
-      if reverse_order:
-        order.reverse()
-      maxlen = max(len(b) for b in blocks)
-      for i in range(maxlen):
-        for idx in order:
-          blk = blocks[idx]
-          if i < len(blk):
-            S.append(blk[i])
-    else:
-      if reverse_order:
-        blocks = list(reversed(blocks))
-      for blk in blocks:
-        S.extend(blk)
+    # --- Stage 3: final long-range connectors ---
+    if len(T) < CAP:
+        lo, hi, D = _span(T)
+        finals = [(0.05,0.95),(0.10,0.85),(0.20,0.80),(0.30,0.70),(0.40,0.60)]
+        for (fa, fb) in finals:
+            A = lo + int(fa*D)
+            B = lo + int(fb*D)
+            if B > A:
+                T.append((A,B))
+            if len(T) >= CAP:
+                break
 
-    # Classic four connectors (Figure-4 style)
-    s0, s1, s2, s3 = starts
-    S.append(((s0 - 1) * delta, (s1 - 1) * delta))  # left cap
-    S.append(((s2 + 2) * delta, (s3 + 2) * delta))  # right cap
-    S.append(((s0 + 2) * delta, (s2 - 1) * delta))  # cross 1
-    S.append(((s1 + 2) * delta, (s3 - 1) * delta))  # cross 2
-    return S
-
-  # Stage 1: KT spine with rotation and parity policies, capacity-guarded
-  for ridx in range(6):
-    # Predict next size: sz -> 4*sz + 4
-    if 4 * len(T) + 4 > CAP:
-      break
-    starts = template_bank[ridx % len(template_bank)]
-    # Interleave on even rounds, reverse block order on odd rounds
-    do_inter = (ridx % 2 == 0)
-    rev = (ridx % 2 == 1)
-    T = _apply_round(T, starts, do_interleave=do_inter, reverse_order=rev)
-
-  # Early exit if nearly at capacity (before micro-phases)
-  if len(T) >= CAP - 8:
-    return T
-
-  # Spine densification: duplicate a thin seed of intervals with slight shrink to boost FF pressure
-  room = CAP - len(T)
-  if room > 16:
-    # Sample a small seed of intervals uniformly from the KT spine
-    stride = max(1, len(T) // 100)
-    seed = [T[i] for i in range(0, len(T), stride)][:10]
-    lo_d, hi_d, span_d = _span(T)
-    eps = max(1, span_d // 1000)
-    densify = []
-    for (l, r) in seed:
-      if r - l > 2 * eps:
-        densify.append((l + eps, r - eps))
-    # Insert densified intervals if capacity allows
-    for iv in densify:
-      if len(T) >= CAP:
-        break
-      T.append(iv)
-
-  # Micro-phase A: add three long-range caps to boost FF pressure (capacity-safe)
-  lo, hi, _ = _span(T)
-  span = max(1, hi - lo)
-  def cap_at(a_frac, b_frac):
-    L = lo + max(1, int(round(a_frac * span)))
-    R = lo + max(1, int(round(b_frac * span)))
-    if R <= L:
-      R = L + 1
-    return (L, R)
-  caps = [cap_at(0.08, 0.60), cap_at(0.25, 0.75), cap_at(0.75, 0.92)]
-  for c in caps:
-    if len(T) >= CAP:
-      break
-    T.append(c)
-
-  # Micro-phase builder: thin-window replication with connectors
-  def build_micro_delta_round(current_T, budget, alt=False):
-    if not current_T or budget <= 8:
-      return []
-
-    glo = min(l for l, r in current_T)
-    ghi = max(r for l, r in current_T)
-    G = max(1, ghi - glo)
-
-    # Thin, evenly spaced seed
-    seed_sz = max(8, min(32, len(current_T) // 300))
-    if alt:
-      seed_sz = max(8, min(40, len(current_T) // 250))
-    stride = max(1, len(current_T) // max(1, seed_sz))
-    U = [current_T[i] for i in range(0, len(current_T), stride)][:seed_sz]
-    if not U:
-      return []
-
-    ulo = min(l for l, r in U)
-
-    # Four windows across the span (stay inside to control omega)
-    if not alt:
-      window_fracs = [(0.12, 0.22), (0.35, 0.45), (0.58, 0.68), (0.80, 0.90)]
-    else:
-      window_fracs = [(0.05, 0.15), (0.28, 0.38), (0.60, 0.70), (0.82, 0.92)]
-
-    # Build translated micro-blocks aligned to these windows
-    blocks = []
-    for (fa, fb) in window_fracs:
-      win_lo = glo + int(round(fa * G))
-      base = win_lo - ulo
-      block = [(l + base, r + base) for (l, r) in U]
-      # Internal reversal on alternating pattern for alt-phase to diversify
-      if alt and int(round(fa * 100)) // 5 % 2 == 1:
-        block = list(reversed(block))
-      blocks.append(block)
-
-    # Interleave micro-blocks to maximize FF mixing
-    micro = []
-    maxlen = max(len(b) for b in blocks)
-    if not alt:
-      # forward interleave
-      for i in range(maxlen):
-        for blk in blocks:
-          if i < len(blk):
-            micro.append(blk[i])
-    else:
-      # reverse interleave
-      for i in range(maxlen):
-        for blk in reversed(blocks):
-          if i < len(blk):
-            micro.append(blk[i])
-
-    # Fractional-span connectors at the micro scale
-    micro_connectors = [
-      (glo + int(round(0.08 * G)), glo + int(round(0.30 * G))),  # left cap
-      (glo + int(round(0.60 * G)), glo + int(round(0.92 * G))),  # right cap
-      (glo + int(round(0.26 * G)), glo + int(round(0.56 * G))),  # cross 1
-      (glo + int(round(0.44 * G)), glo + int(round(0.78 * G))),  # cross 2
-    ]
-    for a, b in micro_connectors:
-      if b > a:
-        micro.append((a, b))
-
-    # A long cross to tie distant colors (alt-phase only)
-    if alt:
-      a = glo + int(round(0.18 * G))
-      b = glo + int(round(0.84 * G))
-      if b > a:
-        micro.append((a, b))
-
-    # Trim to available budget
-    if len(micro) > budget:
-      micro = micro[:budget]
-    return micro
-
-  # Micro-phase B: one safeguarded micro-round (empirically strong for 2.30-tier results)
-  room = CAP - len(T)
-  if room > 8:
-    micro = build_micro_delta_round(T, room, alt=False)
-    if micro:
-      if len(micro) > room:
-        micro = micro[:room]
-      T.extend(micro)
-
-  # Micro-phase C: alternate window family + long cross (guarded, optional)
-  room = CAP - len(T)
-  if enable_alt_microphase and room > 8:
-    micro_alt = build_micro_delta_round(T, room, alt=True)
-    if micro_alt:
-      if len(micro_alt) > room:
-        micro_alt = micro_alt[:room]
-      T.extend(micro_alt)
-
-  # Final capacity trim
-  if len(T) > CAP:
-    T = T[:CAP]
-
-  return T
+    # trim to CAP
+    return T[:CAP]
 
 # EVOLVE-BLOCK-END
 
 def run_experiment(**kwargs):
   """Main called by evaluator"""
   return construct_intervals()