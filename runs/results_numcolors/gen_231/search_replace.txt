<NAME>
blocker_ladder_and_zigzag
</NAME>

<DESCRIPTION>
I introduce two synergistic edits to push FirstFit higher while keeping omega controlled:

1) Zigzag internal ordering in the KT spine blocks: When translating each round’s four blocks, I now reverse the internal order for odd-indexed blocks. This parity-driven “zigzag” breaks color reuse symmetry across blocks without changing the interval count or the span geometry, often forcing FF to introduce additional colors earlier.

2) Guarded blocker ladder before micro blocks + reserved global cross connectors: In each delta2 micro-round, I prepend a small “blocker ladder” in each window—short, staggered pins that persist across the window. These arrive before the micro-blocks, occupying the small colors and making later intervals in those windows overlap active blockers, thus reducing FF’s ability to recycle low colors. The design spaces pins so per-point overlap is small, protecting omega. Additionally, I reserve a tiny budget (2 intervals) before the second micro-phase to inject lightweight global cross connectors that tie distant span regions; this couples colors across windows at the end without bloating omega.

All additions are capacity-guarded and deterministic. The edits keep n under CAP but increase FF pressure via arrival-order engineering and cross-window coupling.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
  def apply_round(current_T, starts, do_interleave=False, reverse_order=False, add_cross4=False):
    lo, hi, delta = _span_delta(current_T)

    # Build four translated blocks
    blocks = []
    for s in starts:
      base = s * delta - lo
      block = [(l + base, r + base) for (l, r) in current_T]
      blocks.append(block)
=======
  def apply_round(current_T, starts, do_interleave=False, reverse_order=False, add_cross4=False):
    lo, hi, delta = _span_delta(current_T)

    # Build four translated blocks (zigzag internal order to hinder FF reuse)
    blocks = []
    for b_idx, s in enumerate(starts):
      base = s * delta - lo
      src = current_T if (b_idx % 2 == 0) else list(reversed(current_T))
      block = [(l + base, r + base) for (l, r) in src]
      blocks.append(block)
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
  def build_micro_delta_round(current_T, budget, iter_id=0, alt=False):
    if not current_T or budget <= 8:
      return []

    glo = min(l for l, r in current_T)
    ghi = max(r for l, r in current_T)
    G = max(1, ghi - glo)

    # Seed construction: slightly larger for alternate pass to increase coupling
    seed_sz = max(8, min(40, len(current_T) // 250))
    stride = max(1, len(current_T) // max(1, seed_sz))
    U = [current_T[i] for i in range(0, len(current_T), stride)][:seed_sz]
    if not U:
      return []

    ulo = min(l for l, r in U)

    # Window sets: primary (A) and alternate (B)
    if not alt:
      shift = (iter_id % 3) * 0.02
      window_fracs = [
        (0.12 + shift, 0.22 + shift),
        (0.35 + shift, 0.45 + shift),
        (0.58 + shift, 0.68 + shift),
        (0.80 + shift, 0.90 + shift),
      ]
      window_fracs = [
        (max(0.05, min(0.90, a)), max(0.10, min(0.95, b)))
        for (a, b) in window_fracs
      ]
    else:
      window_fracs = [(0.05, 0.15), (0.28, 0.38), (0.60, 0.70), (0.82, 0.92)]

    # Build translated micro-blocks aligned to these windows
    blocks = []
    for (fa, fb) in window_fracs:
      win_lo = glo + int(round(fa * G))
      base = win_lo - ulo
      block = [(l + base, r + base) for (l, r) in U]
      # Alternate internal reversal by block to break symmetry
      tag = iter_id if not alt else (iter_id + 1)
      if ((int(round(fa * 100)) // 5) + tag) % 2 == 1:
        block = list(reversed(block))
      blocks.append(block)

    # Interleave micro-blocks (forward on even tag, reverse on odd tag)
    micro = []
    maxlen = max(len(b) for b in blocks)
    block_order = list(range(len(blocks)))
    tag = iter_id if not alt else (iter_id + 1)
    if tag % 2 == 1:
      block_order.reverse()
    for i in range(maxlen):
      for idx in block_order:
        blk = blocks[idx]
        if i < len(blk):
          micro.append(blk[i])

    # Deterministic connectors across windows (fractional-span analog of KT caps)
    micro_connectors = [
      (glo + int(round(0.08 * G)), glo + int(round(0.30 * G))),
      (glo + int(round(0.60 * G)), glo + int(round(0.92 * G))),
      (glo + int(round(0.26 * G)), glo + int(round(0.56 * G))),
      (glo + int(round(0.44 * G)), glo + int(round(0.78 * G))),
    ]
    # Optional longer-range cross4 connector for alternate micro-phase
    if alt:
      micro_connectors.append((glo + int(round(0.18 * G)), glo + int(round(0.84 * G))))
    for a, b in micro_connectors:
      if b > a:
        micro.append((a, b))

    # Trim to budget
    if len(micro) > budget:
      micro = micro[:budget]
    return micro
=======
  def build_micro_delta_round(current_T, budget, iter_id=0, alt=False):
    if not current_T or budget <= 8:
      return []

    glo = min(l for l, r in current_T)
    ghi = max(r for l, r in current_T)
    G = max(1, ghi - glo)

    # Seed construction: slightly larger for alternate pass to increase coupling
    seed_sz = max(8, min(40, len(current_T) // 250))
    stride = max(1, len(current_T) // max(1, seed_sz))
    U = [current_T[i] for i in range(0, len(current_T), stride)][:seed_sz]
    if not U:
      return []

    ulo = min(l for l, r in U)

    # Window sets: primary (A) and alternate (B)
    if not alt:
      shift = (iter_id % 3) * 0.02
      window_fracs = [
        (0.12 + shift, 0.22 + shift),
        (0.35 + shift, 0.45 + shift),
        (0.58 + shift, 0.68 + shift),
        (0.80 + shift, 0.90 + shift),
      ]
      window_fracs = [
        (max(0.05, min(0.90, a)), max(0.10, min(0.95, b)))
        for (a, b) in window_fracs
      ]
    else:
      window_fracs = [(0.05, 0.15), (0.28, 0.38), (0.60, 0.70), (0.82, 0.92)]

    # Guarded blocker ladder: short staggered pins to occupy small colors early
    blockers = []
    for w_idx, (fa, fb) in enumerate(window_fracs):
      w_lo = glo + int(round(fa * G))
      w_hi = glo + int(round(fb * G))
      width = max(4, w_hi - w_lo)
      pin_len = max(2, width // 6)            # short but persistent within the window
      step = max(1, pin_len - 1)              # slight overlap, keeps per-point overlap small
      P = max(4, min(10, width // max(1, pin_len)))  # 4..10 pins per window
      phase = (w_idx % 2) * (pin_len // 2)    # parity shift to avoid accidental stacking
      for i in range(P):
        L = w_lo + (i * (width - pin_len)) // max(1, (P - 1)) + phase
        R = min(w_hi, L + pin_len)
        if R > L:
          blockers.append((L, R))

    # Build translated micro-blocks aligned to these windows
    blocks = []
    for (fa, fb) in window_fracs:
      win_lo = glo + int(round(fa * G))
      base = win_lo - ulo
      block = [(l + base, r + base) for (l, r) in U]
      # Alternate internal reversal by block to break symmetry
      tag = iter_id if not alt else (iter_id + 1)
      if ((int(round(fa * 100)) // 5) + tag) % 2 == 1:
        block = list(reversed(block))
      blocks.append(block)

    # Interleave micro-blocks (forward on even tag, reverse on odd tag)
    micro_seq = []
    maxlen = max(len(b) for b in blocks)
    block_order = list(range(len(blocks)))
    tag = iter_id if not alt else (iter_id + 1)
    if tag % 2 == 1:
      block_order.reverse()
    for i in range(maxlen):
      for idx in block_order:
        blk = blocks[idx]
        if i < len(blk):
          micro_seq.append(blk[i])

    # Begin with blockers to freeze small colors, then the micro sequence
    micro = blockers + micro_seq

    # Deterministic connectors across windows (fractional-span analog of KT caps)
    micro_connectors = [
      (glo + int(round(0.08 * G)), glo + int(round(0.30 * G))),
      (glo + int(round(0.60 * G)), glo + int(round(0.92 * G))),
      (glo + int(round(0.26 * G)), glo + int(round(0.56 * G))),
      (glo + int(round(0.44 * G)), glo + int(round(0.78 * G))),
    ]
    # Optional longer-range cross4 connector for alternate micro-phase
    if alt:
      micro_connectors.append((glo + int(round(0.18 * G)), glo + int(round(0.84 * G))))
    for a, b in micro_connectors:
      if b > a:
        micro.append((a, b))

    # Trim to budget
    if len(micro) > budget:
      micro = micro[:budget]
    return micro
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
  # Secondary micro-phase with distinct windows to capture missed interactions
  room = CAP - len(T)
  if room > 8:
    microB = build_micro_delta_round(T, room, iter_id=steps, alt=True)
    if microB:
      avail = CAP - len(T)
      if len(microB) > avail:
        microB = microB[:avail]
      T.extend(microB)

  # Optional parabolic micro-phase for extra diversity (lightweight)
  if enable_parabolic:
    room = CAP - len(T)
    if room > 0:
      lo = min(l for l, r in T)
      hi = max(r for l, r in T)
      delta = hi - lo if hi > lo else 1
      cap1 = (lo + max(1, int(round(0.15 * delta))), lo + max(1, int(round(0.60 * delta))))
      cap2 = (lo + max(1, int(round(0.25 * delta))), lo + max(1, int(round(0.80 * delta))))
      cap3 = (lo + max(1, int(round(0.55 * delta))), lo + max(1, int(round(0.95 * delta))))
      parabolic = [cap for cap in (cap1, cap2, cap3) if cap[1] > cap[0]]
      if parabolic:
        if len(parabolic) > room:
          parabolic = parabolic[:room]
        T.extend(parabolic)
=======
  # Secondary micro-phase with distinct windows to capture missed interactions
  # Reserve a tiny budget for global cross connectors to be added afterward.
  RESERVE = 2
  room = max(0, CAP - len(T) - RESERVE)
  if room > 8:
    microB = build_micro_delta_round(T, room, iter_id=steps, alt=True)
    if microB:
      avail = CAP - len(T)
      if len(microB) > avail:
        microB = microB[:avail]
      T.extend(microB)

  # Lightweight global cross connectors to tie distant regions without inflating omega
  room = CAP - len(T)
  if room > 0 and T:
    glo = min(l for l, r in T)
    ghi = max(r for l, r in T)
    G = max(1, ghi - glo)
    cross4s = [
      (glo + int(round(0.11 * G)), glo + int(round(0.89 * G))),
      (glo + int(round(0.27 * G)), glo + int(round(0.73 * G))),
    ]
    for iv in cross4s:
      if room == 0:
        break
      a, b = iv
      if b > a:
        T.append(iv)
        room -= 1

  # Optional parabolic micro-phase for extra diversity (lightweight)
  if enable_parabolic:
    room = CAP - len(T)
    if room > 0:
      lo = min(l for l, r in T)
      hi = max(r for l, r in T)
      delta = hi - lo if hi > lo else 1
      cap1 = (lo + max(1, int(round(0.15 * delta))), lo + max(1, int(round(0.60 * delta))))
      cap2 = (lo + max(1, int(round(0.25 * delta))), lo + max(1, int(round(0.80 * delta))))
      cap3 = (lo + max(1, int(round(0.55 * delta))), lo + max(1, int(round(0.95 * delta))))
      parabolic = [cap for cap in (cap1, cap2, cap3) if cap[1] > cap[0]]
      if parabolic:
        if len(parabolic) > room:
          parabolic = parabolic[:room]
        T.extend(parabolic)
>>>>>>> REPLACE

</DIFF>