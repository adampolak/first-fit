--- a/original.py
+++ b/original.py
@@ -1,221 +1,227 @@
 # EVOLVE-BLOCK-START
 
 def construct_intervals(enable_parabolic=True):
   """
   Construct a sequence of intervals of real line,
   in the order in which they are presented to FirstFit,
   so that it maximizes the number of colors used by FirstFit
   divided by the maximum number of intervals that cover a single point
 
   The initial implementation uses the construction from
   Figure 4 in https://arxiv.org/abs/1506.00192
 
   Returns:
     intervals: list of tuples, each tuple (l, r) represents an open interval from l to r
   """
 
   # Capacity guard to keep total intervals < 10000
   CAP = 9800
 
   # Use the classic fixed start-pattern to preserve strong KT coupling
   starts = (2, 6, 10, 14)
   # Rotate among four strong templates and interleave on even rounds to raise FF pressure
   template_bank = [
     (2, 6, 10, 14),
     (1, 5, 9, 13),
     (3, 7, 11, 15),
     (4, 8, 12, 16),
   ]
   T = [(0, 1)]
   for round_idx in range(6):
     lo = min(l for l, r in T)
     hi = max(r for l, r in T)
     delta = hi - lo if hi > lo else 1
     # pick per-round starts
     starts_r = template_bank[round_idx % 4]
     # build translated blocks (interleave on even rounds)
     blocks = []
     for s in starts_r:
       blocks.append([(delta * s + l - lo, delta * s + r - lo) for l, r in T])
     S = []
     if round_idx % 2 == 0:
       maxlen = max(len(b) for b in blocks)
       for i in range(maxlen):
         for blk in blocks:
           if i < len(blk):
             S.append(blk[i])
     else:
       for blk in blocks:
         S.extend(blk)
     # connectors based on per-round starts
     s0, s1, s2, s3 = starts_r
     connectors = [
       (delta * (s0 - 1), delta * (s1 - 1)),  # left cap
       (delta * (s2 + 2), delta * (s3 + 2)),  # right cap
       (delta * (s0 + 2), delta * (s2 - 1)),  # cross 1
       (delta * (s1 + 2), delta * (s3 - 1)),  # cross 2
     ]
+    # add extra long-range cross connectors on even rounds to boost FF mixing
+    if round_idx % 2 == 0:
+      connectors += [
+        (delta * (s0 + 3), delta * (s3 + 3)),  # cross 3
+        (delta * (s0 + 4), delta * (s3 + 4)),  # cross 4
+      ]
     for a, b in connectors:
       S.append((a, b))
     T = S
   # Stage 2: Two delta2-driven micro extension rounds (thin sampling; four-start translations).
   # Skip if near capacity.
   if len(T) < CAP - 16:
     def thin_seed(current_T, max_seed):
       n = len(current_T)
       if n == 0 or max_seed <= 0:
         return []
       step = max(1, n // max_seed)
       return current_T[::step][:max_seed]
 
     def micro_round(current_T, round_id, budget, scale_div=2, starts_override=None):
       if budget <= 0 or not current_T:
         return []
       glo = min(l for l, r in current_T)
       ghi = max(r for l, r in current_T)
       G = max(1, ghi - glo)
       # Use reduced scale to avoid expanding the global span too aggressively
       delta2 = max(1, G // max(1, scale_div))
 
       # Thin seed: bounded and deterministic size to respect budget
       per_block_target = max(8, min(64, budget // 12))
       U = thin_seed(current_T, per_block_target)
       if not U:
         return []
 
       # Determine starts pattern
       use_starts = starts_override if starts_override is not None else starts
 
       # Build translated blocks using the use_starts template,
       # with deterministic parity-based internal reversal
       blocks = []
       ulo = min(l for l, r in U)
       for s in use_starts:
         base = s * delta2 - ulo
         block = [(l + base, r + base) for (l, r) in U]
         if ((s // 2) % 2) == (round_id % 2):
           block = list(reversed(block))
         blocks.append(block)
 
       micro = []
       # Parity-based interleaving across blocks
       maxlen = max(len(b) for b in blocks)
       if round_id % 2 == 0:
         for i in range(maxlen):
           for blk in blocks:
             if i < len(blk):
               micro.append(blk[i])
       else:
         for i in range(maxlen):
           for blk in reversed(blocks):
             if i < len(blk):
               micro.append(blk[i])
 
       # Deterministic connectors at delta2 scale, including a longer cross3 and cross4
       s0, s1, s2, s3 = use_starts
       connectors = [
         ((s0 - 1) * delta2 + glo, (s1 - 1) * delta2 + glo),  # left cap
         ((s2 + 2) * delta2 + glo, (s3 + 2) * delta2 + glo),  # right cap
         ((s0 + 2) * delta2 + glo, (s2 - 1) * delta2 + glo),  # cross 1
         ((s1 + 2) * delta2 + glo, (s3 - 1) * delta2 + glo),  # cross 2
         ((s0 + 3) * delta2 + glo, (s3 + 3) * delta2 + glo),  # cross3 (long range)
         ((s0 + 4) * delta2 + glo, (s3 + 4) * delta2 + glo),  # cross4 (extra fine coupler)
       ]
       micro.extend(connectors)
 
       # Sparse micro caps to press FirstFit locally without raising omega much
       cap1 = (glo + (delta2 // 4), glo + int(1.8 * delta2))
       cap2 = (glo + int(0.9 * delta2), glo + int(2.6 * delta2))
       mid = glo + G // 2
       cap3 = (mid - max(1, delta2 // 8), mid + max(1, delta2 // 8))
       for cap in (cap1, cap2, cap3):
         if cap[1] > cap[0]:
           micro.append(cap)
 
       # Enforce budget
       if len(micro) > budget:
         micro = micro[:budget]
       return micro
 
     remaining = CAP - len(T)
     mr1 = micro_round(T, round_id=0, budget=max(0, remaining // 2))
     if mr1:
       room = CAP - len(T)
       if len(mr1) > room:
         mr1 = mr1[:room]
       T.extend(mr1)
 
     remaining = CAP - len(T)
     mr2 = micro_round(T, round_id=1, budget=max(0, remaining))
     if mr2:
       room = CAP - len(T)
       if len(mr2) > room:
         mr2 = mr2[:room]
       T.extend(mr2)
 
     # Stage 3: Additional fine micro round at quarter-scale for extra FF pressure
     remaining = CAP - len(T)
     if remaining > 0:
       mr3 = micro_round(T, round_id=2, budget=remaining, scale_div=4, starts_override=(3,7,11,15))
       if mr3:
         room = CAP - len(T)
         if len(mr3) > room:
           mr3 = mr3[:room]
         T.extend(mr3)
 
     # Micro-phase W: four-window fractional placements with connectors to couple colors
     room = CAP - len(T)
     if room > 8:
       glo = min(l for l, r in T)
       ghi = max(r for l, r in T)
       G = max(1, ghi - glo)
       # thin seed
       seed_sz = max(8, min(32, len(T) // 300))
       stride = max(1, len(T) // max(1, seed_sz))
       U = [T[i] for i in range(0, len(T), stride)][:seed_sz]
       if U:
         ulo = min(l for l, r in U)
         window_fracs = [(0.12, 0.22), (0.35, 0.45), (0.58, 0.68), (0.80, 0.90)]
         micro_blocks = []
         for (fa, fb) in window_fracs:
           win_lo = glo + int(round(fa * G))
           base = win_lo - ulo
           block = [(l + base, r + base) for (l, r) in U]
           micro_blocks.append(block)
         microW = []
         maxlen = max(len(b) for b in micro_blocks) if micro_blocks else 0
         for i in range(maxlen):
           for blk in micro_blocks:
             if i < len(blk):
               microW.append(blk[i])
         micro_connectors = [
           (glo + int(round(0.08 * G)), glo + int(round(0.30 * G))),
           (glo + int(round(0.60 * G)), glo + int(round(0.92 * G))),
           (glo + int(round(0.26 * G)), glo + int(round(0.56 * G))),
           (glo + int(round(0.44 * G)), glo + int(round(0.78 * G))),
         ]
         for a, b in micro_connectors:
           if b > a:
             microW.append((a, b))
         if len(microW) > room:
           microW = microW[:room]
         T.extend(microW)
 
   return T
 
   # return [  # Figure 3, OPT=2, FF=4
   #   (2,3),
   #   (6,7),
   #   (10,11),
   #   (14,15),
   #   (1,5),
   #   (12,16),
   #   (4,9),
   #   (8,13),
   # ]
 
 # EVOLVE-BLOCK-END
 
 def run_experiment(**kwargs):
   """Main called by evaluator"""
   return construct_intervals()