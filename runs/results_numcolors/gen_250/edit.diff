--- a/original.py
+++ b/original.py
@@ -1,234 +1,347 @@
 # EVOLVE-BLOCK-START
 
 def construct_intervals(rounds=6,
                         rotate_starts=True,
                         reverse_block_parity=True,
                         interleave_blocks=True,
-                        phase2_iters=1):
+                        phase2_iters=2,
+                        seed_count=1):
   """
-  Deterministic KT-style spine with a rotating-template scaffold and a thin micro-phase.
+  Crossover construction combining KT-style spine + diversified multi-seed micro phases.
 
   Parameters:
-    rounds (int): main expansion depth; near 6 yields ~9556 intervals for a single-seed KT spine.
+    rounds (int): desired KT expansion depth (predictive cap may reduce actual rounds).
     rotate_starts (bool): rotate among strong start templates when True.
-    reverse_block_parity (bool): if True, flips even/odd interleaving parity each round.
-    interleave_blocks (bool): enable interleaving on selected rounds.
-    phase2_iters (int): micro-round iterations (safeguarded to at most two and budget-limited).
+    reverse_block_parity (bool): flip block order parity to diversify arrival order.
+    interleave_blocks (bool): allow interleaving of translated blocks on selected rounds.
+    phase2_iters (int): up to two delta-scale micro rounds (CAP-guarded).
+    seed_count (int): optional small multi-seed (keeps early omega low but richer coupling).
 
   Returns:
-    intervals: list of (l, r) integer tuples, open intervals, in FF presentation order.
+    intervals: list of (l, r) integer tuples in FF presentation order.
   """
 
-  # Hard capacity guard to keep the total count < 10000
+  # Hard capacity guard to keep total count < 10000
   CAP = 9800
 
-  # Four strong start-pattern templates (rotated across rounds).
-  spine_starts = (2, 6, 10, 14)
+  # Template bank for KT-like rounds (rotated)
   template_bank = [
     (2, 6, 10, 14),  # classic KT
-    (1, 5, 9, 13),   # left-shifted
-    (3, 7, 11, 15),  # right-shifted
+    (1, 5, 9, 13),   # left-shift
+    (3, 7, 11, 15),  # right-shift
     (4, 8, 12, 16),  # stretched-right
   ]
 
-  # Seed with one unit interval to allow six KT rounds within CAP.
-  T = [(0, 1)]
-
-  # Predictive size accounting to cap the number of full rounds.
-  # KT growth per round: size -> 4*size + 4
-  def round_next_size(sz):
-    return 4 * sz + 4
-
-  def max_rounds_within_cap(initial_size, max_rounds):
-    sz = initial_size
-    done = 0
-    for _ in range(max(0, int(max_rounds))):
-      nxt = round_next_size(sz)
-      if nxt > CAP:
-        break
-      sz = nxt
-      done += 1
-    return done, sz
-
+  # Secondary small connector bank (diversified templates used by the light-bridge rounds)
+  connector_bank = [
+    ((1, 5), (12, 16), (4, 9), (8, 13)),
+    ((0, 4), (11, 15), (3, 8), (7, 12)),
+    ((1, 4), (6, 9), (3, 7), (9, 13)),
+    ((2, 6), (7, 11), (0, 3), (10, 14)),
+  ]
+
+  # Seed initialization: either single unit interval (classic KT) or a few sparse seeds
+  if seed_count <= 1:
+    T = [(0, 1)]
+  else:
+    # deterministic sparse multi-seed, limit to avoid early clique blow-up
+    seeds = min(4, max(1, int(seed_count)))
+    step = 3
+    T = [(i * step, i * step + 1) for i in range(seeds)]
+
+  # Utility: compute span and guard minimal delta
   def _span_delta(current_T):
     lo = min(l for l, r in current_T)
     hi = max(r for l, r in current_T)
     delta = hi - lo
     if delta <= 0:
       delta = 1
-    return lo, hi, delta
-
-  def _append_connectors(S, starts, delta):
-    # Classic four connectors; preserves strong FF pressure while keeping omega modest.
+    return lo, hi, int(delta)
+
+  # Classic KT connectors (scale-preserving integer endpoints)
+  def _append_kt_connectors(S, starts, delta, lo):
     s0, s1, s2, s3 = starts
-    S.append(((s0 - 1) * delta, (s1 - 1) * delta))  # left cap
-    S.append(((s2 + 2) * delta, (s3 + 2) * delta))  # right cap
-    S.append(((s0 + 2) * delta, (s2 - 1) * delta))  # cross 1
-    S.append(((s1 + 2) * delta, (s3 - 1) * delta))  # cross 2
-
-  def apply_round(current_T, starts, do_interleave=False, reverse_order=False):
+    # scale by delta and shift by lo to keep integer coordinates consistent
+    S.append(((s0 - 1) * delta + lo, (s1 - 1) * delta + lo))  # left cap
+    S.append(((s2 + 2) * delta + lo, (s3 + 2) * delta + lo))  # right cap
+    S.append(((s0 + 2) * delta + lo, (s2 - 1) * delta + lo))  # cross 1
+    S.append(((s1 + 2) * delta + lo, (s3 - 1) * delta + lo))  # cross 2
+
+  # Apply one KT-style round: translate blocks, optionally interleave/reverse, append connectors
+  def _apply_kt_round(current_T, starts, do_interleave=False, reverse_order=False):
     lo, hi, delta = _span_delta(current_T)
 
-    # Build four translated blocks
+    # Build four translated blocks (integer arithmetic)
     blocks = []
     for s in starts:
-      base = s * delta - lo
-      block = [(l + base, r + base) for (l, r) in current_T]
+      base_off = s * delta - lo
+      block = [(l + base_off, r + base_off) for (l, r) in current_T]
       blocks.append(block)
 
-    # Build S either interleaving or sequential
     S = []
     if do_interleave:
-      maxlen = max(len(b) for b in blocks)
       order = list(range(4))
       if reverse_order:
         order.reverse()
+      maxlen = max(len(b) for b in blocks)
       for i in range(maxlen):
         for idx in order:
           blk = blocks[idx]
           if i < len(blk):
             S.append(blk[i])
     else:
       if reverse_order:
         blocks = list(reversed(blocks))
       for blk in blocks:
         S.extend(blk)
 
-    # Append classic connectors
-    _append_connectors(S, starts, delta)
+    _append_kt_connectors(S, starts, delta, lo)
     return S
 
-  # Stage 1: KT spine with rotating templates and parity-based interleaving.
-  depth, _ = max_rounds_within_cap(len(T), rounds)
+  # Predictive bound: KT growth per round is size -> 4*size + 4
+  def _max_rounds_within_cap(initial_size, max_rounds):
+    sz = initial_size
+    done = 0
+    for _ in range(max(0, int(max_rounds))):
+      nxt = 4 * sz + 4
+      if nxt > CAP:
+        break
+      sz = nxt
+      done += 1
+    return done, sz
+
+  # Stage 1: KT spine with rotating templates and parity-based interleaving
+  depth, _ = _max_rounds_within_cap(len(T), rounds)
   for ridx in range(depth):
-    starts = template_bank[ridx % len(template_bank)] if rotate_starts else spine_starts
-    # Even/odd interleaving policy; optionally reverse block order each round.
+    starts = template_bank[ridx % len(template_bank)] if rotate_starts else template_bank[0]
     do_inter = bool(interleave_blocks and (ridx % 2 == 0))
     rev = bool(reverse_block_parity and (ridx % 2 == 1))
-    T = apply_round(T, starts, do_interleave=do_inter, reverse_order=rev)
-
-  # If we are close to capacity, return the strong baseline.
-  if len(T) >= CAP - 8:
-    return T
-
-  # Micro-phase A: insert a tiny tail of long caps near the end to boost FF mixing.
-  def _insert_near_tail(seq, intervals):
-    out = list(seq)
-    for i, iv in enumerate(intervals):
-      pos = len(out) - (i * 2 + 1)
-      if pos < 0:
-        out.append(iv)
-      else:
-        out.insert(pos, iv)
-    return out
-
-  lo, hi, delta = _span_delta(T)
-  # Long caps positioned as fractions of the current span; ensure monotone endpoints.
-  def cap_at(a_frac, b_frac):
+    T = _apply_kt_round(T, starts, do_interleave=do_inter, reverse_order=rev)
+    if len(T) >= CAP:
+      return T[:CAP]
+
+  # If nearly at capacity return baseline
+  if len(T) >= CAP - 16:
+    return T[:CAP]
+
+  # Insert a few long-range caps near the tail (helps mixing late FF colors without raising omega much)
+  def _cap_at(lo, delta, a_frac, b_frac):
     L = lo + max(1, int(round(a_frac * delta)))
     R = lo + max(1, int(round(b_frac * delta)))
     if R <= L:
       R = L + 1
     return (L, R)
-  caps = [cap_at(0.08, 0.60), cap_at(0.25, 0.75), cap_at(0.75, 0.92)]
-  # Capacity-guarded insertion
+
+  lo, hi, delta = _span_delta(T)
+  tail_caps = [
+    _cap_at(lo, delta, 0.08, 0.60),
+    _cap_at(lo, delta, 0.25, 0.75),
+    _cap_at(lo, delta, 0.75, 0.92)
+  ]
+  # Insert compactly near the tail (but capacity-guarded)
   room = CAP - len(T)
   if room > 0:
-    T = _insert_near_tail(T, caps[:room])
-
-  if len(T) >= CAP - 16:
-    return T
-
-  # Stage 2: delta2-driven micro rounds using thin evenly-spaced seeds.
-  def build_micro_delta_round(current_T, budget, iter_id=0):
+    for cap in tail_caps[:room]:
+      T.append(cap)
+
+  if len(T) >= CAP - 12:
+    return T[:CAP]
+
+  # Stage 2: delta-scale micro rounds - derive a thin seed and place translated micro-blocks in windows
+  def _thin_seed(current_T, max_seed):
+    n = len(current_T)
+    if n == 0 or max_seed <= 0:
+      return []
+    step = max(1, n // max_seed)
+    U = current_T[::step][:max_seed]
+    return U
+
+  def _build_delta_micro(current_T, budget, iter_id=0, alt=False):
     if not current_T or budget <= 8:
       return []
 
     glo = min(l for l, r in current_T)
     ghi = max(r for l, r in current_T)
     G = max(1, ghi - glo)
 
-    # Thin seed from current_T, evenly spaced.
-    seed_sz = max(8, min(32, len(current_T) // 300))
-    stride = max(1, len(current_T) // max(1, seed_sz))
-    U = [current_T[i] for i in range(0, len(current_T), stride)][:seed_sz]
+    # seed size chosen small to keep omega low
+    base_seed = max(8, min(36, len(current_T) // 250))
+    seed_sz = base_seed if not alt else max(8, min(40, len(current_T) // 220))
+    U = _thin_seed(current_T, seed_sz)
     if not U:
       return []
 
     ulo = min(l for l, r in U)
 
-    # Slightly shift the window positions across iterations for diversification.
-    shift = (iter_id % 3) * 0.02
-    window_fracs = [
-      (0.12 + shift, 0.22 + shift),
-      (0.35 + shift, 0.45 + shift),
-      (0.58 + shift, 0.68 + shift),
-      (0.80 + shift, 0.90 + shift),
-    ]
-    # Clamp windows inside (0.05, 0.95)
-    window_fracs = [
-      (max(0.05, min(0.90, a)), max(0.10, min(0.95, b)))
-      for (a, b) in window_fracs
-    ]
-
-    # Build translated micro-blocks aligned to these windows
+    # windows: primary ones slightly shifted by iter_id; alternate windows distinct
+    if not alt:
+      shift = (iter_id % 3) * 0.02
+      window_fracs = [
+        (0.12 + shift, 0.22 + shift),
+        (0.35 + shift, 0.45 + shift),
+        (0.58 + shift, 0.68 + shift),
+        (0.80 + shift, 0.90 + shift),
+      ]
+      # clamp
+      window_fracs = [(max(0.05, min(0.90, a)), max(0.10, min(0.95, b))) for (a, b) in window_fracs]
+    else:
+      window_fracs = [(0.05, 0.15), (0.28, 0.38), (0.60, 0.70), (0.82, 0.92)]
+
     blocks = []
     for (fa, fb) in window_fracs:
       win_lo = glo + int(round(fa * G))
-      base = win_lo - ulo
-      block = [(l + base, r + base) for (l, r) in U]
-      # Alternate internal reversal by block to break symmetry
-      if ((int(round(fa * 100)) // 5) + iter_id) % 2 == 1:
+      base_off = win_lo - ulo
+      block = [(l + base_off, r + base_off) for (l, r) in U]
+      # parity-breaking reversal to diversify arrivals
+      tag = iter_id + (1 if alt else 0)
+      if ((int(round(fa * 100)) // 5) + tag) % 2 == 1:
         block = list(reversed(block))
       blocks.append(block)
 
-    # Interleave micro-blocks (forward on even iter, reverse on odd iter)
+    # Interleave micro-blocks with block order varying by iter_id
     micro = []
+    block_order = list(range(len(blocks)))
+    if (iter_id % 2) == 1:
+      block_order.reverse()
     maxlen = max(len(b) for b in blocks)
-    block_order = list(range(len(blocks)))
-    if iter_id % 2 == 1:
-      block_order.reverse()
     for i in range(maxlen):
       for idx in block_order:
         blk = blocks[idx]
         if i < len(blk):
           micro.append(blk[i])
 
-    # Deterministic connectors across windows (fractional-span analog of KT caps)
+    # Deterministic fractional connectors on micro-scale (keep them short relative to G)
     micro_connectors = [
-      (glo + int(round(0.08 * G)), glo + int(round(0.30 * G))),  # left cap
-      (glo + int(round(0.60 * G)), glo + int(round(0.92 * G))),  # right cap
-      (glo + int(round(0.26 * G)), glo + int(round(0.56 * G))),  # cross 1
-      (glo + int(round(0.44 * G)), glo + int(round(0.78 * G))),  # cross 2
+      (glo + int(round(0.08 * G)), glo + int(round(0.30 * G))),
+      (glo + int(round(0.60 * G)), glo + int(round(0.92 * G))),
+      (glo + int(round(0.26 * G)), glo + int(round(0.56 * G))),
+      (glo + int(round(0.44 * G)), glo + int(round(0.78 * G))),
     ]
+    if alt:
+      micro_connectors.append((glo + int(round(0.18 * G)), glo + int(round(0.84 * G))))
+
     for a, b in micro_connectors:
       if b > a:
         micro.append((a, b))
 
-    # Trim to available budget
+    # trim to budget
     if len(micro) > budget:
       micro = micro[:budget]
     return micro
 
-  # Execute up to two micro-rounds, capacity-guarded
   steps = min(max(0, int(phase2_iters)), 2)
   for iter_id in range(steps):
     room = CAP - len(T)
     if room <= 8:
       break
-    micro = build_micro_delta_round(T, room, iter_id=iter_id)
+    micro = _build_delta_micro(T, room, iter_id=iter_id, alt=False)
     if not micro:
       break
-    # Capacity guard and append
-    avail = CAP - len(T)
-    if len(micro) > avail:
-      micro = micro[:avail]
+    if len(micro) > room:
+      micro = micro[:room]
     T.extend(micro)
 
+  # Secondary alternate micro-phase to capture missed interactions
+  room = CAP - len(T)
+  if room > 8:
+    microB = _build_delta_micro(T, room, iter_id=steps, alt=True)
+    if microB:
+      if len(microB) > room:
+        microB = microB[:room]
+      T.extend(microB)
+
+  if len(T) >= CAP - 8:
+    return T[:CAP]
+
+  # Stage 3: light-bridge round inspired by diversified design:
+  # use a small connector template, alternating block orders and short caps to press FF colors
+  lo, hi, delta = _span_delta(T)
+  if delta <= 0:
+    return T[:CAP]
+
+  # pick a connector template deterministically
+  template = connector_bank[0]
+  # adopt a small set of starts derived from the KT templates for diversity
+  start_patterns = [
+    (2, 6, 10, 14),
+    (1, 5, 9, 13),
+    (3, 7, 11, 15),
+    (2, 4, 8, 12),
+  ]
+  starts = start_patterns[0]
+
+  S = []
+  # Choose block order variant depending on parity of current size to diversify ordering
+  if len(T) % 3 == 0:
+    block_order = list(starts)
+  elif len(T) % 3 == 1:
+    block_order = list(reversed(starts))
+  else:
+    block_order = list(starts[1:]) + [starts[0]]
+
+  # build translated blocks (use small reversed sub-blocks occasionally)
+  for i, st in enumerate(block_order):
+    inner = T if ((len(T) + i) % 2 == 0) else list(reversed(T))
+    base_off = delta * st - lo
+    for (l, r) in inner:
+      S.append((l + base_off, r + base_off))
+    # add a tiny light-bridge interval tying this block to next (short to avoid omega growth)
+    if i + 1 < len(block_order):
+      nxt = block_order[i + 1]
+      bstart = delta * (st + 0.5) - lo
+      bend = delta * (nxt + 0.5) - lo
+      # make bridge extremely short and integerized
+      a = int(min(bstart, bend) + max(1, delta // 1000))
+      b = int(max(bstart, bend) - max(1, delta // 1000))
+      if b > a:
+        S.append((a, b))
+
+  # append small connector gadget (scaled)
+  for (a, b) in template:
+    A = int(round(a * delta))
+    B = int(round(b * delta))
+    if B > A:
+      S.append((lo + A, lo + B))
+
+  # add a few sparse short caps between translated blocks
+  max_st = max(starts)
+  step = max(2, int(max_st // 3))
+  for j in range(2, max_st, step):
+    a = int(lo + delta * (j - 0.4) + 1)
+    b = int(lo + delta * (j + 0.6) - 1)
+    if b > a:
+      S.append((a, b))
+
+  # Capacity guard and append
+  room = CAP - len(T)
+  if room > 0:
+    if len(S) > room:
+      S = S[:room]
+    T.extend(S)
+
+  # Final micro pins (optional, very short intervals to tie windows)
+  if len(T) < CAP - 4:
+    glo2 = min(l for l, r in T)
+    ghi2 = max(r for l, r in T)
+    G2 = max(1, ghi2 - glo2)
+    eps = max(1, G2 // 512)
+    pins = []
+    # create a few pins at fractional positions
+    for frac in (0.09, 0.27, 0.64, 0.83):
+      mid = glo2 + int(round(frac * G2))
+      pins.append((mid, mid + eps))
+    room = CAP - len(T)
+    if room > 0:
+      pins = pins[:room]
+      T.extend(pins)
+
+  # Final trim
+  if len(T) > CAP:
+    T = T[:CAP]
   return T
 
 # EVOLVE-BLOCK-END
 
 def run_experiment(**kwargs):
   """Main called by evaluator"""
   return construct_intervals()