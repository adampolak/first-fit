<NAME>
parity_cadence_three_micro_rounds
</NAME>

<DESCRIPTION>
I add a parity‑cadenced, three‑round micro phase that uses smaller, rotated-scale windows and a rotated start‑template bank to force FirstFit upward without densifying the maximum clique.

Key changes:
- Thin seed sampling now accepts an offset to desynchronize sampled indices across rounds, reducing repeated overlap patterns.
- Micro rounds use delta2 at smaller scales (rotated divisors [7, 6, 5]) instead of G//2, placing four translated micro blocks further apart across the global span. This mitigates clique growth while enabling more micro intervals.
- Rotate micro start templates across rounds: (2,6,10,14), (1,5,9,13), (3,7,11,15). Combined with forward/reverse interleaving, this broadens cross-block coupling patterns.
- Add short “ladder” connectors between adjacent micro blocks and two fringe caps; keep connectors sparse and spread out to avoid large cliques.
- Increase micro rounds from 2 to 3 with a budget cadence (1/3, then half of remaining, then all remaining), still guarded by CAP, to better utilize capacity for FF pressure.

These adjustments target higher FirstFit usage while preserving omega close to 10 by avoiding heavy overlap at any single point and using distributed windows and sparse connectors.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
  def thin_seed(current_T, max_seed):
    """Take a thin, evenly spaced sample of current_T of size <= max_seed."""
    n = len(current_T)
    if n == 0 or max_seed <= 0:
      return []
    step = max(1, n // max_seed)
    U = current_T[::step][:max_seed]
    return U
=======
  def thin_seed(current_T, max_seed, offset=0):
    """Take a thin, evenly spaced sample of current_T of size <= max_seed, with a round-dependent offset."""
    n = len(current_T)
    if n == 0 or max_seed <= 0:
      return []
    step = max(1, n // max_seed)
    start = offset % step
    U = current_T[start::step][:max_seed]
    return U
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
  def micro_round(current_T, round_id, budget):
    if budget <= 0 or not current_T:
      return []

    glo = min(l for l, r in current_T)
    ghi = max(r for l, r in current_T)
    G = max(1, ghi - glo)

    # Use delta2 at half-scale to avoid expanding the global span too aggressively.
    delta2 = max(1, G // 2)

    # Thin seed: bounded and deterministic size to respect budget
    # Keep micro blocks small: target at most ~ (budget//6) per block (four blocks + ~8 extras).
    per_block_target = max(8, min(64, budget // 12))
    U = thin_seed(current_T, per_block_target)

    if not U:
      return []

    # Build four translated blocks using the same 4-start template,
    # with deterministic parity-based interleaving policy:
    # - Rounds with round_id % 2 == 0: forward interleave
    # - Rounds with round_id % 2 == 1: reverse interleave
    starts = spine_starts
    blocks = []
    ulo = min(l for l, r in U)
    for s in starts:
      base = s * delta2 - ulo
      block = [(l + base, r + base) for (l, r) in U]
      # Add a tiny deterministic internal reversal to break symmetry every other block
      if ((s // 2) % 2) == (round_id % 2):
        block = list(reversed(block))
      blocks.append(block)

    micro = []
    if round_id % 2 == 0:
      # Forward interleave
      maxlen = max(len(b) for b in blocks)
      for i in range(maxlen):
        for blk in blocks:
          if i < len(blk):
            micro.append(blk[i])
    else:
      # Reverse interleave (swap block order)
      maxlen = max(len(b) for b in blocks)
      for i in range(maxlen):
        for blk in reversed(blocks):
          if i < len(blk):
            micro.append(blk[i])

    # Deterministic connectors at delta2 scale, including a cross3 extension
    s0, s1, s2, s3 = starts
    connectors = [
      ((s0 - 1) * delta2 + glo, (s1 - 1) * delta2 + glo),  # left cap (localized)
      ((s2 + 2) * delta2 + glo, (s3 + 2) * delta2 + glo),  # right cap
      ((s0 + 2) * delta2 + glo, (s2 - 1) * delta2 + glo),  # cross 1
      ((s1 + 2) * delta2 + glo, (s3 - 1) * delta2 + glo),  # cross 2
      ((s0 + 3) * delta2 + glo, (s3 + 3) * delta2 + glo),  # cross3 (longer range)
    ]
    micro.extend(connectors)

    # Sparse micro caps: add three long but safe caps at half-scale
    cap1 = (glo + (delta2 // 4), glo + int(1.8 * delta2))
    cap2 = (glo + int(0.9 * delta2), glo + int(2.6 * delta2))
    mid = glo + G // 2
    cap3 = (mid - max(1, delta2 // 8), mid + max(1, delta2 // 8))
    for cap in (cap1, cap2, cap3):
      if cap[1] > cap[0]:
        micro.append(cap)

    # Enforce budget
    if len(micro) > budget:
      micro = micro[:budget]
    return micro
=======
  def micro_round(current_T, round_id, budget):
    if budget <= 0 or not current_T:
      return []

    glo = min(l for l, r in current_T)
    ghi = max(r for l, r in current_T)
    G = max(1, ghi - glo)

    # Rotate delta2 scale to spread micro blocks without densifying any single point
    divs = [7, 6, 5]
    delta2 = max(1, G // divs[round_id % len(divs)])

    # Thin seed: bounded and deterministic size to respect budget, desynchronized by round_id
    # Keep micro blocks modest: target at most ~ (budget//8) per block (four blocks + sparse extras).
    per_block_target = max(12, min(96, budget // 16))
    U = thin_seed(current_T, per_block_target, offset=round_id)

    if not U:
      return []

    # Build four translated blocks using a rotated start-template bank,
    # with deterministic parity-based interleaving policy:
    # - round_id % 2 == 0: forward interleave
    # - round_id % 2 == 1: reverse interleave
    micro_starts_bank = [
      (2, 6, 10, 14),
      (1, 5, 9, 13),
      (3, 7, 11, 15),
    ]
    starts = micro_starts_bank[round_id % len(micro_starts_bank)]
    blocks = []
    ulo = min(l for l, r in U)
    for s in starts:
      base = s * delta2 - ulo
      block = [(l + base, r + base) for (l, r) in U]
      # Internal reversal on a parity rule to break symmetry across blocks
      if ((s // 2) % 2) == (round_id % 2):
        block = list(reversed(block))
      blocks.append(block)

    micro = []
    maxlen = max(len(b) for b in blocks)
    if round_id % 2 == 0:
      # Forward interleave
      for i in range(maxlen):
        for blk in blocks:
          if i < len(blk):
            micro.append(blk[i])
    else:
      # Reverse interleave (swap block order)
      for i in range(maxlen):
        for blk in reversed(blocks):
          if i < len(blk):
            micro.append(blk[i])

    # Deterministic connectors at delta2 scale
    s0, s1, s2, s3 = starts
    connectors = [
      ((s0 - 1) * delta2 + glo, (s1 - 1) * delta2 + glo),  # left cap (localized)
      ((s2 + 2) * delta2 + glo, (s3 + 2) * delta2 + glo),  # right cap
      ((s0 + 2) * delta2 + glo, (s2 - 1) * delta2 + glo),  # cross 1
      ((s1 + 2) * delta2 + glo, (s3 - 1) * delta2 + glo),  # cross 2
      ((s0 + 3) * delta2 + glo, (s3 + 3) * delta2 + glo),  # cross3 (long-range, sparse)
    ]
    micro.extend(connectors)

    # Ladder connectors between adjacent blocks to propagate colors across layers without densifying a single point
    ladders = [
      ((s0 + 1) * delta2 + glo, (s1 + 0) * delta2 + glo),
      ((s1 + 1) * delta2 + glo, (s2 + 0) * delta2 + glo),
      ((s2 + 1) * delta2 + glo, (s3 + 0) * delta2 + glo),
    ]
    micro.extend(ladders)

    # Sparse fringe caps to increase FF pressure at the tails (avoid core densification)
    fr1 = (glo + int(0.06 * G), glo + int(0.22 * G))
    fr2 = (glo + int(0.78 * G), glo + int(0.94 * G))
    # Mid micro cap with tight width to limit clique impact
    mid = glo + G // 2
    cap_mid = (mid - max(1, delta2 // 10), mid + max(1, delta2 // 10))
    for cap in (fr1, fr2, cap_mid):
      if cap[1] > cap[0]:
        micro.append(cap)

    # Enforce budget
    if len(micro) > budget:
      micro = micro[:budget]
    return micro
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
  # Execute two micro rounds with strong guards
  remaining = CAP - len(T)
  mr1 = micro_round(T, round_id=0, budget=max(0, remaining // 2))
  if mr1:
    room = CAP - len(T)
    if len(mr1) > room:
      mr1 = mr1[:room]
    T.extend(mr1)

  remaining = CAP - len(T)
  mr2 = micro_round(T, round_id=1, budget=max(0, remaining))
  if mr2:
    room = CAP - len(T)
    if len(mr2) > room:
      mr2 = mr2[:room]
    T.extend(mr2)
=======
  # Execute three micro rounds with parity cadence and strict capacity guards
  remaining = CAP - len(T)
  mr1 = micro_round(T, round_id=0, budget=max(0, remaining // 3))
  if mr1:
    room = CAP - len(T)
    if len(mr1) > room:
      mr1 = mr1[:room]
    T.extend(mr1)

  remaining = CAP - len(T)
  mr2 = micro_round(T, round_id=1, budget=max(0, remaining // 2))
  if mr2:
    room = CAP - len(T)
    if len(mr2) > room:
      mr2 = mr2[:room]
    T.extend(mr2)

  remaining = CAP - len(T)
  mr3 = micro_round(T, round_id=2, budget=max(0, remaining))
  if mr3:
    room = CAP - len(T)
    if len(mr3) > room:
      mr3 = mr3[:room]
    T.extend(mr3)
>>>>>>> REPLACE
</DIFF>