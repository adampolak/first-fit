--- a/original.py
+++ b/original.py
@@ -1,347 +1,355 @@
 # EVOLVE-BLOCK-START
 
 def construct_intervals(seed_count=1):
   """
   Construct a sequence of intervals on the real line, in the order presented to FirstFit,
-  engineered to drive up FirstFit's color usage while keeping the maximum clique (omega) <= ~10.
-
-  Interface compatibility:
-    - Accepts seed_count (unused by evaluator, but supported).
-    - Returns a list of (l, r) integer tuples with r > l (open intervals).
+  engineered to drive up FirstFit's color usage while keeping the maximum clique (omega) ~<= 10.
+
+  Interface:
+    - seed_count (optional, supported)
+    - returns a list of (l, r) integer tuples with r > l (open intervals)
   """
   CAP = 9800
 
   # Rotating start templates (Kiersteadâ€“Trotter style)
   template_bank = [
     (2, 6, 10, 14),  # classic KT
     (1, 5, 9, 13),   # left-shifted
     (3, 7, 11, 15),  # right-shifted
     (4, 8, 12, 16),  # stretched-right
   ]
 
-  # Seed: single unit interval (multi-seed support capped defensively)
+  # Seed: single unit interval by default; support for multiple disjoint seeds
   if seed_count <= 1:
     T = [(0, 1)]
   else:
+    seeds = max(1, min(4, int(seed_count)))
     step = 3
-    seeds = min(4, max(1, int(seed_count)))
     T = [(i * step, i * step + 1) for i in range(seeds)]
 
+  # Helpers
   def _span_delta(current_T):
     lo = min(l for l, r in current_T)
     hi = max(r for l, r in current_T)
     delta = hi - lo
     if delta <= 0:
       delta = 1
     return lo, hi, delta
 
   def _append_connectors(S, starts, delta):
     # Four classic connectors that propagate color pressure without large omega jumps
     s0, s1, s2, s3 = starts
     S.append(((s0 - 1) * delta, (s1 - 1) * delta))  # left cap
     S.append(((s2 + 2) * delta, (s3 + 2) * delta))  # right cap
     S.append(((s0 + 2) * delta, (s2 - 1) * delta))  # cross 1
     S.append(((s1 + 2) * delta, (s3 - 1) * delta))  # cross 2
 
   def _apply_round(current_T, starts, do_interleave=False, reverse_order=False):
     lo, hi, delta = _span_delta(current_T)
 
     # Build four translated blocks
     blocks = []
     for s in starts:
       base = s * delta - lo
       block = [(l + base, r + base) for (l, r) in current_T]
       blocks.append(block)
 
-    # Compose S with chosen policy
+    # Compose S with policy
     S = []
     if do_interleave:
       order = list(range(4))
       if reverse_order:
         order.reverse()
       maxlen = max(len(b) for b in blocks)
       for i in range(maxlen):
         for idx in order:
           blk = blocks[idx]
           if i < len(blk):
             S.append(blk[i])
     else:
       seq_blocks = list(reversed(blocks)) if reverse_order else blocks
       for blk in seq_blocks:
         S.extend(blk)
 
     _append_connectors(S, starts, delta)
     return S
 
-  # Stage 1: Six KT-style rounds with parity-based interleaving
+  # Stage 1: Six KT-style rounds with parity-based interleaving and a mid-spine splice
   for ridx in range(6):
     starts = template_bank[ridx % len(template_bank)]
     do_interleave = (ridx % 2 == 0)          # even: interleave
     reverse_order = (ridx % 2 == 1)          # odd: reverse sequential
     T = _apply_round(T, starts, do_interleave=do_interleave, reverse_order=reverse_order)
     if len(T) >= CAP:
       return T[:CAP]
+
+    # Mid-spine splice after the 3rd round: insert a few localized connectors at half-scale
+    # to couple colors across the current spine without expanding span or omega much.
+    if ridx == 2 and len(T) < CAP - 8:
+      lo, hi, delta = _span_delta(T)
+      d2 = max(1, delta // 2)
+      s0, s1, s2, s3 = starts
+      splice = [
+        ((s0 - 1) * d2 + lo, (s1 - 1) * d2 + lo),  # localized left cap
+        ((s2 + 2) * d2 + lo, (s3 + 2) * d2 + lo),  # localized right cap
+        ((s0 + 2) * d2 + lo, (s2 - 1) * d2 + lo),  # localized cross 1
+      ]
+      # Insert near tail to avoid disturbing early structure
+      for i, iv in enumerate(splice):
+        pos = len(T) - (i * 3 + 1)
+        if pos < 0:
+          T.append(iv)
+        else:
+          T.insert(pos, iv)
+      if len(T) >= CAP:
+        return T[:CAP]
 
   # Micro-phase A: a few long caps near the global span to mix late colors
   if len(T) < CAP - 8:
     lo, hi, delta = _span_delta(T)
     def cap_at(a_frac, b_frac):
       L = lo + max(1, int(round(a_frac * delta)))
       R = lo + max(1, int(round(b_frac * delta)))
       if R <= L:
         R = L + 1
       return (L, R)
     caps = [cap_at(0.08, 0.60), cap_at(0.25, 0.75), cap_at(0.75, 0.92)]
     room = CAP - len(T)
     if room > 0:
       caps = caps[:room]
-      # Insert near the tail to avoid disrupting early structure
       for i, iv in enumerate(caps):
         pos = len(T) - (i * 2 + 1)
         if pos < 0:
           T.append(iv)
         else:
           T.insert(pos, iv)
 
   if len(T) >= CAP - 16:
     return T[:CAP]
 
   # Helper: thin evenly-spaced seed from T
   def _thin_seed(current_T, max_seed):
     n = len(current_T)
     if n == 0 or max_seed <= 0:
       return []
     step = max(1, n // max_seed)
     return current_T[::step][:max_seed]
 
   # Stage 2: delta2-driven micro rounds using thin evenly-spaced seeds
   def _build_micro_delta_round(current_T, budget, iter_id=0, alt=False):
     if not current_T or budget <= 8:
       return []
 
     glo = min(l for l, r in current_T)
     ghi = max(r for l, r in current_T)
     G = max(1, ghi - glo)
 
     # Thin seed (slightly larger for alt to strengthen mixing)
     base_seed = max(8, min(32, len(current_T) // 300))
-    seed_sz = base_seed if not alt else max(8, min(40, len(current_T) // 250))
+    seed_sz = base_seed if not alt else max(10, min(40, len(current_T) // 250))
     U = _thin_seed(current_T, seed_sz)
     if not U:
       return []
 
     ulo = min(l for l, r in U)
 
     # Windows with small shifts on primary; distinct family on alt
     if not alt:
       shift = (iter_id % 3) * 0.02
       window_fracs = [
         (0.12 + shift, 0.22 + shift),
         (0.35 + shift, 0.45 + shift),
         (0.58 + shift, 0.68 + shift),
         (0.80 + shift, 0.90 + shift),
       ]
       window_fracs = [(max(0.05, min(0.90, a)), max(0.10, min(0.95, b))) for (a, b) in window_fracs]
     else:
       window_fracs = [(0.05, 0.15), (0.28, 0.38), (0.60, 0.70), (0.82, 0.92)]
 
     blocks = []
     for (fa, fb) in window_fracs:
       win_lo = glo + int(round(fa * G))
       base = win_lo - ulo
       block = [(l + base, r + base) for (l, r) in U]
       tag = iter_id if not alt else (iter_id + 1)
       # Parity-breaking reversal to reduce symmetry
       if ((int(round(fa * 100)) // 5) + tag) % 2 == 1:
         block = list(reversed(block))
       blocks.append(block)
 
     # Interleave policy depends on tag parity
     micro = []
     tag = iter_id if not alt else (iter_id + 1)
     order = list(range(len(blocks)))
     if tag % 2 == 1:
       order.reverse()
     maxlen = max(len(b) for b in blocks)
     for i in range(maxlen):
       for idx in order:
         blk = blocks[idx]
         if i < len(blk):
           micro.append(blk[i])
 
     # Fractional-span connectors (KT analog) + long-range cross on alt
     micro_connectors = [
       (glo + int(round(0.08 * G)), glo + int(round(0.30 * G))),
       (glo + int(round(0.60 * G)), glo + int(round(0.92 * G))),
       (glo + int(round(0.26 * G)), glo + int(round(0.56 * G))),
       (glo + int(round(0.44 * G)), glo + int(round(0.78 * G))),
     ]
     if alt:
       micro_connectors.append((glo + int(round(0.18 * G)), glo + int(round(0.84 * G))))
     for a, b in micro_connectors:
       if b > a:
         micro.append((a, b))
 
     if len(micro) > budget:
       micro = micro[:budget]
     return micro
 
   # Execute two primary micro rounds, then one alt round (capacity-guarded)
   for iter_id in range(2):
     room = CAP - len(T)
     if room <= 8:
       break
     micro = _build_micro_delta_round(T, room, iter_id=iter_id, alt=False)
     if not micro:
       break
-    if len(micro) > room:
-      micro = micro[:room]
-    T.extend(micro)
+    T.extend(micro[:room])
 
   room = CAP - len(T)
   if room > 8:
     micro_alt = _build_micro_delta_round(T, room, iter_id=2, alt=True)
     if micro_alt:
-      avail = CAP - len(T)
-      if len(micro_alt) > avail:
-        micro_alt = micro_alt[:avail]
-      T.extend(micro_alt)
+      T.extend(micro_alt[:CAP - len(T)])
 
   # Stage 3: pin-shrinking micro-phase (controls omega via short intervals)
   if len(T) < CAP - 8:
     glo2 = min(l for l, r in T)
     ghi2 = max(r for l, r in T)
     G2 = max(1, ghi2 - glo2)
     seed_sz2 = max(8, min(24, len(T) // 400))
     U2 = _thin_seed(T, seed_sz2)
     if U2:
       ulo2 = min(l for l, r in U2)
       eps = max(1, G2 // 512)
       windows2 = [(0.05, 0.15), (0.28, 0.38), (0.60, 0.70), (0.82, 0.92)]
       blocks2 = []
       for (fa, fb) in windows2:
         win_lo2 = glo2 + int(round(fa * G2))
         base2 = win_lo2 - ulo2
         block = []
         for idx, (l, r) in enumerate(U2):
           mid = (l + r) // 2
           L = mid + base2 - (eps // 2) + (idx % 3)
           R = L + eps
           if R > L:
             block.append((L, R))
         blocks2.append(block)
 
       micro2 = []
       if blocks2:
         maxlen2 = max(len(b) for b in blocks2)
         order2 = [3, 1, 0, 2]
         for i in range(maxlen2):
           for idx in order2:
             blk = blocks2[idx]
             if i < len(blk):
               micro2.append(blk[i])
 
       # Two short cap-pins to tie windows without inflating omega
       caps2 = [
         (glo2 + int(round(0.09 * G2)), glo2 + int(round(0.09 * G2)) + eps),
         (glo2 + int(round(0.64 * G2)), glo2 + int(round(0.64 * G2)) + eps),
       ]
       for a, b in caps2:
         if b > a:
           micro2.append((a, b))
 
       room2 = CAP - len(T)
       if room2 > 0:
-        if len(micro2) > room2:
-          micro2 = micro2[:room2]
-        T.extend(micro2)
-
-  # Stage 4 (new): tower-and-cap micro-phase
-  # Build staggered short towers across five separated windows, then add a few long caps
-  # that each overlap one level from every tower. At any point, only a local tower pin
-  # is active with the cap, mitigating omega growth.
+        T.extend(micro2[:room2])
+
+  # Stage 4: tower-and-cap micro-phase (staggered towers + few long caps)
   if len(T) < CAP - 12:
     glo3 = min(l for l, r in T)
     ghi3 = max(r for l, r in T)
     G3 = max(1, ghi3 - glo3)
 
     # Thin seed for pin positioning (moderate size)
     U3 = _thin_seed(T, max(12, min(36, len(T) // 300)))
     if U3:
       ulo3 = min(l for l, r in U3)
       eps3 = max(1, G3 // 768)  # very short pins
 
       # Five windows for five towers; each builds 3 staggered pin levels
       towers = [(0.10, 0.18), (0.28, 0.36), (0.46, 0.54), (0.64, 0.72), (0.82, 0.90)]
       levels = 3
       tower_blocks = []
       for t_idx, (fa, fb) in enumerate(towers):
         win_lo3 = glo3 + int(round(fa * G3))
         base3 = win_lo3 - ulo3
         block = []
         for idx, (l, r) in enumerate(U3):
           mid = (l + r) // 2
-          # three levels staggered slightly to avoid co-location
           for lv in range(levels):
             jitter = (idx + lv + t_idx) % 4
-            L = mid + base3 - (eps3 // 2) + jitter + lv  # increasing shift by level
+            L = mid + base3 - (eps3 // 2) + jitter + lv
             R = L + eps3
             if R > L:
               block.append((L, R))
         tower_blocks.append(block)
 
       # Interleave towers round-robin to distribute local density
       tower_phase = []
       if tower_blocks:
         maxlen3 = max(len(b) for b in tower_blocks)
         order3 = [0, 2, 4, 1, 3]
         for i in range(maxlen3):
           for idx in order3:
             blk = tower_blocks[idx]
             if i < len(blk):
               tower_phase.append(blk[i])
 
       # Add a few long caps that span across the tower windows but avoid edges
       caps3 = [
         (glo3 + int(round(0.15 * G3)), glo3 + int(round(0.45 * G3))),
         (glo3 + int(round(0.38 * G3)), glo3 + int(round(0.70 * G3))),
         (glo3 + int(round(0.60 * G3)), glo3 + int(round(0.88 * G3))),
       ]
       for a, b in caps3:
         if b > a:
           tower_phase.append((a, b))
 
       room3 = CAP - len(T)
       if room3 > 0 and tower_phase:
-        if len(tower_phase) > room3:
-          tower_phase = tower_phase[:room3]
-        T.extend(tower_phase)
+        T.extend(tower_phase[:room3])
 
   # Final capacity guard
   if len(T) > CAP:
     T = T[:CAP]
 
   # Normalize and ensure integer endpoints with r > l
   if not T:
     return []
   min_l = min(l for l, r in T)
   if min_l < 0:
     T = [(l - min_l, r - min_l) for (l, r) in T]
 
   intervals = []
   for (l, r) in T:
     li = int(l)
     ri = int(r)
     if ri <= li:
       ri = li + 1
     intervals.append((li, ri))
 
   if len(intervals) > CAP:
     intervals = intervals[:CAP]
   return intervals
 
 # EVOLVE-BLOCK-END
 
 def run_experiment(**kwargs):
   """Main called by evaluator"""
   return construct_intervals()