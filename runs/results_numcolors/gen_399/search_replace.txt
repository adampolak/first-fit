<NAME>
tail_window_and_connector_augmentation_v2
</NAME>

<DESCRIPTION>
This edit applies targeted, deterministic augmentations designed to increase FirstFit’s color usage without increasing the clique number materially:

- Expand the KT spine template bank from 4 to 6 deterministic start-patterns to diversify the backbone while keeping growth bounded and CAP-safe.
- Add a CAP-aware, long-range connector augmentation pass immediately after inserting tail caps. These few fractional-span connectors couple colors across long ranges late in the sequence, raising FF while keeping omega modest.
- Enrich micro-phase windows by adding a fifth tail-focused window (0.92–0.98) in the main micro-phase builder, and relax the clamp slightly to allow near-tail placement. This is a known lever to push FF later without inflating the maximum overlap.
- Extend the Stage-3 pinning micro-phase with a tail window and change the interleaving order to prioritize the new tail window while using very short pins to avoid harming omega.
- Extend the tower micro-phase by adding a tail window and updating its interleaving order to incorporate that extra tower.
- Add a tail window to the second micro-phase window set as well.

All changes are deterministic, CAP-aware, and keep intervals short in densification passes, following established heuristics from the literature and prior program successes. The code still runs, adheres to the interface, and remains under the 10,000 interval cap.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    template_bank = [
        (2, 6, 10, 14),  # classic KT
        (1, 5, 9, 13),   # left-shifted
        (3, 7, 11, 15),  # right-shifted
        (4, 8, 12, 16),  # stretched-right
    ]
=======
    template_bank = [
        (2, 6, 10, 14),  # classic KT
        (1, 5, 9, 13),   # left-shifted
        (3, 7, 11, 15),  # right-shifted
        (4, 8, 12, 16),  # stretched-right
        (0, 4, 8, 12),   # left-anchored variant
        (5, 9, 13, 17),  # right-anchored variant
    ]
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
    T = _insert_tail_caps(T, tail_caps, CAP)

    if len(T) >= CAP - 16:
        return T[:CAP]
=======
    T = _insert_tail_caps(T, tail_caps, CAP)

    # Stage 1c: dedicated long-range connector augmentation (CAP-aware)
    lo, hi, delta = _span_delta(T)
    conn_aug_fracs = [(0.14, 0.50), (0.22, 0.66), (0.32, 0.78), (0.44, 0.88)]
    conn_aug = []
    for af, bf in conn_aug_fracs:
        L = lo + max(1, int(round(af * delta)))
        R = lo + max(1, int(round(bf * delta)))
        if R > L:
            conn_aug.append((L, R))
    T = _insert_tail_caps(T, conn_aug, CAP)

    if len(T) >= CAP - 16:
        return T[:CAP]
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
        if not alt:
            shift = ((round_seed + iter_id) % 3) * 0.02
            window_fracs = [
                (0.12 + shift, 0.22 + shift),
                (0.35 + shift, 0.45 + shift),
                (0.58 + shift, 0.68 + shift),
                (0.80 + shift, 0.90 + shift),
            ]
            window_fracs = [
                (max(0.05, min(0.90, a)),
                 max(0.10, min(0.95, b)))
                for (a, b) in window_fracs
            ]
        else:
            window_fracs = [(0.05, 0.15), (0.28, 0.38), (0.60, 0.70), (0.82, 0.92)]
=======
        if not alt:
            shift = ((round_seed + iter_id) % 3) * 0.02
            window_fracs = [
                (0.12 + shift, 0.22 + shift),
                (0.35 + shift, 0.45 + shift),
                (0.58 + shift, 0.68 + shift),
                (0.80 + shift, 0.90 + shift),
                (0.92 + shift, 0.98 + shift),  # tail-focused window
            ]
            window_fracs = [
                (max(0.05, min(0.94, a)),
                 max(0.10, min(0.98, b)))
                for (a, b) in window_fracs
            ]
        else:
            window_fracs = [(0.05, 0.15), (0.28, 0.38), (0.60, 0.70), (0.82, 0.92)]
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
            ulo2 = min(l for l, r in U2)
            eps = max(1, G2 // 512)
            windows2 = [(0.05, 0.15), (0.28, 0.38), (0.60, 0.70), (0.82, 0.92)]
            blocks2 = []
            for (fa, fb) in windows2:
                win_lo2 = glo2 + int(round(fa * G2))
                base2 = win_lo2 - ulo2
                block = []
                for idx, (l, r) in enumerate(U2):
                    mid = (l + r) // 2
                    L = mid + base2 - (eps // 2) + (idx % 3)
                    R = L + eps
                    if R > L:
                        block.append((L, R))
                blocks2.append(block)

            micro2 = []
            if blocks2:
                maxlen2 = max(len(b) for b in blocks2)
                order2 = [3, 1, 0, 2]
                for i in range(maxlen2):
                    for idx in order2:
                        blk = blocks2[idx]
                        if i < len(blk):
                            micro2.append(blk[i])
=======
            ulo2 = min(l for l, r in U2)
            eps = max(1, G2 // 512)
            windows2 = [(0.05, 0.15), (0.28, 0.38), (0.60, 0.70), (0.82, 0.90), (0.92, 0.98)]
            blocks2 = []
            for (fa, fb) in windows2:
                win_lo2 = glo2 + int(round(fa * G2))
                base2 = win_lo2 - ulo2
                block = []
                for idx, (l, r) in enumerate(U2):
                    mid = (l + r) // 2
                    L = mid + base2 - (eps // 2) + (idx % 3)
                    R = L + eps
                    if R > L:
                        block.append((L, R))
                blocks2.append(block)

            micro2 = []
            if blocks2:
                maxlen2 = max(len(b) for b in blocks2)
                order2 = list(range(len(blocks2)))
                # prioritize tail window, then alternate inward
                if len(order2) >= 5:
                    order2 = [len(order2) - 1, 3, 1, 0, 2] + list(range(5, len(order2)))
                for i in range(maxlen2):
                    for idx in order2:
                        blk = blocks2[idx]
                        if i < len(blk):
                            micro2.append(blk[i])
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
            towers = [(0.10, 0.18), (0.28, 0.36), (0.46, 0.54), (0.64, 0.72), (0.82, 0.90)]
            levels = 3
            tower_blocks = []
            for t_idx, (fa, fb) in enumerate(towers):
                win_lo3 = glo3 + int(round(fa * G3))
                base3 = win_lo3 - ulo3
                block = []
                for idx, (l, r) in enumerate(U3):
                    mid = (l + r) // 2
                    for lv in range(levels):
                        jitter = (idx + lv + t_idx) % 4
                        L = mid + base3 - (eps3 // 2) + jitter + lv
                        R = L + eps3
                        if R > L:
                            block.append((L, R))
                tower_blocks.append(block)

            tower_phase = []
            if tower_blocks:
                maxlen3 = max(len(b) for b in tower_blocks)
                order3 = [0, 2, 4, 1, 3]
                for i in range(maxlen3):
                    for idx in order3:
                        blk = tower_blocks[idx]
                        if i < len(blk):
                            tower_phase.append(blk[i])
=======
            towers = [(0.10, 0.18), (0.28, 0.36), (0.46, 0.54), (0.64, 0.72), (0.82, 0.90), (0.92, 0.98)]
            levels = 3
            tower_blocks = []
            for t_idx, (fa, fb) in enumerate(towers):
                win_lo3 = glo3 + int(round(fa * G3))
                base3 = win_lo3 - ulo3
                block = []
                for idx, (l, r) in enumerate(U3):
                    mid = (l + r) // 2
                    for lv in range(levels):
                        jitter = (idx + lv + t_idx) % 4
                        L = mid + base3 - (eps3 // 2) + jitter + lv
                        R = L + eps3
                        if R > L:
                            block.append((L, R))
                tower_blocks.append(block)

            tower_phase = []
            if tower_blocks:
                maxlen3 = max(len(b) for b in tower_blocks)
                order3 = [0, 2, 4, 5, 1, 3]
                for i in range(maxlen3):
                    for idx in order3:
                        blk = tower_blocks[idx]
                        if i < len(blk):
                            tower_phase.append(blk[i])
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
        window_fracs_b = [(0.06, 0.16), (0.30, 0.40), (0.54, 0.64), (0.78, 0.88)]
=======
        window_fracs_b = [(0.06, 0.16), (0.30, 0.40), (0.54, 0.64), (0.78, 0.88), (0.92, 0.98)]
>>>>>>> REPLACE

</DIFF>