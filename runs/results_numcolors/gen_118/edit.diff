--- a/original.py
+++ b/original.py
@@ -1,223 +1,262 @@
 # EVOLVE-BLOCK-START
 
 def construct_intervals(rounds=6,
                         rotate_starts=True,
                         reverse_block_parity=True,
                         interleave_blocks=True,
                         phase2_iters=0):
   """
-  Deterministic KT-style spine with a safeguarded two-phase scaffold.
-
-  Parameters:
-    rounds (int): main expansion depth; near 6 yields ~9556 intervals for a single-seed KT spine.
-    rotate_starts (bool): available but disabled in the safeguarded spine mode.
-    reverse_block_parity (bool): available but disabled in the safeguarded spine mode.
-    interleave_blocks (bool): available but disabled in the safeguarded spine mode.
-    phase2_iters (int): requested micro iterations; actual application is strictly capacity- and safety-gated.
-
-  Returns:
-    intervals: list of (l, r) integer tuples, open intervals, in FF presentation order.
+  Enhanced deterministic KT-style spine and capped micro-extensions.
+
+  Signature preserved for compatibility with previous evaluator.
+  Returns a list of open intervals (l, r) in the order presented to FirstFit.
   """
 
-  # Capacity guard relaxed to permit a thin micro-phase while staying < 10000
+  # Hard capacity guard to keep the total count < 10000
   CAP = 9800
 
-  # Stable KT-spine start pattern (proven strong in prior runs)
-  spine_starts = [2, 6, 10, 14]
-
-  # Optional template bank for exploratory use in micro/secondary phase
-  # (kept dormant by default to preserve the strong baseline).
+  # Expanded template bank (8 templates) of 4-start patterns.
   template_bank = [
-    [2, 6, 10, 14],  # A: classic KT
-    [1, 5, 9, 13],   # B: left-shifted
-    [3, 7, 11, 15],  # C: right-shifted
-    [2, 4, 8, 12],   # D: compressed left pair
-    [3, 5, 9, 13],   # E: gentle left pack
-    [1, 7, 11, 15],  # F: wide skew
-    [2, 8, 10, 12],  # G: inner symmetric
-    [4, 6, 8, 10],   # H: tight middle
+    (2, 6, 10, 14),  # classic
+    (1, 5, 9, 13),   # left-shift
+    (3, 7, 11, 15),  # right-shift
+    (2, 4, 8, 12),   # compressed left pair
+    (3, 5, 9, 13),   # gentle left pack
+    (1, 7, 11, 15),  # wide skew
+    (2, 8, 10, 12),  # inner symmetric
+    (4, 6, 8, 10),   # tight middle
   ]
 
-  # Seed with one unit interval to allow six KT rounds within CAP.
-  T = [(0, 1)]
-
-  # Predictive size accounting to cap the number of full rounds.
-  # KT growth per round: size -> 4*size + 4
-  def round_next_size(sz):
+  # Initial seed (single unit interval as before to permit depth)
+  T = [(0.0, 1.0)]
+
+  # Growth rule: each KT-style round roughly maps size -> 4*size + 4.
+  def next_round_size(sz):
     return 4 * sz + 4
 
-  def max_rounds_within_cap(initial_size, max_rounds):
+  # Compute maximal feasible rounds under CAP
+  def max_rounds_allowable(initial_size, max_rounds):
     sz = initial_size
-    done = 0
-    for _ in range(max(0, int(max_rounds))):
-      nxt = round_next_size(sz)
+    used = 0
+    for _ in range(int(max_rounds)):
+      nxt = next_round_size(sz)
       if nxt > CAP:
         break
       sz = nxt
-      done += 1
-    return done, sz
-
-  # Stage 1: KT spine, un-interleaved, classic connectors, capacity-safe depth.
-  depth, size_est = max_rounds_within_cap(len(T), rounds)
-
-  def apply_round(current_T, starts, do_interleave=False):
-    # Compute span and delta
+      used += 1
+    return used, sz
+
+  depth, _ = max_rounds_allowable(len(T), rounds)
+
+  # Thin deterministic sampler: uniformly subsample at most max_seed items
+  def thin_seed(current_T, max_seed):
+    n = len(current_T)
+    if n == 0 or max_seed <= 0:
+      return []
+    step = max(1, n // max_seed)
+    return current_T[::step][:max_seed]
+
+  # Apply one KT-style spine round with given start pattern and interleaving mode.
+  # We also insert a small number of "spine blockers" per block to occupy early FF colors.
+  def apply_spine_round(current_T, starts, round_idx, do_interleave):
     lo = min(l for l, r in current_T)
     hi = max(r for l, r in current_T)
     delta = hi - lo
     if delta <= 0:
-      delta = 1
-
-    # Build four translated blocks; optionally interleave to enhance color mixing
+      delta = 1.0
+
+    # Build translated blocks
     blocks = []
     for s in starts:
       base = s * delta - lo
       block = [(l + base, r + base) for (l, r) in current_T]
       blocks.append(block)
 
-    # Interleave on demand (even rounds), otherwise keep sequential (odd rounds)
+    # Insert tiny in-block spine blockers (longer intervals placed first in each block)
+    # They are local to each translated block (slightly extend the block span).
+    # Keep count small to avoid raising the global clique number too much.
+    spine_blockers = []
+    blocker_len = max(1.0, delta * 0.6)  # somewhat long compared to block internal width
+    for idx, s in enumerate(starts):
+      # place blocker near the block's left edge (deterministic offset)
+      base = s * delta - lo
+      b_lo = base - 0.05 * delta + 0.02 * idx
+      b_hi = b_lo + blocker_len
+      spine_blockers.append((b_lo, b_hi))
+
+    # Produce final sequence S for this round with the chosen interleaving policy.
     S = []
     if do_interleave:
+      # two-round adaptive parity: rounds in {0,1} forward interleave, {2,3} reverse, cycle
+      cadence = round_idx % 4
       maxlen = max(len(b) for b in blocks)
-      for i in range(maxlen):
-        for blk in blocks:
-          if i < len(blk):
-            S.append(blk[i])
+      if cadence in (0, 1):
+        # forward interleave
+        for i in range(maxlen):
+          for blk in blocks:
+            if i < len(blk):
+              S.append(blk[i])
+      else:
+        # reverse interleave
+        for i in range(maxlen):
+          for blk in reversed(blocks):
+            if i < len(blk):
+              S.append(blk[i])
     else:
+      # sequential block order
       for blk in blocks:
         S.extend(blk)
 
-    # Classic connectors that preserve the desired FF pressure without
-    # blowing up omega when used with spine_starts:
+    # Prepend spine blockers so they appear before the block intervals in each round,
+    # pressuring FirstFit to use small colors early.
+    S = spine_blockers + S
+
+    # Classic KT-style connectors adapted to the current delta and starts.
     s0, s1, s2, s3 = starts
     connectors = [
-      ((s0 - 1) * delta, (s1 - 1) * delta),
-      ((s2 + 2) * delta, (s3 + 2) * delta),
-      ((s0 + 2) * delta, (s2 - 1) * delta),
-      ((s1 + 2) * delta, (s3 - 1) * delta),
+      ((s0 - 1) * delta, (s1 - 1) * delta),  # left cap
+      ((s2 + 2) * delta, (s3 + 2) * delta),  # right cap
+      ((s0 + 2) * delta, (s2 - 1) * delta),  # cross 1
+      ((s1 + 2) * delta, (s3 - 1) * delta),  # cross 2
     ]
     S.extend(connectors)
+
     return S
 
+  # Run spine rounds cycling through template bank and interleaving cadence.
   for ridx in range(depth):
-    # Keep sequential order every round (disabling interleaving lowers omega)
-    T = apply_round(T, spine_starts, do_interleave=False)
-
-  # If we already reached or are near the cap, skip phase 2 safely.
+    starts = template_bank[ridx % len(template_bank)]
+    # enable interleaving for most rounds to increase mixing; still deterministic
+    do_interleave = bool(interleave_blocks)
+    T = apply_spine_round(T, starts, ridx, do_interleave=do_interleave)
+    # Safety cap: if we near capacity, stop expanding spine
+    if len(T) > CAP - 64:
+      break
+
+  # If we already reached or are very near the cap, return T
   if len(T) >= CAP - 16:
     return T
 
-  # Stage 2: Two delta2-driven micro extension rounds (thin sampling; four-start translations).
-  # Goals:
-  #  - Raise FF pressure via cross-scale coupling and interleaving parity,
-  #  - Keep omega in check by using thin seeds and sparse caps/connectors,
-  #  - Respect strict capacity guard.
-
-  def thin_seed(current_T, max_seed):
-    """Take a thin, evenly spaced sample of current_T of size <= max_seed."""
-    n = len(current_T)
-    if n == 0 or max_seed <= 0:
-      return []
-    step = max(1, n // max_seed)
-    U = current_T[::step][:max_seed]
-    return U
-
-  def micro_round(current_T, round_id, budget):
+  # Stage 2: improved micro-extension phase.
+  # We'll attempt up to two delta2 rounds plus one tighter delta2' round,
+  # each strictly bounded by remaining capacity.
+
+  def micro_round(current_T, round_id, budget, scale_factor=0.5, extra_long_caps=3):
+    """
+    scale_factor: fraction of global span used as local delta2 scale.
+    extra_long_caps: number of sparse long caps added to overlap many active colors.
+    """
     if budget <= 0 or not current_T:
       return []
 
     glo = min(l for l, r in current_T)
     ghi = max(r for l, r in current_T)
-    G = max(1, ghi - glo)
-
-    # Use delta2 at half-scale to avoid expanding the global span too aggressively.
-    delta2 = max(1, G // 2)
-
-    # Thin seed: bounded and deterministic size to respect budget
-    # Keep micro blocks small: target at most ~ (budget//6) per block (four blocks + ~8 extras).
-    per_block_target = max(8, min(64, budget // 12))
+    G = max(1.0, ghi - glo)
+
+    # delta2 at controlled scale (integer-ish where possible)
+    delta2 = max(1.0, max(1.0, scale_factor * G))
+
+    # Thin deterministic seed; target a modest seed size to avoid large omega
+    per_block_target = max(12, min(96, budget // 10))
     U = thin_seed(current_T, per_block_target)
-
     if not U:
       return []
 
-    # Build four translated blocks using the same 4-start template,
-    # with deterministic parity-based interleaving policy:
-    # - Rounds with round_id % 2 == 0: forward interleave
-    # - Rounds with round_id % 2 == 1: reverse interleave
-    starts = spine_starts
+    # Build four micro-blocks using the classic 4-start pattern from the template bank
+    starts = template_bank[round_id % len(template_bank)]
+    ulo = min(l for l, r in U)
     blocks = []
-    ulo = min(l for l, r in U)
     for s in starts:
-      base = s * delta2 - ulo
+      base = s * delta2 + glo - ulo
       block = [(l + base, r + base) for (l, r) in U]
-      # Add a tiny deterministic internal reversal to break symmetry every other block
-      if ((s // 2) % 2) == (round_id % 2):
+      # deterministic micro reversal to diversify interaction pattern
+      if (s % 2) == (round_id % 2):
         block = list(reversed(block))
       blocks.append(block)
 
+    # Interleave blocks using the same two-round cadence (round_id influences order)
     micro = []
-    if round_id % 2 == 0:
-      # Forward interleave
-      maxlen = max(len(b) for b in blocks)
+    cadence = round_id % 4
+    maxlen = max(len(b) for b in blocks)
+    if cadence in (0, 1):
       for i in range(maxlen):
         for blk in blocks:
           if i < len(blk):
             micro.append(blk[i])
     else:
-      # Reverse interleave (swap block order)
-      maxlen = max(len(b) for b in blocks)
       for i in range(maxlen):
         for blk in reversed(blocks):
           if i < len(blk):
             micro.append(blk[i])
 
-    # Deterministic connectors at delta2 scale, including a cross3 extension
+    # Deterministic connectors at delta2 scale (localized to glo..ghi region)
     s0, s1, s2, s3 = starts
     connectors = [
-      ((s0 - 1) * delta2 + glo, (s1 - 1) * delta2 + glo),  # left cap (localized)
-      ((s2 + 2) * delta2 + glo, (s3 + 2) * delta2 + glo),  # right cap
-      ((s0 + 2) * delta2 + glo, (s2 - 1) * delta2 + glo),  # cross 1
-      ((s1 + 2) * delta2 + glo, (s3 - 1) * delta2 + glo),  # cross 2
-      ((s0 + 3) * delta2 + glo, (s3 + 3) * delta2 + glo),  # cross3 (longer range)
+      (glo + (s0 - 1) * delta2, glo + (s1 - 1) * delta2),
+      (glo + (s2 + 2) * delta2, glo + (s3 + 2) * delta2),
+      (glo + (s0 + 2) * delta2, glo + (s2 - 1) * delta2),
+      (glo + (s1 + 2) * delta2, glo + (s3 - 1) * delta2),
     ]
     micro.extend(connectors)
 
-    # Sparse micro caps: add three long but safe caps at half-scale
-    cap1 = (glo + (delta2 // 4), glo + int(1.8 * delta2))
-    cap2 = (glo + int(0.9 * delta2), glo + int(2.6 * delta2))
-    mid = glo + G // 2
-    cap3 = (mid - max(1, delta2 // 8), mid + max(1, delta2 // 8))
-    for cap in (cap1, cap2, cap3):
-      if cap[1] > cap[0]:
-        micro.append(cap)
-
-    # Enforce budget
+    # Add a few sparse long caps that overlap many blocks â€” tuned to be 'safe' yet pressuring FF.
+    caps = []
+    for k in range(extra_long_caps):
+      frac_lo = 0.05 + 0.2 * k
+      frac_hi = min(0.95, frac_lo + 0.5)
+      cap_lo = glo + frac_lo * G
+      cap_hi = glo + frac_hi * G
+      if cap_hi > cap_lo:
+        caps.append((cap_lo, cap_hi))
+    micro.extend(caps)
+
+    # Trim micro to budget deterministically
     if len(micro) > budget:
       micro = micro[:budget]
     return micro
 
-  # Execute two micro rounds with strong guards
+  # Two delta2 micro rounds
   remaining = CAP - len(T)
-  mr1 = micro_round(T, round_id=0, budget=max(0, remaining // 2))
-  if mr1:
-    room = CAP - len(T)
-    if len(mr1) > room:
-      mr1 = mr1[:room]
-    T.extend(mr1)
+  # allocate roughly half of remaining to first micro, rest to second
+  if remaining > 16:
+    b1 = max(8, remaining // 2)
+    mr1 = micro_round(T, round_id=0, budget=b1, scale_factor=0.45, extra_long_caps=3)
+    if mr1:
+      room = CAP - len(T)
+      if len(mr1) > room:
+        mr1 = mr1[:room]
+      T.extend(mr1)
 
   remaining = CAP - len(T)
-  mr2 = micro_round(T, round_id=1, budget=max(0, remaining))
-  if mr2:
-    room = CAP - len(T)
-    if len(mr2) > room:
-      mr2 = mr2[:room]
-    T.extend(mr2)
+  if remaining > 16:
+    b2 = max(8, remaining)
+    mr2 = micro_round(T, round_id=1, budget=b2, scale_factor=0.35, extra_long_caps=3)
+    if mr2:
+      room = CAP - len(T)
+      if len(mr2) > room:
+        mr2 = mr2[:room]
+      T.extend(mr2)
+
+  # Optional tight micro (delta2') to push FF late: use a smaller scale and tiny seed.
+  remaining = CAP - len(T)
+  if remaining > 32:
+    b3 = min(remaining, 256)
+    # very fine-scale micro extension: smaller seed, tiny scale to avoid big span growth
+    mr3 = micro_round(T, round_id=2, budget=b3, scale_factor=0.12, extra_long_caps=2)
+    if mr3:
+      room = CAP - len(T)
+      if len(mr3) > room:
+        mr3 = mr3[:room]
+      T.extend(mr3)
+
+  # Final safety trim (if anything overshot due to arithmetic)
+  if len(T) > CAP:
+    T = T[:CAP]
 
   return T
 
 # EVOLVE-BLOCK-END
 
 def run_experiment(**kwargs):
   """Main called by evaluator"""
   return construct_intervals()