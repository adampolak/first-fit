<NAME>
bridges_microgadgets_and_dual_caps
</NAME>

<DESCRIPTION>
I add three targeted mechanisms known to inflate FirstFit while keeping the clique number controlled:
1) Adjacent and occasional second-next bridges: short “bridge” intervals coupling consecutive blocks (and every other block in alternating rounds) carry colors across blocks, making early small colors unavailable and forcing FF to open new colors later, while bridges are sparse enough to avoid raising omega too much.
2) Micro-gadget injection: a scaled version of the four-interval gadget is embedded inside the middle block each round. This creates intra-block pressure at a smaller scale without stacking too many long intervals at one point.
3) Dual sparse caps: replace the single family of caps with two interleaved families of short-to-moderate caps, spaced to avoid heavy pileups yet effective at coupling colors across starts.

These changes are consistent with tower/cap/blocker heuristics from the literature (e.g., waves of short intervals, caps, and arrival-order engineering) and aim to lift FF beyond the current 10/8 while keeping omega near/below 10. The edits are localized and maintain determinism and modest span.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
def construct_intervals(rounds=3):
  """
  Construct a sequence of intervals of real line,
  in the order in which they are presented to FirstFit,
  so that it tends to maximize the number of colors used by FirstFit
  divided by the maximum number of intervals that cover a single point
  through a recursive wave construction.

  Improvements over the previous version:
  - start with multiple disjoint unit intervals to seed richer early overlaps
  - use a small bank of four-interval "templates" and pick a template per round
    (breaks strict self-similarity)
  - cycle through a list of start-patterns across rounds so translated copies
    land in different relative offsets each round
  - default to 3 rounds to allow one more expansion (still modest total size)
  """
  # seed with several disjoint unit intervals (keeps omega small but provides coupling)
  T = [(0, 1), (2, 3), (4, 5), (6, 7)]

  # a small bank of four-interval templates (variants of the gadget)
  templates = [
    # template A: original pattern
    [(1, 5), (12, 16), (4, 9), (8, 13)],
    # template B: shifted variant
    [(0.5, 4.5), (11, 15), (3.5, 8.5), (7, 12)],
    # template C: tighter local overlaps
    [(1, 4), (6, 9), (3, 7), (9, 13)],
    # template D: staggered caps
    [(2, 6), (7, 11), (0, 3), (10, 14)]
  ]

  # a short deterministic cycle of start patterns (each element is a tuple/list of starts)
  start_patterns = [
    (2, 6, 10, 14),             # compact 4-wave pattern
    (2, 4, 6, 8, 10, 12, 14, 16),  # denser pattern
    (2, 5, 8, 11, 14, 17, 20),  # staggered 7-wave
  ]

  for round_idx in range(rounds):
    lo = min(l for l, r in T)
    hi = max(r for l, r in T)
    delta = hi - lo
    S = []

    # choose start pattern and template deterministically based on round index
    starts = list(start_patterns[round_idx % len(start_patterns)])
    template = templates[round_idx % len(templates)]

    # vary the inner order of clones to make FirstFit reuse harder
    for idx, start in enumerate(starts):
      if idx % 2 == 0:
        base = T
      else:
        base = list(reversed(T))
      S += [(delta * start + l - lo, delta * start + r - lo) for l, r in base]

    # place the chosen template intervals scaled by delta
    S += [(delta * a, delta * b) for (a, b) in template]

    # add a few sparse caps that span small neighborhoods of starts to couple colors
    # without raising omega too much
    max_start = max(starts)
    for j in range(2, max_start, max(3, int(max_start // 6))):
      S.append((delta * (j - 0.5), delta * (j + 1.5)))

    T = S

  return T

  # return [  # Figure 3, OPT=2, FF=4
  #   (2,3),
  #   (6,7),
  #   (10,11),
  #   (14,15),
  #   (1,5),
  #   (12,16),
  #   (4,9),
  #   (8,13),
  # ]
=======
def construct_intervals(rounds=3):
  """
  Construct a sequence of intervals of real line,
  in the order in which they are presented to FirstFit,
  so that it tends to maximize the number of colors used by FirstFit
  divided by the maximum number of intervals that cover a single point
  through a recursive wave construction.

  Improvements over the previous version:
  - start with multiple disjoint unit intervals to seed richer early overlaps
  - use a small bank of four-interval "templates" and pick a template per round
    (breaks strict self-similarity)
  - cycle through a list of start-patterns across rounds so translated copies
    land in different relative offsets each round
  - add sparse bridges across consecutive (and occasional second-next) blocks
    to couple colors with minimal omega growth
  - inject a small-scale gadget inside a middle block per round
    to create intra-block pressure without large cliques
  - use two interleaved cap families to increase FF pressure gently
  - default to 3 rounds to allow one more expansion (still modest total size)
  """
  # seed with several disjoint unit intervals (keeps omega small but provides coupling)
  T = [(0, 1), (2, 3), (4, 5), (6, 7)]

  # a small bank of four-interval templates (variants of the gadget)
  templates = [
    # template A: original pattern
    [(1, 5), (12, 16), (4, 9), (8, 13)],
    # template B: shifted variant
    [(0.5, 4.5), (11, 15), (3.5, 8.5), (7, 12)],
    # template C: tighter local overlaps
    [(1, 4), (6, 9), (3, 7), (9, 13)],
    # template D: staggered caps
    [(2, 6), (7, 11), (0, 3), (10, 14)]
  ]

  # a short deterministic cycle of start patterns (each element is a tuple/list of starts)
  start_patterns = [
    (2, 6, 10, 14),             # compact 4-wave pattern
    (2, 4, 6, 8, 10, 12, 14, 16),  # denser pattern
    (2, 5, 8, 11, 14, 17, 20),  # staggered 7-wave
  ]

  for round_idx in range(rounds):
    lo = min(l for l, r in T)
    hi = max(r for l, r in T)
    delta = hi - lo
    S = []

    # choose start pattern and template deterministically based on round index
    starts = list(start_patterns[round_idx % len(start_patterns)])
    template = templates[round_idx % len(templates)]

    # vary the inner order of clones to make FirstFit reuse harder
    for idx, start in enumerate(starts):
      if idx % 2 == 0:
        base = T
      else:
        base = list(reversed(T))
      S += [(delta * start + l - lo, delta * start + r - lo) for l, r in base]

      # bridges to couple adjacent (and occasional second-next) blocks
      if idx + 1 < len(starts):
        nxt = starts[idx + 1]
        S.append((delta * (start + 0.35), delta * (nxt + 0.65)))
      if (round_idx % 2 == 0) and (idx + 2 < len(starts)):
        nxt2 = starts[idx + 2]
        S.append((delta * (start + 0.75), delta * (nxt2 + 0.25)))

    # place the chosen template intervals scaled by delta
    S += [(delta * a, delta * b) for (a, b) in template]

    # micro-gadget: scaled gadget injected inside the middle block to raise FF
    anchor = starts[len(starts) // 2]
    micro_template = templates[(round_idx + 1) % len(templates)]
    S += [(delta * (anchor + a / 16.0), delta * (anchor + b / 16.0)) for (a, b) in micro_template]

    # add dual sparse cap families to couple colors without large omega
    max_start = max(starts)
    step = max(2, int(max_start // 5))
    for j in range(2, max_start, step):
      S.append((delta * (j - 0.6), delta * (j + 0.6)))
    for j in range(3, max_start, step + 1):
      S.append((delta * (j - 0.2), delta * (j + 1.8)))

    T = S

  return T

  # return [  # Figure 3, OPT=2, FF=4
  #   (2,3),
  #   (6,7),
  #   (10,11),
  #   (14,15),
  #   (1,5),
  #   (12,16),
  #   (4,9),
  #   (8,13),
  # ]
>>>>>>> REPLACE

</DIFF>