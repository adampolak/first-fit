--- a/original.py
+++ b/original.py
@@ -1,254 +1,311 @@
 # EVOLVE-BLOCK-START
+
+import math
+import hashlib
 
 def construct_intervals(seed_count=1):
   """
-  Construct a sequence of intervals on the real line, in the order presented to FirstFit,
-  to maximize FF colors divided by the clique number.
+  Evolved KT-style spine + two micro-phases with deterministic per-round controls,
+  small CAP-aware density boosts, long-range connectors, and near-tail caps.
+
+  Interface:
+    seed_count (int): preserved for compatibility. Routine currently uses a single seed
+                      interval by default to avoid early omega inflation.
+
   Returns:
-    intervals: list of (l, r) tuples (open intervals).
+    List of (l, r) integer tuples (open intervals) in FF arrival order.
   """
 
-  # Capacity guard to keep total intervals < 10000
-  CAP = 9800
-
-  # Rotating four-start templates for the KT spine
+  CAP = 9800  # hard capacity guard (keep < 10k)
+
+  # Deterministic base seed to produce per-round deterministic choices
+  BASE_SEED = "kt_evolved_v1"
+
+  # Four-template spine bank (rotated)
   template_bank = [
     (2, 6, 10, 14),  # classic KT
     (1, 5, 9, 13),   # left-shifted
     (3, 7, 11, 15),  # right-shifted
     (4, 8, 12, 16),  # stretched-right
   ]
 
-  # Seed with a single unit interval; multi-seed tends to inflate omega too early
-  T = [(0, 1)] if seed_count <= 1 else [(0, 1)]
+  # Seed: single unit interval (keeps omega small early)
+  T = [(0, 1)]
 
   # Helpers
-  def _span(current_T):
-    lo = min(l for l, r in current_T)
-    hi = max(r for l, r in current_T)
+  def _span(Tlist):
+    lo = min(l for l, r in Tlist)
+    hi = max(r for l, r in Tlist)
     delta = hi - lo
     if delta <= 0:
       delta = 1
     return lo, hi, delta
 
-  def _apply_round(current_T, starts, do_interleave=False, reverse_order=False, add_cross4=False):
-    lo, hi, delta = _span(current_T)
-
-    # Build four translated blocks
-    blocks = []
-    for s in starts:
-      base = s * delta - lo
-      block = [(l + base, r + base) for (l, r) in current_T]
-      blocks.append(block)
-
-    # Interleaving policy (round-robin across blocks)
-    S = []
-    if do_interleave:
-      order = list(range(4))
-      if reverse_order:
-        order.reverse()
-      maxlen = max(len(b) for b in blocks)
-      for i in range(maxlen):
-        for idx in order:
-          blk = blocks[idx]
-          if i < len(blk):
-            S.append(blk[i])
-    else:
-      if reverse_order:
-        blocks = list(reversed(blocks))
-      for blk in blocks:
-        S.extend(blk)
-
-    # Classic four connectors
+  def _per_round_bits(base_seed, ridx):
+    """
+    Create deterministic small state per round from base seed and ridx.
+    Returns booleans and a small float multiplier.
+    """
+    key = "{}:{}".format(base_seed, ridx).encode("utf8")
+    digest = hashlib.sha256(key).digest()
+    # convert first bytes to numbers
+    b0 = digest[0]
+    b1 = digest[1]
+    b2 = digest[2]
+    b3 = digest[3]
+    # booleans
+    reverse = (b0 % 2) == 1
+    interleave = True   # enforce interleaving (always True for spine rounds)
+    # small deterministic density multiplier in [1.12,1.25] but scaled to round index
+    frac = (b1 / 255.0)
+    density_mul = 1.12 + 0.13 * frac  # range approx [1.12, 1.25]
+    # small flag for adding cross4 long connector on final rounds
+    add_cross4 = (b2 % 7 == 0)
+    return reverse, interleave, density_mul, add_cross4
+
+  def _translate_block(current_T, s, delta, lo):
+    base = s * delta - lo
+    return [(l + base, r + base) for (l, r) in current_T]
+
+  def _interleave_blocks(blocks, order=None):
+    if order is None:
+      order = list(range(len(blocks)))
+    maxlen = max(len(b) for b in blocks)
+    out = []
+    for i in range(maxlen):
+      for idx in order:
+        blk = blocks[idx]
+        if i < len(blk):
+          out.append(blk[i])
+    return out
+
+  def _append_connectors(S, starts, delta, include_cross4=False):
     s0, s1, s2, s3 = starts
-    S.append(((s0 - 1) * delta, (s1 - 1) * delta))  # left cap
-    S.append(((s2 + 2) * delta, (s3 + 2) * delta))  # right cap
-    S.append(((s0 + 2) * delta, (s2 - 1) * delta))  # cross 1
-    S.append(((s1 + 2) * delta, (s3 - 1) * delta))  # cross 2
-
-    # Optional long-range connector (cross4) to tie distant colors across scales
-    if add_cross4:
-      S.append(((s0 + 4) * delta, (s3 + 4) * delta))
-
-    return S
-
-  # Small helper to insert intervals near the tail (increases blocking effect)
-  def _insert_near_tail(seq, intervals):
-    out = list(seq)
-    for i, iv in enumerate(intervals):
+    S.append(((s0 - 1) * delta, (s1 - 1) * delta))   # left cap
+    S.append(((s2 + 2) * delta, (s3 + 2) * delta))   # right cap
+    S.append(((s0 + 2) * delta, (s2 - 1) * delta))   # cross 1
+    S.append(((s1 + 2) * delta, (s3 - 1) * delta))   # cross 2
+    if include_cross4:
+      S.append(((s0 + 4) * delta, (s3 + 4) * delta)) # long cross4
+
+  def _density_boost(S, density_mul, clamp_room):
+    """
+    Apply a modest density boost to S by duplicating a fraction of S with
+    small offsets. The fraction is chosen so that we don't exceed clamp_room
+    and the multiplier is modest (<= ~1.25).
+    """
+    if density_mul <= 1.0001:
+      return S
+    # fraction to duplicate
+    frac_dup = min(0.18, (density_mul - 1.0))  # keep modest, e.g., 0.12->0.18
+    n = len(S)
+    dup_count = max(0, int(n * frac_dup))
+    dup_count = min(dup_count, clamp_room)
+    if dup_count <= 0:
+      return S
+    # choose evenly spaced indices to duplicate
+    step = max(1, n // dup_count)
+    duplicates = []
+    # small offset proportional to span of S
+    if n == 0:
+      return S
+    lo = min(l for l, r in S)
+    hi = max(r for l, r in S)
+    span = max(1, hi - lo)
+    offset = max(1, span // 100)  # small shift to avoid exact overlap; 1% of span
+    for i in range(0, n, step)[:dup_count]:
+      l, r = S[i]
+      duplicates.append((l + offset, r + offset))
+    # insert duplicates interleaved near the end to maximize blocking
+    out = list(S)
+    for i, iv in enumerate(duplicates):
       pos = len(out) - (i * 2 + 1)
       if pos < 0:
         out.append(iv)
       else:
         out.insert(pos, iv)
     return out
 
-  # Stage 1: KT spine with rotation and parity policies, capacity-guarded
-  for ridx in range(6):
-    # Predict next size: sz -> 4*sz + 4
-    if 4 * len(T) + 4 > CAP:
+  # Main spine parameters
+  MAX_ROUNDS = 6
+  for ridx in range(MAX_ROUNDS):
+    # capacity forecast for recurrence: next_size = 4*len(T) + 4 (connectors)
+    if 4 * len(T) + 8 > CAP:
       break
+
     starts = template_bank[ridx % len(template_bank)]
-    # Interleave on even rounds, reverse block order on odd rounds
-    do_inter = (ridx % 2 == 0)
-    rev = (ridx % 2 == 1)
-    T = _apply_round(T, starts, do_interleave=do_inter, reverse_order=rev)
-
-  # Early exit if nearly at capacity
-  if len(T) >= CAP - 8:
-    return T
-
-  # Micro-phase A: add three long-range caps to boost FF pressure (capacity-safe)
-  lo, hi, _ = _span(T)
-  span = max(1, hi - lo)
-  def cap_at(a_frac, b_frac):
-    L = lo + max(1, int(round(a_frac * span)))
-    R = lo + max(1, int(round(b_frac * span)))
-    if R <= L:
-      R = L + 1
-    return (L, R)
-  caps = [cap_at(0.08, 0.60), cap_at(0.25, 0.75), cap_at(0.75, 0.92)]
-  for c in caps:
-    if len(T) >= CAP:
-      break
-    T.append(c)
-
-  # Micro-phase B: thin delta2-style fractional-window round(s), capacity-guarded
-  def build_micro_delta_round(current_T, budget):
+    reverse, interleave_flag, density_mul, add_cross4_flag = _per_round_bits(BASE_SEED, ridx)
+
+    # Build 4 blocks translated
+    lo, hi, delta = _span(T)
+    blocks = [_translate_block(T, s, delta, lo) for s in starts]
+
+    # Always interleave on spine rounds to enforce mixing
+    order = list(range(4))
+    if reverse:
+      order.reverse()
+    S = _interleave_blocks(blocks, order=order)
+
+    # Append classic connectors; add cross4 only rarely and only if capacity allows.
+    _append_connectors(S, starts, delta, include_cross4=add_cross4_flag and (len(S) + 1 < CAP))
+
+    # Apply a small CAP-aware density boost deterministic for this round
+    room = CAP - len(S)  # room for S alone (we will clamp later when merging into T)
+    # compute clamp_room for duplicates: allow at most 5% of CAP or remaining CAP budget later
+    clamp_room = max(2, min(int(CAP * 0.05), CAP - len(T) - 8))
+    S = _density_boost(S, density_mul, clamp_room)
+
+    # Replace T with S (KT recurrence)
+    T = S
+
+  # If near capacity after spine, clamp and return
+  if len(T) >= CAP - 12:
+    return T[:CAP]
+
+  # Micro-phase 1: fractional-window micro round (delta2-style)
+  def build_micro_round(current_T, budget, window_fracs, alt_tag=False):
     if not current_T or budget <= 8:
       return []
 
-    glo = min(l for l, r in current_T)
-    ghi = max(r for l, r in current_T)
+    glo = min(l for l, _ in current_T)
+    ghi = max(r for _, r in current_T)
     G = max(1, ghi - glo)
 
-    # Thin, evenly spaced seed
-    seed_sz = max(8, min(32, len(current_T) // 300))
-    stride = max(1, len(current_T) // max(1, seed_sz))
-    U = [current_T[i] for i in range(0, len(current_T), stride)][:seed_sz]
+    # thin adaptive seed
+    seed_sz = max(10, min(48, len(current_T) // 220))
+    seed_sz = min(seed_sz, 48)
+    step = max(1, len(current_T) // max(1, seed_sz))
+    U = [current_T[i] for i in range(0, len(current_T), step)][:seed_sz]
     if not U:
       return []
 
-    ulo = min(l for l, r in U)
-
-    # Four windows across the span (stay inside to control omega)
-    window_fracs = [(0.12, 0.22), (0.35, 0.45), (0.58, 0.68), (0.80, 0.90)]
-
-    # Build translated micro-blocks aligned to these windows
+    ulo = min(l for l, _ in U)
+
     blocks = []
     for (fa, fb) in window_fracs:
       win_lo = glo + int(round(fa * G))
       base = win_lo - ulo
       block = [(l + base, r + base) for (l, r) in U]
+      # break internal symmetry by reversing some blocks depending on alt_tag and fa
+      parity = int(round(fa * 100)) // 7
+      if (parity + (1 if alt_tag else 0)) % 2 == 1:
+        block = list(reversed(block))
       blocks.append(block)
 
-    # Interleave micro-blocks to maximize FF mixing
-    micro = []
-    maxlen = max(len(b) for b in blocks)
-    for i in range(maxlen):
-      for blk in blocks:
-        if i < len(blk):
-          micro.append(blk[i])
-
-    # Fractional-span connectors at the micro scale
+    # Interleave with an order that alternates by tag
+    order = list(range(len(blocks)))
+    if alt_tag:
+      order = list(reversed(order))
+    micro = _interleave_blocks(blocks, order=order)
+
+    # Add fractional-span connectors (micro-scale)
+    def fcap(a_frac, b_frac):
+      a = glo + int(round(a_frac * G))
+      b = glo + int(round(b_frac * G))
+      if b <= a:
+        b = a + 1
+      return (a, b)
+
     micro_connectors = [
-      (glo + int(round(0.08 * G)), glo + int(round(0.30 * G))),  # left cap
-      (glo + int(round(0.60 * G)), glo + int(round(0.92 * G))),  # right cap
-      (glo + int(round(0.26 * G)), glo + int(round(0.56 * G))),  # cross 1
-      (glo + int(round(0.44 * G)), glo + int(round(0.78 * G))),  # cross 2
+      fcap(0.08, 0.30),
+      fcap(0.60, 0.92),
+      fcap(0.26, 0.56),
+      fcap(0.44, 0.78),
     ]
-    for a, b in micro_connectors:
-      if b > a:
-        micro.append((a, b))
-
-    # Trim to available budget
+    # include one longer cross sometimes for alt_tag
+    if alt_tag:
+      micro_connectors.append(fcap(0.14, 0.86))
+
+    for c in micro_connectors:
+      micro.append(c)
+
+    # Trim micro to budget
     if len(micro) > budget:
       micro = micro[:budget]
     return micro
 
-  # One safeguarded micro-round (empirically strong for 2.30-tier results)
+  # Primary micro windows
+  micro_windows_A = [(0.12, 0.22), (0.35, 0.45), (0.58, 0.68), (0.80, 0.90)]
   room = CAP - len(T)
-  if room > 8:
-    micro = build_micro_delta_round(T, room)
-    if micro:
-      if len(micro) > room:
-        micro = micro[:room]
-      T.extend(micro)
-
-  # Micro-phase C: alternate window family with reverse-order interleaving and a long cross connector
-  def build_micro_delta_round_alt(current_T, budget):
-    if not current_T or budget <= 8:
+  if room > 12:
+    micro_budget = min(room, 400)  # keep micro-phase moderate in size
+    microA = build_micro_round(T, micro_budget, micro_windows_A, alt_tag=False)
+    if microA:
+      # append microA but keep CAP
+      avail = CAP - len(T)
+      if len(microA) > avail:
+        microA = microA[:avail]
+      T.extend(microA)
+
+  # If near capacity after microA, stop
+  if len(T) >= CAP - 12:
+    return T[:CAP]
+
+  # Deterministic long-range connectors tuned to current geometry
+  def add_long_connectors(current_T, max_add=6):
+    if not current_T:
       return []
-
-    glo = min(l for l, r in current_T)
-    ghi = max(r for l, r in current_T)
-    G = max(1, ghi - glo)
-
-    # Slightly larger thin seed for stronger coupling (still bounded)
-    seed_sz = max(8, min(40, len(current_T) // 250))
-    stride = max(1, len(current_T) // max(1, seed_sz))
-    U = [current_T[i] for i in range(0, len(current_T), stride)][:seed_sz]
-    if not U:
-      return []
-
-    ulo = min(l for l, r in U)
-
-    # Alternate window set, anchored well inside the span
-    window_fracs = [(0.05, 0.15), (0.28, 0.38), (0.60, 0.70), (0.82, 0.92)]
-
-    # Build translated micro-blocks aligned to these windows
-    blocks = []
-    for (fa, fb) in window_fracs:
-      win_lo = glo + int(round(fa * G))
-      base = win_lo - ulo
-      block = [(l + base, r + base) for (l, r) in U]
-      # Internal reversal on alternating blocks to break symmetry
-      if int(round(fa * 100)) // 5 % 2 == 1:
-        block = list(reversed(block))
-      blocks.append(block)
-
-    # Reverse-order interleaving to diversify color mixing
-    micro = []
-    maxlen = max(len(b) for b in blocks)
-    for i in range(maxlen):
-      for blk in reversed(blocks):
-        if i < len(blk):
-          micro.append(blk[i])
-
-    # Fractional-span connectors including a long cross to tie distant colors
-    micro_connectors = [
-      (glo + int(round(0.08 * G)), glo + int(round(0.30 * G))),  # left cap
-      (glo + int(round(0.60 * G)), glo + int(round(0.92 * G))),  # right cap
-      (glo + int(round(0.26 * G)), glo + int(round(0.56 * G))),  # cross 1
-      (glo + int(round(0.44 * G)), glo + int(round(0.78 * G))),  # cross 2
-      (glo + int(round(0.18 * G)), glo + int(round(0.84 * G))),  # long cross
+    lo = min(l for l, _ in current_T)
+    hi = max(r for _, r in current_T)
+    span = max(1, hi - lo)
+    connectors = []
+    # choose a small bank of connectors anchored deterministically
+    anchors = [0.06, 0.18, 0.36, 0.58, 0.76, 0.88]
+    for a_frac in anchors[:max_add]:
+      L = lo + int(round(a_frac * span))
+      R = lo + int(round((a_frac + 0.24) * span))
+      if R <= L:
+        R = L + 1
+      connectors.append((L, R))
+    return connectors
+
+  room = CAP - len(T)
+  long_conns = add_long_connectors(T, max_add=4)
+  for c in long_conns:
+    if len(T) >= CAP:
+      break
+    T.append(c)
+
+  # Micro-phase 2: alternate windows to capture missed interactions
+  micro_windows_B = [(0.05, 0.15), (0.28, 0.38), (0.60, 0.70), (0.82, 0.92)]
+  room = CAP - len(T)
+  if room > 12:
+    micro_budget = min(room, 300)
+    microB = build_micro_round(T, micro_budget, micro_windows_B, alt_tag=True)
+    if microB:
+      avail = CAP - len(T)
+      if len(microB) > avail:
+        microB = microB[:avail]
+      T.extend(microB)
+
+  # Final near-tail insertion of staggered long caps to boost last-stage blocking
+  if len(T) < CAP:
+    lo, hi, delta = _span(T)
+    d2 = max(1, delta // 5)
+    tail_caps = [
+      (lo + 1 * d2, lo + 5 * d2),
+      (lo + 3 * d2, lo + 8 * d2),
+      (hi - 6 * d2, hi - 2 * d2),
+      (hi - 9 * d2, hi - 4 * d2),
     ]
-    for a, b in micro_connectors:
-      if b > a:
-        micro.append((a, b))
-
-    # Trim to available budget
-    if len(micro) > budget:
-      micro = micro[:budget]
-    return micro
-
-  # Execute the alternate micro-phase if capacity allows
-  room = CAP - len(T)
-  if room > 8:
-    micro_alt = build_micro_delta_round_alt(T, room)
-    if micro_alt:
-      if len(micro_alt) > room:
-        micro_alt = micro_alt[:room]
-      T.extend(micro_alt)
-
-  # Final capacity trim
+    # insert near the tail to maximize interference with many ongoing colors
+    for i, iv in enumerate(tail_caps):
+      if len(T) >= CAP:
+        break
+      pos = len(T) - (i * 2 + 1)
+      if pos < 0:
+        T.append(iv)
+      else:
+        T.insert(pos, iv)
+
+  # Final capacity clamp
   if len(T) > CAP:
     T = T[:CAP]
 
   return T
 
 # EVOLVE-BLOCK-END
 
 def run_experiment(**kwargs):
   """Main called by evaluator"""
   return construct_intervals()