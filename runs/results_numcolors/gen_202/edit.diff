--- a/original.py
+++ b/original.py
@@ -1,183 +1,299 @@
 # EVOLVE-BLOCK-START
 
 def construct_intervals(seed_count=1):
-  """
-  Construct a sequence of intervals of real line,
-  in the order in which they are presented to FirstFit,
-  so that it maximizes the number of colors used by FirstFit
-  divided by the maximum number of intervals that cover a single point
-
-  The initial implementation uses the construction from
-  Figure 4 in https://arxiv.org/abs/1506.00192
-
-  Returns:
-    intervals: list of tuples, each tuple (l, r) represents an open interval from l to r
-  """
-
-  # Capacity guard to keep total intervals < 10000
-  CAP = 9800
-
-  # Use the classic fixed start-pattern to preserve strong KT coupling
-  spine_starts = (2, 6, 10, 14)
-
-  # Seed with multiple disjoint unit intervals if requested (new capability)
-  if seed_count <= 1:
-    T = [(0, 1)]
-  else:
-    step = 3
-    T = [(i * step, i * step + 1) for i in range(seed_count)]
-
-  # Stage 1: six KT rounds, sequential order to keep omega small and structure stable
-  for _ in range(6):
-    # Predict next size: size -> 4*size + 4; abort if it would exceed CAP
-    nxt_size = 4 * len(T) + 4
-    if nxt_size > CAP:
-      break
-    lo = min(l for l, r in T)
-    hi = max(r for l, r in T)
-    delta = hi - lo
-    if delta <= 0:
-      delta = 1
-    S = []
-    for start in spine_starts:
-      base = start * delta - lo
-      S.extend((l + base, r + base) for (l, r) in T)
-    # Classic connectors (Figure 4 style)
-    s0, s1, s2, s3 = spine_starts
-    connectors = [
-      ((s0 - 1) * delta, (s1 - 1) * delta),  # left cap
-      ((s2 + 2) * delta, (s3 + 2) * delta),  # right cap
-      ((s0 + 2) * delta, (s2 - 1) * delta),  # cross 1
-      ((s1 + 2) * delta, (s3 - 1) * delta),  # cross 2
+    """
+    Multi-stage KT-like spine with two guarded micro-phases and long-range cross4 connectors.
+    Returns a list of integer (l, r) tuples representing open intervals in FirstFit presentation order.
+
+    Parameters:
+      seed_count (int): small deterministic knob used to derive the global BASE_SEED.
+                        Behavior remains deterministic and reproducible.
+
+    Output: list of (l, r) integer tuples
+    """
+
+    # Hard capacity guard (keeps us under 10000 intervals)
+    CAP = 9800
+
+    # Deterministic global BASE_SEED derived from seed_count (keeps reproducibility)
+    BASE_SEED = max(1, int(seed_count) * 1009 + 1729)
+
+    # Classic four-start templates (we rotate among these)
+    TEMPLATE_BANK = [
+        (2, 6, 10, 14),
+        (1, 5, 9, 13),
+        (3, 7, 11, 15),
+        (4, 8, 12, 16),
     ]
-    S.extend(connectors)
-    T = S
-
-  # If we are already near the cap, return the strong baseline.
-  if len(T) >= CAP - 16:
-    return T
-
-  # Stage 2: Two delta2-driven micro extension rounds (thin sampling; four-start translations).
-  # Goals:
-  #  - Raise FF pressure via cross-scale coupling and interleaving parity,
-  #  - Keep omega in check by using thin seeds and sparse caps/connectors,
-  #  - Respect strict capacity guard.
-
-  def thin_seed(current_T, max_seed):
-    """Take a thin, evenly spaced sample of current_T of size <= max_seed."""
-    n = len(current_T)
-    if n == 0 or max_seed <= 0:
-      return []
-    step = max(1, n // max_seed)
-    U = current_T[::step][:max_seed]
-    return U
-
-  def micro_round(current_T, round_id, budget):
-    if budget <= 0 or not current_T:
-      return []
-
-    glo = min(l for l, r in current_T)
-    ghi = max(r for l, r in current_T)
-    G = max(1, ghi - glo)
-
-    # Use delta2 at half-scale to avoid expanding the global span too aggressively.
-    delta2 = max(1, G // 2)
-
-    # Thin seed: bounded and deterministic size to respect budget
-    # Keep micro blocks small: target at most ~ (budget//6) per block (four blocks + ~8 extras).
-    per_block_target = max(8, min(64, budget // 12))
-    U = thin_seed(current_T, per_block_target)
-
-    if not U:
-      return []
-
-    # Build four translated blocks using the same 4-start template,
-    # with deterministic parity-based interleaving policy:
-    # - Rounds with round_id % 2 == 0: forward interleave
-    # - Rounds with round_id % 2 == 1: reverse interleave
-    blocks = []
-    ulo = min(l for l, r in U)
-    for s in spine_starts:
-      base = s * delta2 - ulo
-      block = [(l + base, r + base) for (l, r) in U]
-      # Add a tiny deterministic internal reversal to break symmetry every other block
-      if ((s // 2) % 2) == (round_id % 2):
-        block = list(reversed(block))
-      blocks.append(block)
-
-    micro = []
-    if round_id % 2 == 0:
-      # Forward interleave
-      maxlen = max(len(b) for b in blocks)
-      for i in range(maxlen):
-        for blk in blocks:
-          if i < len(blk):
-            micro.append(blk[i])
-    else:
-      # Reverse interleave (swap block order)
-      maxlen = max(len(b) for b in blocks)
-      for i in range(maxlen):
-        for blk in reversed(blocks):
-          if i < len(blk):
-            micro.append(blk[i])
-
-    # Deterministic connectors at delta2 scale, including a cross3 extension
-    s0, s1, s2, s3 = spine_starts
-    connectors = [
-      ((s0 - 1) * delta2 + glo, (s1 - 1) * delta2 + glo),  # left cap (localized)
-      ((s2 + 2) * delta2 + glo, (s3 + 2) * delta2 + glo),  # right cap
-      ((s0 + 2) * delta2 + glo, (s2 - 1) * delta2 + glo),  # cross 1
-      ((s1 + 2) * delta2 + glo, (s3 - 1) * delta2 + glo),  # cross 2
-      ((s0 + 3) * delta2 + glo, (s3 + 3) * delta2 + glo),  # cross3 (longer range)
-    ]
-    micro.extend(connectors)
-
-    # Sparse micro caps: add three long but safe caps at half-scale
-    cap1 = (glo + (delta2 // 4), glo + int(1.8 * delta2))
-    cap2 = (glo + int(0.9 * delta2), glo + int(2.6 * delta2))
-    mid = glo + G // 2
-    cap3 = (mid - max(1, delta2 // 8), mid + max(1, delta2 // 8))
-    for cap in (cap1, cap2, cap3):
-      if cap[1] > cap[0]:
-        micro.append(cap)
-
-    # Enforce budget
-    if len(micro) > budget:
-      micro = micro[:budget]
-    return micro
-
-  # Execute two micro rounds with strong guards
-  remaining = CAP - len(T)
-  mr1 = micro_round(T, round_id=0, budget=max(0, remaining // 2))
-  if mr1:
-    room = CAP - len(T)
-    if len(mr1) > room:
-      mr1 = mr1[:room]
-    T.extend(mr1)
-
-  remaining = CAP - len(T)
-  mr2 = micro_round(T, round_id=1, budget=max(0, remaining))
-  if mr2:
-    room = CAP - len(T)
-    if len(mr2) > room:
-      mr2 = mr2[:room]
-    T.extend(mr2)
-
-  return T
-
-  # return [  # Figure 3, OPT=2, FF=4
-  #   (2,3),
-  #   (6,7),
-  #   (10,11),
-  #   (14,15),
-  #   (1,5),
-  #   (12,16),
-  #   (4,9),
-  #   (8,13),
-  # ]
+
+    # Primary spine settings
+    MAX_SPINE_ROUNDS = 6               # nominal target; will be capacity-checked
+    INITIAL_SEED = [(0, 1)]            # start with unit interval seed
+
+    # Cross4 connector enable (conservative)
+    CROSS4_ENABLED = True
+
+    # Helper: compute span and delta (integer)
+    def span_delta(T):
+        lo = min(l for l, r in T)
+        hi = max(r for l, r in T)
+        delta = hi - lo
+        if delta <= 0:
+            delta = 1
+        return lo, hi, delta
+
+    # Predictive growth: size -> 4*size + 4
+    def max_rounds_within_cap(initial_size, cap, max_rounds):
+        sz = initial_size
+        done = 0
+        for _ in range(max(0, int(max_rounds))):
+            nxt = 4 * sz + 4
+            if nxt > cap:
+                break
+            sz = nxt
+            done += 1
+        return done, sz
+
+    # Thin, even sampling of current_T up to max_seed elements
+    def thin_seed(current_T, max_seed):
+        n = len(current_T)
+        if n == 0 or max_seed <= 0:
+            return []
+        step = max(1, n // max_seed)
+        U = current_T[::step][:max_seed]
+        return U
+
+    # Round application: create four translated blocks, optional interleaving/reversal,
+    # add classical connectors and optional cross4 connector
+    def apply_spine_round(current_T, starts, do_interleave=False, reverse_block_parity=False, add_cross4=False):
+        lo, hi, delta = span_delta(current_T)
+
+        blocks = []
+        for s in starts:
+            base = s * delta - lo
+            block = [(l + base, r + base) for (l, r) in current_T]
+            blocks.append(block)
+
+        # Assembly policy: parity-based interleaving / reversal
+        S = []
+        if do_interleave:
+            order = list(range(4))
+            if reverse_block_parity:
+                order = list(reversed(order))
+            maxlen = max(len(b) for b in blocks)
+            for i in range(maxlen):
+                for idx in order:
+                    blk = blocks[idx]
+                    if i < len(blk):
+                        S.append(blk[i])
+        else:
+            if reverse_block_parity:
+                blocks = list(reversed(blocks))
+            for blk in blocks:
+                S.extend(blk)
+
+        # Classic connectors (integer endpoints)
+        s0, s1, s2, s3 = starts
+        # connectors computed relative to delta and shifted into global coordinates
+        connectors = [
+            ((s0 - 1) * delta, (s1 - 1) * delta),      # left cap
+            ((s2 + 2) * delta, (s3 + 2) * delta),      # right cap
+            ((s0 + 2) * delta, (s2 - 1) * delta),      # cross 1
+            ((s1 + 2) * delta, (s3 - 1) * delta),      # cross 2
+        ]
+        for c in connectors:
+            # ensure valid open interval and integer coordinates
+            a, b = int(c[0]), int(c[1])
+            if b <= a:
+                b = a + 1
+            S.append((a, b))
+
+        # Optional conservative cross4: long-range connector tying first and last block
+        if add_cross4 and CROSS4_ENABLED:
+            a = int((s0 + 4) * delta)
+            b = int((s3 + 4) * delta + max(1, delta // 8))
+            if b <= a:
+                b = a + 1
+            S.append((a, b))
+
+        return S
+
+    # Micro-round builder: takes a thin seed of current_T and clones it into multiple windows.
+    # Two distinct window families can be supplied to create different micro-phases.
+    def build_micro_round(current_T, budget, round_tag=0, window_fracs=None, local_scale_factor=0.5):
+        if not current_T or budget <= 4:
+            return []
+
+        glo = min(l for l, r in current_T)
+        ghi = max(r for l, r in current_T)
+        G = max(1, ghi - glo)
+
+        # local scale (delta2) is a fraction of the global span, but at least 1
+        delta2 = max(1, int(max(1, round(local_scale_factor * G))))
+
+        # seed: choose a small thin sample
+        per_block_target = max(8, min(64, budget // 12))
+        U = thin_seed(current_T, per_block_target)
+        if not U:
+            return []
+
+        ulo = min(l for l, r in U)
+
+        # default window family if none provided
+        if window_fracs is None:
+            window_fracs = [(0.12, 0.22), (0.35, 0.45), (0.58, 0.68), (0.80, 0.90)]
+
+        # deterministic tag-influenced ordering and small shifts
+        shift = ((round_tag * BASE_SEED) % 17) / 100.0  # tiny deterministic shift
+        blocks = []
+        for idx, (fa, fb) in enumerate(window_fracs):
+            # clamp to (0,1)
+            a_frac = max(0.01, min(0.95, fa + shift * ((idx % 3) - 1)))
+            # place the win_lo inside global span
+            win_lo = glo + int(round(a_frac * G))
+            base = win_lo - ulo
+            block = [(l + base, r + base) for (l, r) in U]
+            # deterministic micro-reversal pattern to break symmetry
+            if (idx + round_tag + (BASE_SEED % 3)) % 2 == 1:
+                block = list(reversed(block))
+            blocks.append(block)
+
+        # Interleave blocks to maximize color mixing in FirstFit
+        micro = []
+        maxlen = max(len(b) for b in blocks)
+        # Deterministic order permutation related to tag
+        order = list(range(len(blocks)))
+        if (round_tag + (BASE_SEED % 2)) % 2 == 1:
+            order.reverse()
+        for i in range(maxlen):
+            for idx in order:
+                blk = blocks[idx]
+                if i < len(blk):
+                    micro.append(blk[i])
+
+        # Add fractional-scale connectors (localized within [glo, ghi])
+        micro_connectors = [
+            (glo + int(round(0.08 * G)), glo + int(round(0.30 * G))),
+            (glo + int(round(0.60 * G)), glo + int(round(0.92 * G))),
+            (glo + int(round(0.26 * G)), glo + int(round(0.56 * G))),
+            (glo + int(round(0.44 * G)), glo + int(round(0.78 * G))),
+        ]
+        # occasionally include one longer connector to tie many windows
+        if (BASE_SEED + round_tag) % 2 == 0:
+            micro_connectors.append((glo + int(round(0.18 * G)), glo + int(round(0.84 * G))))
+
+        for a, b in micro_connectors:
+            if b <= a:
+                b = a + 1
+            micro.append((a, b))
+
+        # Trim micro to budget (keep first elements; order matters for FF adversary)
+        if len(micro) > budget:
+            micro = micro[:budget]
+
+        return micro
+
+    # ---------- Build spine ----------
+    T = list(INITIAL_SEED)
+
+    # determine safe depth for spine by predictive growth
+    predicted_depth, _ = max_rounds_within_cap(len(T), CAP - 128, MAX_SPINE_ROUNDS)
+    # we want at least 3 rounds but not exceed MAX_SPINE_ROUNDS
+    spine_rounds = max(1, min(MAX_SPINE_ROUNDS, predicted_depth))
+    # but be conservative: don't always push to predicted depth, keep 4 typical
+    spine_rounds = min(spine_rounds, 6)
+
+    for ridx in range(spine_rounds):
+        # choose template (rotate)
+        starts = TEMPLATE_BANK[ridx % len(TEMPLATE_BANK)]
+        # capacity predictive check
+        if 4 * len(T) + 4 > CAP:
+            break
+        # parity-based policies
+        do_interleave = (ridx % 2 == 0)
+        reverse_parity = (ridx % 2 == 1)
+        # Add cross4 only on later spine rounds to avoid early omega spikes
+        add_cross4 = (ridx >= max(0, spine_rounds - 2))
+        T = apply_spine_round(T, starts, do_interleave=do_interleave, reverse_block_parity=reverse_parity, add_cross4=add_cross4)
+        if len(T) >= CAP - 64:
+            break
+
+    # Guard: if near capacity return truncated T
+    if len(T) >= CAP - 32:
+        return T[:CAP]
+
+    # ---------- Micro-Phase A (window family A) ----------
+    remaining = CAP - len(T)
+    if remaining > 8:
+        window_family_A = [(0.12, 0.22), (0.35, 0.45), (0.58, 0.68), (0.80, 0.90)]
+        # micro-phase A uses local_scale_factor ~ 0.45 to stay inside global span
+        budgetA = min(remaining // 2, 1200)
+        microA = build_micro_round(T, budgetA, round_tag=1, window_fracs=window_family_A, local_scale_factor=0.45)
+        if microA:
+            if len(microA) > remaining:
+                microA = microA[:remaining]
+            T.extend(microA)
+
+    # Re-check capacity
+    if len(T) >= CAP - 16:
+        return T[:CAP]
+
+    # ---------- Micro-Phase B (distinct window family seeded from spine) ----------
+    remaining = CAP - len(T)
+    if remaining > 8:
+        # a second, shifted window family per the recommendations
+        window_family_B = [(0.05, 0.15), (0.28, 0.38), (0.60, 0.70), (0.82, 0.92)]
+        budgetB = min(remaining, 2200)
+        # seed micro-phase B deterministically from a function of the spine's lo/hi to ensure coupling
+        lo, hi, _ = span_delta(T)
+        # Use round_tag derived from lo and BASE_SEED to vary deterministic ordering
+        round_tag_B = (BASE_SEED + (lo % 997)) % 97
+        microB = build_micro_round(T, budgetB, round_tag=round_tag_B, window_fracs=window_family_B, local_scale_factor=0.5)
+        if microB:
+            if len(microB) > remaining:
+                microB = microB[:remaining]
+            # insert microB near the tail (to overlap many active colors)
+            # insertion strategy: append but with a few long caps placed first to spread pressure
+            # create two long safe caps derived from span
+            glo = min(l for l, r in T)
+            ghi = max(r for l, r in T)
+            G = max(1, ghi - glo)
+            long_caps = [
+                (glo + int(round(0.10 * G)), glo + int(round(0.60 * G))),
+                (glo + int(round(0.30 * G)), glo + int(round(0.85 * G))),
+            ]
+            # append caps first (if there's room)
+            for cap in long_caps:
+                if len(T) >= CAP:
+                    break
+                a, b = cap
+                if b <= a:
+                    b = a + 1
+                T.append((int(a), int(b)))
+            # then append the micro-blocks
+            T.extend(microB)
+
+    # Final capacity trim & normalization to integers
+    if len(T) > CAP:
+        T = T[:CAP]
+
+    # Ensure integer coordinates (already mostly ints) and non-degenerate intervals
+    final = []
+    for (l, r) in T:
+        li = int(round(l))
+        ri = int(round(r))
+        if ri <= li:
+            ri = li + 1
+        final.append((li, ri))
+
+    # Truncate once more if rounding changed size
+    if len(final) > CAP:
+        final = final[:CAP]
+
+    return final
 
 # EVOLVE-BLOCK-END
 
 def run_experiment(**kwargs):
   """Main called by evaluator"""
   return construct_intervals()