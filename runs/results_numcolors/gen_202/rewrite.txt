# EVOLVE-BLOCK-START

def construct_intervals(seed_count=1):
    """
    Multi-stage KT-like spine with two guarded micro-phases and long-range cross4 connectors.
    Returns a list of integer (l, r) tuples representing open intervals in FirstFit presentation order.

    Parameters:
      seed_count (int): small deterministic knob used to derive the global BASE_SEED.
                        Behavior remains deterministic and reproducible.

    Output: list of (l, r) integer tuples
    """

    # Hard capacity guard (keeps us under 10000 intervals)
    CAP = 9800

    # Deterministic global BASE_SEED derived from seed_count (keeps reproducibility)
    BASE_SEED = max(1, int(seed_count) * 1009 + 1729)

    # Classic four-start templates (we rotate among these)
    TEMPLATE_BANK = [
        (2, 6, 10, 14),
        (1, 5, 9, 13),
        (3, 7, 11, 15),
        (4, 8, 12, 16),
    ]

    # Primary spine settings
    MAX_SPINE_ROUNDS = 6               # nominal target; will be capacity-checked
    INITIAL_SEED = [(0, 1)]            # start with unit interval seed

    # Cross4 connector enable (conservative)
    CROSS4_ENABLED = True

    # Helper: compute span and delta (integer)
    def span_delta(T):
        lo = min(l for l, r in T)
        hi = max(r for l, r in T)
        delta = hi - lo
        if delta <= 0:
            delta = 1
        return lo, hi, delta

    # Predictive growth: size -> 4*size + 4
    def max_rounds_within_cap(initial_size, cap, max_rounds):
        sz = initial_size
        done = 0
        for _ in range(max(0, int(max_rounds))):
            nxt = 4 * sz + 4
            if nxt > cap:
                break
            sz = nxt
            done += 1
        return done, sz

    # Thin, even sampling of current_T up to max_seed elements
    def thin_seed(current_T, max_seed):
        n = len(current_T)
        if n == 0 or max_seed <= 0:
            return []
        step = max(1, n // max_seed)
        U = current_T[::step][:max_seed]
        return U

    # Round application: create four translated blocks, optional interleaving/reversal,
    # add classical connectors and optional cross4 connector
    def apply_spine_round(current_T, starts, do_interleave=False, reverse_block_parity=False, add_cross4=False):
        lo, hi, delta = span_delta(current_T)

        blocks = []
        for s in starts:
            base = s * delta - lo
            block = [(l + base, r + base) for (l, r) in current_T]
            blocks.append(block)

        # Assembly policy: parity-based interleaving / reversal
        S = []
        if do_interleave:
            order = list(range(4))
            if reverse_block_parity:
                order = list(reversed(order))
            maxlen = max(len(b) for b in blocks)
            for i in range(maxlen):
                for idx in order:
                    blk = blocks[idx]
                    if i < len(blk):
                        S.append(blk[i])
        else:
            if reverse_block_parity:
                blocks = list(reversed(blocks))
            for blk in blocks:
                S.extend(blk)

        # Classic connectors (integer endpoints)
        s0, s1, s2, s3 = starts
        # connectors computed relative to delta and shifted into global coordinates
        connectors = [
            ((s0 - 1) * delta, (s1 - 1) * delta),      # left cap
            ((s2 + 2) * delta, (s3 + 2) * delta),      # right cap
            ((s0 + 2) * delta, (s2 - 1) * delta),      # cross 1
            ((s1 + 2) * delta, (s3 - 1) * delta),      # cross 2
        ]
        for c in connectors:
            # ensure valid open interval and integer coordinates
            a, b = int(c[0]), int(c[1])
            if b <= a:
                b = a + 1
            S.append((a, b))

        # Optional conservative cross4: long-range connector tying first and last block
        if add_cross4 and CROSS4_ENABLED:
            a = int((s0 + 4) * delta)
            b = int((s3 + 4) * delta + max(1, delta // 8))
            if b <= a:
                b = a + 1
            S.append((a, b))

        return S

    # Micro-round builder: takes a thin seed of current_T and clones it into multiple windows.
    # Two distinct window families can be supplied to create different micro-phases.
    def build_micro_round(current_T, budget, round_tag=0, window_fracs=None, local_scale_factor=0.5):
        if not current_T or budget <= 4:
            return []

        glo = min(l for l, r in current_T)
        ghi = max(r for l, r in current_T)
        G = max(1, ghi - glo)

        # local scale (delta2) is a fraction of the global span, but at least 1
        delta2 = max(1, int(max(1, round(local_scale_factor * G))))

        # seed: choose a small thin sample
        per_block_target = max(8, min(64, budget // 12))
        U = thin_seed(current_T, per_block_target)
        if not U:
            return []

        ulo = min(l for l, r in U)

        # default window family if none provided
        if window_fracs is None:
            window_fracs = [(0.12, 0.22), (0.35, 0.45), (0.58, 0.68), (0.80, 0.90)]

        # deterministic tag-influenced ordering and small shifts
        shift = ((round_tag * BASE_SEED) % 17) / 100.0  # tiny deterministic shift
        blocks = []
        for idx, (fa, fb) in enumerate(window_fracs):
            # clamp to (0,1)
            a_frac = max(0.01, min(0.95, fa + shift * ((idx % 3) - 1)))
            # place the win_lo inside global span
            win_lo = glo + int(round(a_frac * G))
            base = win_lo - ulo
            block = [(l + base, r + base) for (l, r) in U]
            # deterministic micro-reversal pattern to break symmetry
            if (idx + round_tag + (BASE_SEED % 3)) % 2 == 1:
                block = list(reversed(block))
            blocks.append(block)

        # Interleave blocks to maximize color mixing in FirstFit
        micro = []
        maxlen = max(len(b) for b in blocks)
        # Deterministic order permutation related to tag
        order = list(range(len(blocks)))
        if (round_tag + (BASE_SEED % 2)) % 2 == 1:
            order.reverse()
        for i in range(maxlen):
            for idx in order:
                blk = blocks[idx]
                if i < len(blk):
                    micro.append(blk[i])

        # Add fractional-scale connectors (localized within [glo, ghi])
        micro_connectors = [
            (glo + int(round(0.08 * G)), glo + int(round(0.30 * G))),
            (glo + int(round(0.60 * G)), glo + int(round(0.92 * G))),
            (glo + int(round(0.26 * G)), glo + int(round(0.56 * G))),
            (glo + int(round(0.44 * G)), glo + int(round(0.78 * G))),
        ]
        # occasionally include one longer connector to tie many windows
        if (BASE_SEED + round_tag) % 2 == 0:
            micro_connectors.append((glo + int(round(0.18 * G)), glo + int(round(0.84 * G))))

        for a, b in micro_connectors:
            if b <= a:
                b = a + 1
            micro.append((a, b))

        # Trim micro to budget (keep first elements; order matters for FF adversary)
        if len(micro) > budget:
            micro = micro[:budget]

        return micro

    # ---------- Build spine ----------
    T = list(INITIAL_SEED)

    # determine safe depth for spine by predictive growth
    predicted_depth, _ = max_rounds_within_cap(len(T), CAP - 128, MAX_SPINE_ROUNDS)
    # we want at least 3 rounds but not exceed MAX_SPINE_ROUNDS
    spine_rounds = max(1, min(MAX_SPINE_ROUNDS, predicted_depth))
    # but be conservative: don't always push to predicted depth, keep 4 typical
    spine_rounds = min(spine_rounds, 6)

    for ridx in range(spine_rounds):
        # choose template (rotate)
        starts = TEMPLATE_BANK[ridx % len(TEMPLATE_BANK)]
        # capacity predictive check
        if 4 * len(T) + 4 > CAP:
            break
        # parity-based policies
        do_interleave = (ridx % 2 == 0)
        reverse_parity = (ridx % 2 == 1)
        # Add cross4 only on later spine rounds to avoid early omega spikes
        add_cross4 = (ridx >= max(0, spine_rounds - 2))
        T = apply_spine_round(T, starts, do_interleave=do_interleave, reverse_block_parity=reverse_parity, add_cross4=add_cross4)
        if len(T) >= CAP - 64:
            break

    # Guard: if near capacity return truncated T
    if len(T) >= CAP - 32:
        return T[:CAP]

    # ---------- Micro-Phase A (window family A) ----------
    remaining = CAP - len(T)
    if remaining > 8:
        window_family_A = [(0.12, 0.22), (0.35, 0.45), (0.58, 0.68), (0.80, 0.90)]
        # micro-phase A uses local_scale_factor ~ 0.45 to stay inside global span
        budgetA = min(remaining // 2, 1200)
        microA = build_micro_round(T, budgetA, round_tag=1, window_fracs=window_family_A, local_scale_factor=0.45)
        if microA:
            if len(microA) > remaining:
                microA = microA[:remaining]
            T.extend(microA)

    # Re-check capacity
    if len(T) >= CAP - 16:
        return T[:CAP]

    # ---------- Micro-Phase B (distinct window family seeded from spine) ----------
    remaining = CAP - len(T)
    if remaining > 8:
        # a second, shifted window family per the recommendations
        window_family_B = [(0.05, 0.15), (0.28, 0.38), (0.60, 0.70), (0.82, 0.92)]
        budgetB = min(remaining, 2200)
        # seed micro-phase B deterministically from a function of the spine's lo/hi to ensure coupling
        lo, hi, _ = span_delta(T)
        # Use round_tag derived from lo and BASE_SEED to vary deterministic ordering
        round_tag_B = (BASE_SEED + (lo % 997)) % 97
        microB = build_micro_round(T, budgetB, round_tag=round_tag_B, window_fracs=window_family_B, local_scale_factor=0.5)
        if microB:
            if len(microB) > remaining:
                microB = microB[:remaining]
            # insert microB near the tail (to overlap many active colors)
            # insertion strategy: append but with a few long caps placed first to spread pressure
            # create two long safe caps derived from span
            glo = min(l for l, r in T)
            ghi = max(r for l, r in T)
            G = max(1, ghi - glo)
            long_caps = [
                (glo + int(round(0.10 * G)), glo + int(round(0.60 * G))),
                (glo + int(round(0.30 * G)), glo + int(round(0.85 * G))),
            ]
            # append caps first (if there's room)
            for cap in long_caps:
                if len(T) >= CAP:
                    break
                a, b = cap
                if b <= a:
                    b = a + 1
                T.append((int(a), int(b)))
            # then append the micro-blocks
            T.extend(microB)

    # Final capacity trim & normalization to integers
    if len(T) > CAP:
        T = T[:CAP]

    # Ensure integer coordinates (already mostly ints) and non-degenerate intervals
    final = []
    for (l, r) in T:
        li = int(round(l))
        ri = int(round(r))
        if ri <= li:
            ri = li + 1
        final.append((li, ri))

    # Truncate once more if rounding changed size
    if len(final) > CAP:
        final = final[:CAP]

    return final

# EVOLVE-BLOCK-END