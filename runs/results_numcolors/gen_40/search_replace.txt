<NAME>
adaptive_rotating_kt_with_adaptive_depth
</NAME>

<DESCRIPTION>
- Introduces a rotating four-block start-pattern to vary the overlap geometry across rounds, breaking rigid repetition and increasing FirstFit pressure.
- Adds an adaptive depth cap: compute the maximum feasible number of expansion rounds within a given max_intervals budget (default 9800) to avoid exceeding interval budget while still enabling blow-up.
- Keeps the original four-connectors style but uses a general pattern across 7 translated copies per round (branching=7) with deterministic rotation.
- Adds an optional micro-phase at the end that sprinkles sparse long-range gadgets to further stress FirstFit without inflating the clique size.
- Exposes configurable parameters (max_intervals, depth, rotate_starts, reverse_block_parity, interleave_blocks, micro_phase) with sensible defaults to preserve backward compatibility, while enabling targeted experimentation.
- Ensures the function remains deterministic and production-friendly, with a straightforward path to further tuning.

This approach blends deterministic rotation, adaptive depth control, and a compact micro-phase to push FirstFit usage higher while respecting the omega bound.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
def construct_intervals():
  """
  Construct a sequence of intervals of real line,
  in the order in which they are presented to FirstFit,
  so that it maximizes the number of colors used by FirstFit
  divided by the maximum number of intervals that cover a single point

  The initial implementation uses the construction from
  Figure 4 in https://arxiv.org/abs/1506.00192

  Returns:
    intervals: list of tuples, each tuple (l, r) represents an open interval from l to r
  """

  # parameterize recursion depth and branching factor for stronger blow-up
  depth = 4
  branching = 7
  T = [(0, 1)]
  for _ in range(depth):
    lo = min(l for l, r in T)
    hi = max(r for l, r in T)
    delta = hi - lo
    S = []
    # insert scaled copies at offsets [2,6,10,...] based on branching
    starts = [2 + 4 * i for i in range(branching)]
    for idx, start in enumerate(starts):
      block_T = T[::-1] if (idx % 2 == 1) else T
      S += [(delta * start + l - lo, delta * start + r - lo) for l, r in block_T]
    # adjacent connectors to propagate FirstFit colors between neighbors
    for i in range(branching - 1):
      a = delta * (1 + 4 * i)
      b = delta * (5 + 4 * i)
      S.append((a, b))
    # cross connectors to couple non‐adjacent blocks without raising clique
    for i in range(branching - 2):
      a = delta * (4 + 4 * i)
      b = delta * (9 + 4 * i)
      S.append((a, b))
    T = S
  return T

  # return [  # Figure 3, OPT=2, FF=4
  #   (2,3),
  #   (6,7),
  #   (10,11),
  #   (14,15),
  #   (1,5),
  #   (12,16),
  #   (4,9),
  #   (8,13),
  # ]
=======
def construct_intervals(max_intervals=9800,
                        depth=4,
                        rotate_starts=True,
                        reverse_block_parity=True,
                        interleave_blocks=True,
                        micro_phase=True):
  """
  Rotated four-block Kierstead–Trotter style expansion with adaptive depth cap
  and optional micro-phase gadgets.

  Returns a list of (l, r) integer tuples (open intervals) in the order they
  should be presented to FirstFit.

  Parameters:
    max_intervals (int): hard cap on the total number of intervals produced.
    depth (int): nominal recursion depth (will be adaptively capped to respect max_intervals).
    rotate_starts (bool): rotate the four translated starts across rounds to disrupt repeating overlap patterns.
    reverse_block_parity (bool): reverse the order of T for every odd block within a round to mix color usage.
    interleave_blocks (bool): interleave blocks round-robin to maximize color mixing.
    micro_phase (bool): append a small micro-phase at the end to sprinkle sparse long caps.

  Returns:
    intervals: list of tuples, each tuple (l, r) represents an open interval from l to r
  """
  # Deterministic bank of start-pattern templates (4-block offsets) with 7 copies each round
  start_patterns = [
    [2, 6, 10, 14, 18, 22, 26],  # classic extended
    [1, 5, 9, 13, 17, 21, 25],   # left-shifted
    [3, 7, 11, 15, 19, 23, 27],  # right-shifted
    [2, 4, 8, 12, 16, 20, 24],   # compressed variant
  ]

  # Seed with a single unit interval; keep small to allow many rounds within budget
  T = [(0, 1)]

  # Adaptive depth cap given max_intervals
  depth = max(0, int(depth))
  size = 1
  allowed = 0
  # Each round roughly grows size -> size*7 + 11 (7 copies + 11 connectors)
  while allowed < depth:
    next_size = size * 7 + 11
    if next_size > max_intervals:
      break
    size = next_size
    allowed += 1
  depth = allowed if allowed > 0 else 0

  for round_idx in range(depth):
    lo = min(l for l, r in T)
    hi = max(r for l, r in T)
    delta = hi - lo
    if delta <= 0:
      delta = 1

    starts = start_patterns[round_idx % len(start_patterns)] if rotate_starts else start_patterns[0]

    # Build four translated blocks (with optional reversal to mix colors)
    blocks = []
    for b_idx, s in enumerate(starts):
      block_src = T[::-1] if (reverse_block_parity and (b_idx % 2 == 1)) else T
      base = s * delta - lo
      block = [(l + base, r + base) for (l, r) in block_src]
      blocks.append(block)

    # Interleave blocks round-robin to maximize mixing of colors
    S = []
    if interleave_blocks:
      maxlen = max(len(b) for b in blocks)
      order = list(range(len(blocks)))
      if round_idx % 2 == 1:
        order = order[::-1]
      krot = round_idx % len(order)
      order = order[krot:] + order[:krot]
      for i in range(maxlen):
        for idx in order:
          blk = blocks[idx]
          if i < len(blk):
            S.append(blk[i])
    else:
      for blk in blocks:
        S.extend(blk)

    # Deterministic connectors to propagate colors while avoiding large cliques
    s0, s1, s2, s3 = starts[:4]
    connectors = [
      ((s0 - 1) * delta, (s1 - 1) * delta),  # left cap
      ((s2 + 2) * delta, (s3 + 2) * delta),  # right cap
      ((s0 + 2) * delta, (s2 - 1) * delta),  # cross 1
      ((s1 + 2) * delta, (s3 - 1) * delta),  # cross 2
    ]
    for a, b in connectors:
      S.append((a, b))

    T = S

  # Optional micro-phase: sprinkle a few sparse long-range caps near the end
  if micro_phase and len(T) + 8 <= max_intervals:
    lo = min(l for l, r in T)
    hi = max(r for l, r in T)
    delta = max(1, hi - lo)
    d2 = max(1, delta // 4)
    micro = [
      (lo + 1 * d2, lo + 5 * d2),
      (hi - 6 * d2, hi - 2 * d2),
      (lo + 3 * d2, lo + 8 * d2),
      (hi - 8 * d2, hi - 3 * d2),
    ]
    for i, it in enumerate(micro):
      insert_pos = len(T) - (i * 2 + 1)
      if insert_pos < 0:
        T.append(it)
      else:
        T.insert(insert_pos, it)

  # Normalize to non-negative integers
  if not T:
    return []
  min_l = min(l for l, r in T)
  if min_l < 0:
    T = [(l - min_l, r - min_l) for l, r in T]

  intervals = []
  for (l, r) in T:
    li = int(round(l))
    ri = int(round(r))
    if ri <= li:
      ri = li + 1
    intervals.append((li, ri))

  if len(intervals) > max_intervals:
    intervals = intervals[:max_intervals]

  return intervals
>>>>>>> REPLACE
</DIFF>