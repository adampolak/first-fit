--- a/original.py
+++ b/original.py
@@ -1,78 +1,89 @@
 # EVOLVE-BLOCK-START
 
 def construct_intervals(rounds=3, seed_lo=0.0, seed_scale=1.0):
     """
-    Construct a sequence of open intervals that FirstFit colors online,
-    aiming to maximize FF-colors / clique-size (omega).
-    - rounds: number of recursive expansion rounds
-    - seed_lo, seed_scale: initial placement and scale knobs
-    Returns: list of (l, r) intervals in arrival order.
+    Enhanced fractal-wave expansion for FirstFit pressure.
+    - rounds: recursion depth
+    - seed_lo / seed_scale: deterministic location and scale knobs
+    Returns: list of intervals (l, r) as open intervals
     """
-    # Seed with several disjoint unit intervals for early overlap coupling
+    # Seed with four disjoint unit intervals for early coupling
     T = [
         (seed_lo, seed_lo + 1.0 * seed_scale),
         (seed_lo + 2.0 * seed_scale, seed_lo + 3.0 * seed_scale),
         (seed_lo + 4.0 * seed_scale, seed_lo + 5.0 * seed_scale),
         (seed_lo + 6.0 * seed_scale, seed_lo + 7.0 * seed_scale),
     ]
 
-    # Four-interval gadget templates
+    # Four-interval gadget templates (A, B, C, D)
     templates = [
-        [(1, 5),   (12, 16), (4, 9),  (8, 13)],   # A
-        [(0.5,4.5),(11,15),  (3.5,8.5),(7,12)],    # B
-        [(1,4),   (6,9),    (3,7),   (9,13)],     # C
-        [(2,6),   (7,11),   (0,3),   (10,14)],    # D
+        [(1, 5), (12, 16), (4, 9), (8, 13)],   # A
+        [(0.5, 4.5), (11, 15), (3.5, 8.5), (7, 12)],  # B
+        [(1, 4), (6, 9), (3, 7), (9, 13)],      # C
+        [(2, 6), (7, 11), (0, 3), (10, 14)],     # D
     ]
-    # Deterministic cycle of start-patterns
+
+    # Deterministic start-pattern cycles (offset/denser waves)
     start_patterns = [
-        (2,6,10,14),                   # compact 4-wave
-        (2,4,6,8,10,12,14,16),         # dense 8-wave
-        (2,5,8,11,14,17,20),           # staggered 7-wave
+        (2, 6, 10, 14),               # baseline compact wave
+        (2, 4, 6, 8, 10, 12, 14, 16), # dense wave
+        (2, 5, 8, 11, 14, 17, 20),    # staggered wave
+        (1, 3, 5, 7, 9, 11, 13, 15),   # alternate offset wave
     ]
 
     for round_idx in range(rounds):
         lo = min(l for l, r in T)
         hi = max(r for l, r in T)
         delta = hi - lo if hi > lo else 1.0
 
-        # pick start pattern and template for this round
+        # Choose deterministic pattern/template for this round
         starts = list(start_patterns[round_idx % len(start_patterns)])
         template = templates[round_idx % len(templates)]
 
         S = []
-        # clone T into shifted blocks, reversing on odd indices
+        # Clone T into translated blocks, alternating inner order
         for idx, start in enumerate(starts):
             base = T if (idx % 2 == 0) else list(reversed(T))
-            # translate each interval in base
-            for (l, r) in base:
+            for l, r in base:
                 S.append((delta * start + l - lo, delta * start + r - lo))
-            # light bridge to next block
+
+            # Bridge between consecutive blocks
             if idx + 1 < len(starts):
-                nxt = starts[idx+1]
-                S.append((delta*(start+0.5), delta*(nxt+0.5)))
+                nxt = starts[idx + 1]
+                S.append((delta * (start + 0.5), delta * (nxt + 0.5)))
 
-        # add the chosen gadget template scaled
-        for (a, b) in template:
-            S.append((delta*a, delta*b))
+            # Optional second-next bridge to couple across three blocks
+            if (round_idx % 2 == 0) and (idx + 2 < len(starts)):
+                nxt2 = starts[idx + 2]
+                S.append((delta * (start + 0.75), delta * (nxt2 + 0.25)))
 
-        # short caps around each start to press local FF usages
-        cap_radius = 0.3
-        cap_length = 1.2
-        for start in starts:
-            mid = delta*start
-            S.append((mid - cap_radius, mid + cap_length))
+        # Append the chosen gadget template scaled by delta
+        S += [(delta * a, delta * b) for (a, b) in template]
 
-        # longer sparse caps spanning blocks to couple distant colors
+        # Micro-gadget injected inside the middle block to raise local FF pressure
+        middle = starts[len(starts) // 2]
+        micro_template = templates[(round_idx + 2) % len(templates)]
+        S += [(delta * (middle + a / 16.0), delta * (middle + b / 16.0)) for (a, b) in micro_template]
+
+        # Sparse cap families to press FF without large omega
         max_start = max(starts)
-        for j in range(3, max_start, max(3, max_start//4)):
-            S.append((delta*(j - 1), delta*(j + 2)))
+        cap1_step = max(2, int(max_start // 4))
+        cap2_step = max(3, int(max_start // 3))
+        for j in range(2, int(max_start) + 1, cap1_step):
+            S.append((delta * (j - 0.5), delta * (j + 1.0)))
+        for j in range(3, int(max_start) + 1, cap2_step):
+            S.append((delta * (j - 0.2), delta * (j + 2.0)))
 
         T = S
 
     return T
+
+def run_experiment(**kwargs):
+  """Main called by evaluator"""
+  return construct_intervals(**kwargs)
 
 # EVOLVE-BLOCK-END
 
 def run_experiment(**kwargs):
   """Main called by evaluator"""
   return construct_intervals()