# EVOLVE-BLOCK-START

def construct_intervals(rounds=3, seed_lo=0.0, seed_scale=1.0):
    """
    Enhanced fractal-wave expansion for FirstFit pressure.
    - rounds: recursion depth
    - seed_lo / seed_scale: deterministic location and scale knobs
    Returns: list of intervals (l, r) as open intervals
    """
    # Seed with four disjoint unit intervals for early coupling
    T = [
        (seed_lo, seed_lo + 1.0 * seed_scale),
        (seed_lo + 2.0 * seed_scale, seed_lo + 3.0 * seed_scale),
        (seed_lo + 4.0 * seed_scale, seed_lo + 5.0 * seed_scale),
        (seed_lo + 6.0 * seed_scale, seed_lo + 7.0 * seed_scale),
    ]

    # Four-interval gadget templates (A, B, C, D)
    templates = [
        [(1, 5), (12, 16), (4, 9), (8, 13)],   # A
        [(0.5, 4.5), (11, 15), (3.5, 8.5), (7, 12)],  # B
        [(1, 4), (6, 9), (3, 7), (9, 13)],      # C
        [(2, 6), (7, 11), (0, 3), (10, 14)],     # D
    ]

    # Deterministic start-pattern cycles (offset/denser waves)
    start_patterns = [
        (2, 6, 10, 14),               # baseline compact wave
        (2, 4, 6, 8, 10, 12, 14, 16), # dense wave
        (2, 5, 8, 11, 14, 17, 20),    # staggered wave
        (1, 3, 5, 7, 9, 11, 13, 15),   # alternate offset wave
    ]

    for round_idx in range(rounds):
        lo = min(l for l, r in T)
        hi = max(r for l, r in T)
        delta = hi - lo if hi > lo else 1.0

        # Choose deterministic pattern/template for this round
        starts = list(start_patterns[round_idx % len(start_patterns)])
        template = templates[round_idx % len(templates)]

        S = []
        # Clone T into translated blocks, alternating inner order
        for idx, start in enumerate(starts):
            base = T if (idx % 2 == 0) else list(reversed(T))
            for l, r in base:
                S.append((delta * start + l - lo, delta * start + r - lo))

            # Bridge between consecutive blocks
            if idx + 1 < len(starts):
                nxt = starts[idx + 1]
                S.append((delta * (start + 0.5), delta * (nxt + 0.5)))

            # Optional second-next bridge to couple across three blocks
            if (round_idx % 2 == 0) and (idx + 2 < len(starts)):
                nxt2 = starts[idx + 2]
                S.append((delta * (start + 0.75), delta * (nxt2 + 0.25)))

        # Append the chosen gadget template scaled by delta
        S += [(delta * a, delta * b) for (a, b) in template]

        # Micro-gadget injected inside the middle block to raise local FF pressure
        middle = starts[len(starts) // 2]
        micro_template = templates[(round_idx + 2) % len(templates)]
        S += [(delta * (middle + a / 16.0), delta * (middle + b / 16.0)) for (a, b) in micro_template]

        # Sparse cap families to press FF without large omega
        max_start = max(starts)
        cap1_step = max(2, int(max_start // 4))
        cap2_step = max(3, int(max_start // 3))
        for j in range(2, int(max_start) + 1, cap1_step):
            S.append((delta * (j - 0.5), delta * (j + 1.0)))
        for j in range(3, int(max_start) + 1, cap2_step):
            S.append((delta * (j - 0.2), delta * (j + 2.0)))

        T = S

    return T

def run_experiment(**kwargs):
  """Main called by evaluator"""
  return construct_intervals(**kwargs)

# EVOLVE-BLOCK-END