--- a/original.py
+++ b/original.py
@@ -1,168 +1,274 @@
 # EVOLVE-BLOCK-START
 
 def construct_intervals():
   """
-  Construct a sequence of intervals of real line,
-  in the order in which they are presented to FirstFit,
-  so that it maximizes the number of colors used by FirstFit
-  divided by the maximum number of intervals that cover a single point
-
-  The initial implementation uses the construction from
-  Figure 4 in https://arxiv.org/abs/1506.00192
-
-  Returns:
-    intervals: list of tuples, each tuple (l, r) represents an open interval from l to r
+  Construct a sequence of intervals on the real line,
+  presented to FirstFit in this order, attempting to maximize
+  FF colors divided by the clique number (omega).
+  Returns a list of (l, r) open intervals with integer endpoints.
   """
 
-  # Capacity guard to keep total intervals < 10000
+  # Hard capacity to keep total intervals < 10000
   CAP = 9800
 
-  # Use the classic fixed start-pattern to preserve strong KT coupling
-  starts = (2, 6, 10, 14)
+  # Global deterministic parameters
+  SPINE_TEMPLATES = [
+    (2, 6, 10, 14),  # classic KT
+    (1, 5, 9, 13),   # left-shifted
+    (3, 7, 11, 15),  # right-shifted
+    (4, 8, 12, 16),  # stretched
+  ]
+  DEFAULT_STARTS = (2, 6, 10, 14)
+
+  # Optional density knob for future experimentation (kept at 1 here).
+  K_DENSITY = 1  # can be toggled to 2 if evaluated safe; left at 1 for stability
+
+  # Stage 0: seed with one unit interval
   T = [(0, 1)]
-  for round_idx in range(6):
-    lo = min(l for l, r in T)
-    hi = max(r for l, r in T)
+
+  # -------------------------------
+  # Shared utilities
+  # -------------------------------
+  def span_info(seq):
+    lo = min(l for l, r in seq)
+    hi = max(r for l, r in seq)
     delta = hi - lo
-    # build translated blocks in sequence (no interleaving)
+    if delta <= 0:
+      delta = 1
+    return lo, hi, delta
+
+  def kt_connectors(starts, delta, base_shift=0):
+    s0, s1, s2, s3 = starts
+    cons = [
+      (base_shift + (s0 - 1) * delta, base_shift + (s1 - 1) * delta),  # left cap
+      (base_shift + (s2 + 2) * delta, base_shift + (s3 + 2) * delta),  # right cap
+      (base_shift + (s0 + 2) * delta, base_shift + (s2 - 1) * delta),  # cross 1
+      (base_shift + (s1 + 2) * delta, base_shift + (s3 - 1) * delta),  # cross 2
+    ]
+    return [(a, b) for (a, b) in cons if b > a]
+
+  def spine_round(current_T, starts, interleave=False, reverse_blocks=False, add_long=False):
+    lo, hi, delta = span_info(current_T)
+    # Build translated blocks
     blocks = []
-    for start in starts:
-      blocks.append([(delta * start + l - lo, delta * start + r - lo) for l, r in T])
+    for s in starts:
+      base = s * delta - lo
+      block = [(l + base, r + base) for (l, r) in current_T]
+      blocks.append(block[::-1] if reverse_blocks else block)
+
+    # Merge blocks
     S = []
-    # keep sequential order every round to stabilize omega and reproduce KT backbone
-    for blk in blocks:
-      S.extend(blk)
-    # connectors based on the fixed starts
-    s0, s1, s2, s3 = starts
-    connectors = [
-      (delta * (s0 - 1), delta * (s1 - 1)),  # left cap
-      (delta * (s2 + 2), delta * (s3 + 2)),  # right cap
-      (delta * (s0 + 2), delta * (s2 - 1)),  # cross 1
-      (delta * (s1 + 2), delta * (s3 - 1)),  # cross 2
+    if interleave:
+      maxlen = max(len(b) for b in blocks)
+      order = list(range(len(blocks)))
+      for i in range(maxlen):
+        for idx in order:
+          if i < len(blocks[idx]):
+            S.append(blocks[idx][i])
+    else:
+      for blk in blocks:
+        S.extend(blk)
+
+    # Add classic connectors
+    S.extend(kt_connectors(starts, delta, base_shift=0))
+    # Optionally add a longer connector to couple extremes
+    if add_long:
+      s0, s3 = starts[0], starts[3]
+      long_c = (int((s0 + 3) * delta), int((s3 + 3) * delta))
+      if long_c[1] > long_c[0]:
+        S.append(long_c)
+    return S
+
+  def predicted_next_size(sz):
+    # KT growth per round: 4*size + 4
+    return 4 * sz + 4
+
+  def thin_seed(current_T, max_seed):
+    n = len(current_T)
+    if n == 0 or max_seed <= 0:
+      return []
+    step = max(1, n // max_seed)
+    return current_T[::step][:max_seed]
+
+  def enforce_budget(seq, budget):
+    if budget <= 0:
+      return []
+    return seq[:budget] if len(seq) > budget else seq
+
+  # -------------------------------
+  # Stage 1: Deterministic KT spine
+  # -------------------------------
+  # Derive a deterministic per-round interleaving parity with seed = f(round_index)
+  # Even rounds: interleave, Odd: sequential; reverse block order on odd rounds for variety.
+  # Rotate templates each round to diversify positions while preserving clique control.
+  max_rounds = 6  # known to fit comfortably under CAP with some room for micro-phase
+  for ridx in range(max_rounds):
+    # Predict size; stop if we'd exceed CAP by too much (leave room for micro-phase)
+    nxt = predicted_next_size(len(T))
+    if nxt > CAP:
+      break
+
+    starts = SPINE_TEMPLATES[ridx % len(SPINE_TEMPLATES)]
+    # Parity discipline (deterministic, seedless)
+    interleave = (ridx % 2 == 0)
+    reverse_blocks = (ridx % 2 == 1)
+    add_long = (ridx % 2 == 0)
+    T = spine_round(T, starts, interleave=interleave, reverse_blocks=reverse_blocks, add_long=add_long)
+
+    # Bail if we unexpectedly hit CAP
+    if len(T) >= CAP:
+      T = T[:CAP]
+      return T
+
+  # If already near CAP, return spine-only baseline
+  if len(T) >= CAP - 16:
+    return T
+
+  # -------------------------------
+  # Stage 1.5: Near-tail sparse caps
+  # -------------------------------
+  # Insert a few long caps near the tail to raise FF mixing with minimal omega impact.
+  def insert_near_tail(seq, extra):
+    out = list(seq)
+    for i, iv in enumerate(extra):
+      pos = len(out) - (i * 2 + 1)
+      if pos < 0:
+        out.append(iv)
+      else:
+        out.insert(pos, iv)
+    return out
+
+  glo, ghi, G = span_info(T)
+  def cap_at(fr_a, fr_b):
+    L = glo + max(1, int(round(fr_a * G)))
+    R = glo + max(1, int(round(fr_b * G)))
+    if R <= L:
+      R = L + 1
+    return (L, R)
+
+  tail_caps = [cap_at(0.08, 0.60), cap_at(0.25, 0.75), cap_at(0.75, 0.92)]
+  room = CAP - len(T)
+  if room > 0:
+    T = insert_near_tail(T, tail_caps[:room])
+
+  if len(T) >= CAP - 24:
+    return T
+
+  # -------------------------------
+  # Stage 2: Two guarded micro-phases
+  # -------------------------------
+  # Primary micro-phase (A): windows with small deterministic shifts
+  # Secondary micro-phase (B): distinct alternate windows set, includes a cross4 layer
+
+  def build_micro_round(current_T, budget, iter_id=0, alt=False):
+    if not current_T or budget <= 8:
+      return []
+
+    glo = min(l for l, r in current_T)
+    ghi = max(r for l, r in current_T)
+    G = max(1, ghi - glo)
+
+    # Thin, evenly spaced seed â€” bounded by budget and overall size
+    seed_sz = max(8, min(40, len(current_T) // 250 if len(current_T) >= 250 else 16))
+    U = thin_seed(current_T, seed_sz)
+    if not U:
+      return []
+
+    ulo = min(l for l, r in U)
+
+    # Window sets
+    if not alt:
+      # Primary windows with a tiny, deterministic shift based on iter_id
+      shift = (iter_id % 3) * 0.02
+      fr_windows = [
+        (0.12 + shift, 0.22 + shift),
+        (0.35 + shift, 0.45 + shift),
+        (0.58 + shift, 0.68 + shift),
+        (0.80 + shift, 0.90 + shift),
+      ]
+    else:
+      # Alternate windows (distinct, fixed)
+      fr_windows = [(0.05, 0.15), (0.28, 0.38), (0.60, 0.70), (0.82, 0.92)]
+
+    # Clamp windows within (0,1)
+    fr_windows = [
+      (max(0.02, min(0.90, a)), max(0.10, min(0.98, b))) for (a, b) in fr_windows
     ]
-    for a, b in connectors:
-      S.append((a, b))
-    T = S
-  # Stage 2: Two delta2-driven micro extension rounds (thin sampling; four-start translations).
-  # Skip if near capacity.
-  if len(T) < CAP - 16:
-    def thin_seed(current_T, max_seed):
-      n = len(current_T)
-      if n == 0 or max_seed <= 0:
-        return []
-      step = max(1, n // max_seed)
-      return current_T[::step][:max_seed]
-
-    def micro_round(current_T, round_id, budget, scale_div=2, starts_override=None):
-      if budget <= 0 or not current_T:
-        return []
-      glo = min(l for l, r in current_T)
-      ghi = max(r for l, r in current_T)
-      G = max(1, ghi - glo)
-      # Use reduced scale to avoid expanding the global span too aggressively
-      delta2 = max(1, G // max(1, scale_div))
-
-      # Thin seed: bounded and deterministic size to respect budget
-      per_block_target = max(8, min(64, budget // 12))
-      U = thin_seed(current_T, per_block_target)
-      if not U:
-        return []
-
-      # Determine starts pattern
-      use_starts = starts_override if starts_override is not None else starts
-
-      # Build translated blocks using the use_starts template,
-      # with deterministic parity-based internal reversal
-      blocks = []
-      ulo = min(l for l, r in U)
-      for s in use_starts:
-        base = s * delta2 - ulo
-        block = [(l + base, r + base) for (l, r) in U]
-        if ((s // 2) % 2) == (round_id % 2):
-          block = list(reversed(block))
-        blocks.append(block)
-
-      micro = []
-      # Parity-based interleaving across blocks
-      maxlen = max(len(b) for b in blocks)
-      if round_id % 2 == 0:
-        for i in range(maxlen):
-          for blk in blocks:
-            if i < len(blk):
-              micro.append(blk[i])
-      else:
-        for i in range(maxlen):
-          for blk in reversed(blocks):
-            if i < len(blk):
-              micro.append(blk[i])
-
-      # Deterministic connectors at delta2 scale, including a longer cross3 and cross4
-      s0, s1, s2, s3 = use_starts
-      connectors = [
-        ((s0 - 1) * delta2 + glo, (s1 - 1) * delta2 + glo),  # left cap
-        ((s2 + 2) * delta2 + glo, (s3 + 2) * delta2 + glo),  # right cap
-        ((s0 + 2) * delta2 + glo, (s2 - 1) * delta2 + glo),  # cross 1
-        ((s1 + 2) * delta2 + glo, (s3 - 1) * delta2 + glo),  # cross 2
-        ((s0 + 3) * delta2 + glo, (s3 + 3) * delta2 + glo),  # cross3 (long range)
-        ((s0 + 4) * delta2 + glo, (s3 + 4) * delta2 + glo),  # cross4 (extra fine coupler)
-      ]
-      micro.extend(connectors)
-
-      # Sparse micro caps to press FirstFit locally without raising omega much
-      cap1 = (glo + (delta2 // 4), glo + int(1.8 * delta2))
-      cap2 = (glo + int(0.9 * delta2), glo + int(2.6 * delta2))
-      mid = glo + G // 2
-      cap3 = (mid - max(1, delta2 // 8), mid + max(1, delta2 // 8))
-      for cap in (cap1, cap2, cap3):
-        if cap[1] > cap[0]:
-          micro.append(cap)
-
-      # Enforce budget
-      if len(micro) > budget:
-        micro = micro[:budget]
-      return micro
-
-    remaining = CAP - len(T)
-    mr1 = micro_round(T, round_id=0, budget=max(0, remaining // 2))
-    if mr1:
-      room = CAP - len(T)
-      if len(mr1) > room:
-        mr1 = mr1[:room]
-      T.extend(mr1)
-
-    remaining = CAP - len(T)
-    mr2 = micro_round(T, round_id=1, budget=max(0, remaining))
-    if mr2:
-      room = CAP - len(T)
-      if len(mr2) > room:
-        mr2 = mr2[:room]
-      T.extend(mr2)
-
-    # Stage 3: Additional fine micro round at quarter-scale for extra FF pressure
-    remaining = CAP - len(T)
-    if remaining > 0:
-      mr3 = micro_round(T, round_id=2, budget=remaining, scale_div=4, starts_override=(3,7,11,15))
-      if mr3:
-        room = CAP - len(T)
-        if len(mr3) > room:
-          mr3 = mr3[:room]
-        T.extend(mr3)
+
+    # Build translated micro-blocks aligned to windows
+    blocks = []
+    for wi, (fa, fb) in enumerate(fr_windows):
+      win_lo = glo + int(round(fa * G))
+      base = win_lo - ulo
+      block = [(l + base, r + base) for (l, r) in U]
+      # Parity-based internal reversal per block for mixing
+      tag = iter_id + (1 if alt else 0)
+      if ((wi + tag) % 2) == 0:
+        block = list(reversed(block))
+      blocks.append(block)
+
+    # Interleave micro-blocks with parity discipline
+    micro = []
+    maxlen = max(len(b) for b in blocks)
+    order = list(range(len(blocks)))
+    if (iter_id % 2) == 1:
+      order.reverse()
+    for i in range(maxlen):
+      for idx in order:
+        blk = blocks[idx]
+        if i < len(blk):
+          micro.append(blk[i])
+
+    # Deterministic connectors across windows (fractional-span analog of KT caps)
+    # Always add the classic four; add an extra long cross4 layer when alt=True.
+    micro_connectors = [
+      (glo + int(round(0.08 * G)), glo + int(round(0.30 * G))),  # left cap
+      (glo + int(round(0.60 * G)), glo + int(round(0.92 * G))),  # right cap
+      (glo + int(round(0.26 * G)), glo + int(round(0.56 * G))),  # cross 1
+      (glo + int(round(0.44 * G)), glo + int(round(0.78 * G))),  # cross 2
+    ]
+    if alt:
+      # Cross4 layer: longer-range couplers to tie distant windows without dense stacking
+      micro_connectors.extend([
+        (glo + int(round(0.18 * G)), glo + int(round(0.84 * G))),
+        (glo + int(round(0.10 * G)), glo + int(round(0.70 * G))),
+        (glo + int(round(0.34 * G)), glo + int(round(0.96 * G))),
+      ])
+
+    for a, b in micro_connectors:
+      if b > a:
+        micro.append((a, b))
+
+    # Enforce budget
+    micro = enforce_budget(micro, budget)
+    return micro
+
+  # Execute primary micro-phase (A), then secondary (B), both budgeted
+  # Phase A: up to two iterations (iter_id = 0, 1)
+  for iter_id in range(2):
+    room = CAP - len(T)
+    if room <= 8:
+      break
+    microA = build_micro_round(T, budget=room, iter_id=iter_id, alt=False)
+    if not microA:
+      break
+    T.extend(enforce_budget(microA, CAP - len(T)))
+
+  # Phase B: a single alternate-window pass with cross4 layer
+  room = CAP - len(T)
+  if room > 8:
+    microB = build_micro_round(T, budget=room, iter_id=2, alt=True)
+    if microB:
+      T.extend(enforce_budget(microB, CAP - len(T)))
+
+  # Final cap
+  if len(T) > CAP:
+    T = T[:CAP]
 
   return T
-
-  # return [  # Figure 3, OPT=2, FF=4
-  #   (2,3),
-  #   (6,7),
-  #   (10,11),
-  #   (14,15),
-  #   (1,5),
-  #   (12,16),
-  #   (4,9),
-  #   (8,13),
-  # ]
 
 # EVOLVE-BLOCK-END
 
 def run_experiment(**kwargs):
   """Main called by evaluator"""
   return construct_intervals()