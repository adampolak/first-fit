--- a/original.py
+++ b/original.py
@@ -1,347 +1,313 @@
 # EVOLVE-BLOCK-START
 
 def construct_intervals(seed_count=1):
   """
-  Construct a sequence of intervals on the real line, in the order presented to FirstFit,
-  engineered to drive up FirstFit's color usage while keeping the maximum clique (omega) <= ~10.
-
-  Interface compatibility:
-    - Accepts seed_count (unused by evaluator, but supported).
-    - Returns a list of (l, r) integer tuples with r > l (open intervals).
+  Deterministic six-template spine plus a dual-pass micro-phase and tail connectors.
+  Returns a list of (l, r) integer tuples (open intervals) in FirstFit presentation order.
+
+  The design:
+    - Six KT-like rounds using six distinct templates (one per round).
+    - Deterministic interleaving/block-order schedules across rounds.
+    - Small per-round pin connectors (short intervals) to couple colors safely.
+    - Post-spine long-range connectors inserted near the tail.
+    - Two CAP-aware micro passes with disjoint window families and connectors.
+
+  Parameters:
+    seed_count (int): supported for compatibility; uses 1 by default.
+
+  Output:
+    intervals: list[(int l, int r)], with r > l.
   """
+
   CAP = 9800
 
-  # Rotating start templates (Kiersteadâ€“Trotter style)
-  template_bank = [
-    (2, 6, 10, 14),  # classic KT
-    (1, 5, 9, 13),   # left-shifted
-    (3, 7, 11, 15),  # right-shifted
-    (4, 8, 12, 16),  # stretched-right
+  # Six-template deterministic backbone (one per round)
+  templates = [
+    (2, 6, 10, 14),  # T0 classic KT
+    (1, 5, 9, 13),   # T1 left-shifted
+    (3, 7, 11, 15),  # T2 right-shifted
+    (4, 8, 12, 16),  # T3 stretched-right
+    (2, 5, 11, 14),  # T4 skewed symmetric
+    (1, 7, 9, 15),   # T5 wide skew
   ]
 
-  # Seed: single unit interval (multi-seed support capped defensively)
+  # Deterministic interleaving policy per round (True => interleave, False => sequential)
+  interleave_schedule = [True, False, True, True, False, True]
+
+  # Deterministic block order per round (indexes 0..3 into the four translated blocks)
+  block_orders = [
+    [0, 1, 2, 3],  # r0
+    [2, 0, 3, 1],  # r1
+    [1, 3, 0, 2],  # r2
+    [3, 1, 2, 0],  # r3
+    [0, 2, 1, 3],  # r4
+    [2, 3, 1, 0],  # r5
+  ]
+
+  # Small jitter per round per block to break translation symmetry (kept modest to protect omega)
+  jitter_sets = [
+    (-0.020,  0.015, -0.010,  0.020),  # for r0
+    ( 0.010, -0.015,  0.020, -0.010),  # for r1
+    (-0.015,  0.010,  0.015, -0.005),  # for r2
+    ( 0.005,  0.000, -0.005,  0.010),  # for r3
+    ( 0.000,  0.005,  0.010, -0.015),  # for r4
+    ( 0.015, -0.010,  0.005,  0.000),  # for r5
+  ]
+
+  # Seed with a single unit interval; support seed_count for compatibility
   if seed_count <= 1:
     T = [(0, 1)]
   else:
+    seeds = min(4, max(1, int(seed_count)))
     step = 3
-    seeds = min(4, max(1, int(seed_count)))
     T = [(i * step, i * step + 1) for i in range(seeds)]
 
-  def _span_delta(current_T):
+  def span_delta(current_T):
     lo = min(l for l, r in current_T)
     hi = max(r for l, r in current_T)
     delta = hi - lo
     if delta <= 0:
       delta = 1
     return lo, hi, delta
 
-  def _append_connectors(S, starts, delta):
-    # Four classic connectors that propagate color pressure without large omega jumps
+  def append_classic_connectors(S, starts, delta):
+    # KT-style four connectors
     s0, s1, s2, s3 = starts
     S.append(((s0 - 1) * delta, (s1 - 1) * delta))  # left cap
     S.append(((s2 + 2) * delta, (s3 + 2) * delta))  # right cap
     S.append(((s0 + 2) * delta, (s2 - 1) * delta))  # cross 1
     S.append(((s1 + 2) * delta, (s3 - 1) * delta))  # cross 2
 
-  def _apply_round(current_T, starts, do_interleave=False, reverse_order=False):
-    lo, hi, delta = _span_delta(current_T)
-
-    # Build four translated blocks
+  def add_round_pins(S, lo, delta, ridx):
+    # Short pins to couple colors locally without raising omega much.
+    # Enabled only on odd rounds to avoid stacking.
+    if ridx % 2 == 1:
+      eps = max(1, delta // 128)
+      pin_positions = [0.18, 0.82]
+      for pf in pin_positions:
+        L = lo + int(round(pf * delta))
+        R = L + eps
+        if R > L:
+          S.append((L, R))
+
+  def apply_backbone_round(current_T, starts, ridx):
+    lo, hi, delta = span_delta(current_T)
+    jvec = jitter_sets[ridx]
+
+    # Build four translated blocks with a small jitter perturbation
     blocks = []
-    for s in starts:
-      base = s * delta - lo
-      block = [(l + base, r + base) for (l, r) in current_T]
+    for idx, s in enumerate(starts):
+      base = int(round((s + jvec[idx]) * delta)) - lo
+      # reverse source ordering for odd blocks to reduce symmetry
+      src = current_T[::-1] if (idx % 2 == 1) else current_T
+      block = [(l + base, r + base) for (l, r) in src]
       blocks.append(block)
 
-    # Compose S with chosen policy
+    # Compose S: either interleaved or sequential via a deterministic order
     S = []
-    if do_interleave:
-      order = list(range(4))
-      if reverse_order:
-        order.reverse()
+    order = block_orders[ridx]
+    if interleave_schedule[ridx]:
       maxlen = max(len(b) for b in blocks)
       for i in range(maxlen):
         for idx in order:
           blk = blocks[idx]
           if i < len(blk):
             S.append(blk[i])
     else:
-      seq_blocks = list(reversed(blocks)) if reverse_order else blocks
-      for blk in seq_blocks:
-        S.extend(blk)
-
-    _append_connectors(S, starts, delta)
+      for idx in order:
+        S.extend(blocks[idx])
+
+    # Append classic connectors (scaled by delta)
+    append_classic_connectors(S, starts, delta)
+    # Add short pins for odd rounds (small, local coupling)
+    add_round_pins(S, lo, delta, ridx)
     return S
 
-  # Stage 1: Six KT-style rounds with parity-based interleaving
+  # Stage 1: Six-round deterministic spine
   for ridx in range(6):
-    starts = template_bank[ridx % len(template_bank)]
-    do_interleave = (ridx % 2 == 0)          # even: interleave
-    reverse_order = (ridx % 2 == 1)          # odd: reverse sequential
-    T = _apply_round(T, starts, do_interleave=do_interleave, reverse_order=reverse_order)
+    starts = templates[ridx]
+    T = apply_backbone_round(T, starts, ridx)
     if len(T) >= CAP:
-      return T[:CAP]
-
-  # Micro-phase A: a few long caps near the global span to mix late colors
-  if len(T) < CAP - 8:
-    lo, hi, delta = _span_delta(T)
-    def cap_at(a_frac, b_frac):
-      L = lo + max(1, int(round(a_frac * delta)))
-      R = lo + max(1, int(round(b_frac * delta)))
-      if R <= L:
-        R = L + 1
-      return (L, R)
-    caps = [cap_at(0.08, 0.60), cap_at(0.25, 0.75), cap_at(0.75, 0.92)]
-    room = CAP - len(T)
-    if room > 0:
-      caps = caps[:room]
-      # Insert near the tail to avoid disrupting early structure
-      for i, iv in enumerate(caps):
-        pos = len(T) - (i * 2 + 1)
-        if pos < 0:
-          T.append(iv)
-        else:
-          T.insert(pos, iv)
-
-  if len(T) >= CAP - 16:
-    return T[:CAP]
-
-  # Helper: thin evenly-spaced seed from T
-  def _thin_seed(current_T, max_seed):
-    n = len(current_T)
-    if n == 0 or max_seed <= 0:
+      T = T[:CAP]
+      break
+
+  if len(T) >= CAP - 8:
+    # Near capacity; return strong baseline
+    # Normalize and exit.
+    intervals = []
+    min_l = min(l for l, r in T) if T else 0
+    if min_l < 0:
+      T = [(l - min_l, r - min_l) for (l, r) in T]
+    for (l, r) in T[:CAP]:
+      li = int(l)
+      ri = int(r)
+      if ri <= li:
+        ri = li + 1
+      intervals.append((li, ri))
+    return intervals
+
+  # Utility: insert intervals near tail of sequence
+  def insert_near_tail(seq, intervals):
+    out = list(seq)
+    for i, iv in enumerate(intervals):
+      pos = len(out) - (2 * i + 1)
+      if pos < 0:
+        out.append(iv)
+      else:
+        out.insert(pos, iv)
+    return out
+
+  # Stage 1.5: deterministic long-range connectors added near the tail (post-spine only)
+  lo, hi, G = span_delta(T)
+  tail_connectors = [
+    (lo + int(round(0.11 * G)), lo + int(round(0.51 * G))),
+    (lo + int(round(0.24 * G)), lo + int(round(0.76 * G))),
+    (lo + int(round(0.42 * G)), lo + int(round(0.86 * G))),
+    (lo + int(round(0.18 * G)), lo + int(round(0.90 * G))),
+  ]
+  tail_connectors = [(a, b) for (a, b) in tail_connectors if b > a]
+  room = CAP - len(T)
+  if room > 0 and tail_connectors:
+    T = insert_near_tail(T, tail_connectors[:room])
+
+  if len(T) >= CAP - 8:
+    intervals = []
+    min_l = min(l for l, r in T) if T else 0
+    if min_l < 0:
+      T = [(l - min_l, r - min_l) for (l, r) in T]
+    for (l, r) in T[:CAP]:
+      li = int(l)
+      ri = int(r)
+      if ri <= li:
+        ri = li + 1
+      intervals.append((li, ri))
+    return intervals
+
+  # Thin evenly-spaced seed
+  def thin_seed(seq, max_seed):
+    n = len(seq)
+    if n <= 0 or max_seed <= 0:
       return []
     step = max(1, n // max_seed)
-    return current_T[::step][:max_seed]
-
-  # Stage 2: delta2-driven micro rounds using thin evenly-spaced seeds
-  def _build_micro_delta_round(current_T, budget, iter_id=0, alt=False):
+    return seq[::step][:max_seed]
+
+  # Build a micro pass: translate a thin seed to multiple windows and interleave
+  def build_micro_pass(current_T, budget, windows, seed_cap, add_long_caps=False, add_pins=True):
     if not current_T or budget <= 8:
       return []
 
     glo = min(l for l, r in current_T)
     ghi = max(r for l, r in current_T)
-    G = max(1, ghi - glo)
-
-    # Thin seed (slightly larger for alt to strengthen mixing)
-    base_seed = max(8, min(32, len(current_T) // 300))
-    seed_sz = base_seed if not alt else max(8, min(40, len(current_T) // 250))
-    U = _thin_seed(current_T, seed_sz)
+    Gspan = max(1, ghi - glo)
+
+    # Thin seed
+    seed_sz = max(8, min(seed_cap, max(8, len(current_T) // 280)))
+    U = thin_seed(current_T, seed_sz)
     if not U:
       return []
 
     ulo = min(l for l, r in U)
 
-    # Windows with small shifts on primary; distinct family on alt
-    if not alt:
-      shift = (iter_id % 3) * 0.02
-      window_fracs = [
-        (0.12 + shift, 0.22 + shift),
-        (0.35 + shift, 0.45 + shift),
-        (0.58 + shift, 0.68 + shift),
-        (0.80 + shift, 0.90 + shift),
-      ]
-      window_fracs = [(max(0.05, min(0.90, a)), max(0.10, min(0.95, b))) for (a, b) in window_fracs]
-    else:
-      window_fracs = [(0.05, 0.15), (0.28, 0.38), (0.60, 0.70), (0.82, 0.92)]
-
+    # Translate into windows
     blocks = []
-    for (fa, fb) in window_fracs:
-      win_lo = glo + int(round(fa * G))
+    for (fa, fb) in windows:
+      win_lo = glo + int(round(fa * Gspan))
       base = win_lo - ulo
-      block = [(l + base, r + base) for (l, r) in U]
-      tag = iter_id if not alt else (iter_id + 1)
-      # Parity-breaking reversal to reduce symmetry
-      if ((int(round(fa * 100)) // 5) + tag) % 2 == 1:
-        block = list(reversed(block))
-      blocks.append(block)
-
-    # Interleave policy depends on tag parity
+      blk = [(l + base, r + base) for (l, r) in U]
+      # reverse internally for half of the windows to break symmetry
+      if int(round(fa * 100)) // 5 % 2 == 1:
+        blk = list(reversed(blk))
+      blocks.append(blk)
+
+    # Interleave blocks deterministically
     micro = []
-    tag = iter_id if not alt else (iter_id + 1)
+    maxlen = max(len(b) for b in blocks)
+    # alternate order pattern
     order = list(range(len(blocks)))
-    if tag % 2 == 1:
-      order.reverse()
-    maxlen = max(len(b) for b in blocks)
+    if len(blocks) >= 4:
+      order = [0, 2, 1, 3] + list(range(4, len(blocks)))
     for i in range(maxlen):
       for idx in order:
         blk = blocks[idx]
         if i < len(blk):
           micro.append(blk[i])
 
-    # Fractional-span connectors (KT analog) + long-range cross on alt
-    micro_connectors = [
-      (glo + int(round(0.08 * G)), glo + int(round(0.30 * G))),
-      (glo + int(round(0.60 * G)), glo + int(round(0.92 * G))),
-      (glo + int(round(0.26 * G)), glo + int(round(0.56 * G))),
-      (glo + int(round(0.44 * G)), glo + int(round(0.78 * G))),
+    # Fractional-span connectors (lightweight) across windows
+    connectors = [
+      (glo + int(round(0.08 * Gspan)), glo + int(round(0.30 * Gspan))),
+      (glo + int(round(0.62 * Gspan)), glo + int(round(0.94 * Gspan))),
+      (glo + int(round(0.26 * Gspan)), glo + int(round(0.56 * Gspan))),
+      (glo + int(round(0.44 * Gspan)), glo + int(round(0.78 * Gspan))),
     ]
-    if alt:
-      micro_connectors.append((glo + int(round(0.18 * G)), glo + int(round(0.84 * G))))
-    for a, b in micro_connectors:
+    if add_long_caps:
+      # One extra long connector gated to avoid too much span coverage
+      connectors.append((glo + int(round(0.20 * Gspan)), glo + int(round(0.84 * Gspan))))
+    for (a, b) in connectors:
       if b > a:
         micro.append((a, b))
+
+    # Short pins to lightly couple without omega blowup
+    if add_pins:
+      eps = max(1, Gspan // 512)
+      for pf in (0.16, 0.39, 0.61, 0.85):
+        L = glo + int(round(pf * Gspan))
+        R = L + eps
+        if R > L:
+          micro.append((L, R))
 
     if len(micro) > budget:
       micro = micro[:budget]
     return micro
 
-  # Execute two primary micro rounds, then one alt round (capacity-guarded)
-  for iter_id in range(2):
-    room = CAP - len(T)
-    if room <= 8:
-      break
-    micro = _build_micro_delta_round(T, room, iter_id=iter_id, alt=False)
-    if not micro:
-      break
-    if len(micro) > room:
-      micro = micro[:room]
-    T.extend(micro)
+  # Stage 2: two micro passes, CAP-aware, disjoint windows, deterministic
+  room = CAP - len(T)
+
+  if room > 8:
+    # Pass A windows (inner)
+    windows_A = [(0.10, 0.18), (0.32, 0.40), (0.54, 0.62), (0.76, 0.84)]
+    budget_A = max(0, room // 2)
+    micro_A = build_micro_pass(T, budget_A, windows_A, seed_cap=32, add_long_caps=True, add_pins=True)
+    if micro_A:
+      avail = CAP - len(T)
+      if len(micro_A) > avail:
+        micro_A = micro_A[:avail]
+      T.extend(micro_A)
 
   room = CAP - len(T)
   if room > 8:
-    micro_alt = _build_micro_delta_round(T, room, iter_id=2, alt=True)
-    if micro_alt:
+    # Pass B windows (offset, outer)
+    windows_B = [(0.18, 0.26), (0.40, 0.48), (0.62, 0.70), (0.84, 0.92)]
+    budget_B = max(0, room)
+    micro_B = build_micro_pass(T, budget_B, windows_B, seed_cap=40, add_long_caps=False, add_pins=True)
+    if micro_B:
       avail = CAP - len(T)
-      if len(micro_alt) > avail:
-        micro_alt = micro_alt[:avail]
-      T.extend(micro_alt)
-
-  # Stage 3: pin-shrinking micro-phase (controls omega via short intervals)
-  if len(T) < CAP - 8:
-    glo2 = min(l for l, r in T)
-    ghi2 = max(r for l, r in T)
-    G2 = max(1, ghi2 - glo2)
-    seed_sz2 = max(8, min(24, len(T) // 400))
-    U2 = _thin_seed(T, seed_sz2)
-    if U2:
-      ulo2 = min(l for l, r in U2)
-      eps = max(1, G2 // 512)
-      windows2 = [(0.05, 0.15), (0.28, 0.38), (0.60, 0.70), (0.82, 0.92)]
-      blocks2 = []
-      for (fa, fb) in windows2:
-        win_lo2 = glo2 + int(round(fa * G2))
-        base2 = win_lo2 - ulo2
-        block = []
-        for idx, (l, r) in enumerate(U2):
-          mid = (l + r) // 2
-          L = mid + base2 - (eps // 2) + (idx % 3)
-          R = L + eps
-          if R > L:
-            block.append((L, R))
-        blocks2.append(block)
-
-      micro2 = []
-      if blocks2:
-        maxlen2 = max(len(b) for b in blocks2)
-        order2 = [3, 1, 0, 2]
-        for i in range(maxlen2):
-          for idx in order2:
-            blk = blocks2[idx]
-            if i < len(blk):
-              micro2.append(blk[i])
-
-      # Two short cap-pins to tie windows without inflating omega
-      caps2 = [
-        (glo2 + int(round(0.09 * G2)), glo2 + int(round(0.09 * G2)) + eps),
-        (glo2 + int(round(0.64 * G2)), glo2 + int(round(0.64 * G2)) + eps),
-      ]
-      for a, b in caps2:
-        if b > a:
-          micro2.append((a, b))
-
-      room2 = CAP - len(T)
-      if room2 > 0:
-        if len(micro2) > room2:
-          micro2 = micro2[:room2]
-        T.extend(micro2)
-
-  # Stage 4 (new): tower-and-cap micro-phase
-  # Build staggered short towers across five separated windows, then add a few long caps
-  # that each overlap one level from every tower. At any point, only a local tower pin
-  # is active with the cap, mitigating omega growth.
-  if len(T) < CAP - 12:
-    glo3 = min(l for l, r in T)
-    ghi3 = max(r for l, r in T)
-    G3 = max(1, ghi3 - glo3)
-
-    # Thin seed for pin positioning (moderate size)
-    U3 = _thin_seed(T, max(12, min(36, len(T) // 300)))
-    if U3:
-      ulo3 = min(l for l, r in U3)
-      eps3 = max(1, G3 // 768)  # very short pins
-
-      # Five windows for five towers; each builds 3 staggered pin levels
-      towers = [(0.10, 0.18), (0.28, 0.36), (0.46, 0.54), (0.64, 0.72), (0.82, 0.90)]
-      levels = 3
-      tower_blocks = []
-      for t_idx, (fa, fb) in enumerate(towers):
-        win_lo3 = glo3 + int(round(fa * G3))
-        base3 = win_lo3 - ulo3
-        block = []
-        for idx, (l, r) in enumerate(U3):
-          mid = (l + r) // 2
-          # three levels staggered slightly to avoid co-location
-          for lv in range(levels):
-            jitter = (idx + lv + t_idx) % 4
-            L = mid + base3 - (eps3 // 2) + jitter + lv  # increasing shift by level
-            R = L + eps3
-            if R > L:
-              block.append((L, R))
-        tower_blocks.append(block)
-
-      # Interleave towers round-robin to distribute local density
-      tower_phase = []
-      if tower_blocks:
-        maxlen3 = max(len(b) for b in tower_blocks)
-        order3 = [0, 2, 4, 1, 3]
-        for i in range(maxlen3):
-          for idx in order3:
-            blk = tower_blocks[idx]
-            if i < len(blk):
-              tower_phase.append(blk[i])
-
-      # Add a few long caps that span across the tower windows but avoid edges
-      caps3 = [
-        (glo3 + int(round(0.15 * G3)), glo3 + int(round(0.45 * G3))),
-        (glo3 + int(round(0.38 * G3)), glo3 + int(round(0.70 * G3))),
-        (glo3 + int(round(0.60 * G3)), glo3 + int(round(0.88 * G3))),
-      ]
-      for a, b in caps3:
-        if b > a:
-          tower_phase.append((a, b))
-
-      room3 = CAP - len(T)
-      if room3 > 0 and tower_phase:
-        if len(tower_phase) > room3:
-          tower_phase = tower_phase[:room3]
-        T.extend(tower_phase)
+      if len(micro_B) > avail:
+        micro_B = micro_B[:avail]
+      T.extend(micro_B)
 
   # Final capacity guard
   if len(T) > CAP:
     T = T[:CAP]
 
-  # Normalize and ensure integer endpoints with r > l
+  # Normalize to non-negative integers and ensure r > l
   if not T:
     return []
   min_l = min(l for l, r in T)
   if min_l < 0:
     T = [(l - min_l, r - min_l) for (l, r) in T]
 
   intervals = []
-  for (l, r) in T:
+  for (l, r) in T[:CAP]:
     li = int(l)
     ri = int(r)
     if ri <= li:
       ri = li + 1
     intervals.append((li, ri))
 
-  if len(intervals) > CAP:
-    intervals = intervals[:CAP]
   return intervals
 
 # EVOLVE-BLOCK-END
 
 def run_experiment(**kwargs):
   """Main called by evaluator"""
   return construct_intervals()