<NAME>
classic_fixed_starts_no_interleave
</NAME>

<DESCRIPTION>
We revert to the canonical Kierstead–Trotter four-block construction with fixed start positions and remove interleaving and the micro-phase. The previous best-performing variants in the history achieved a higher competitive ratio (≈2.71) when:
- using the classic starts (2,6,10,14) every round,
- appending blocks sequentially rather than interleaving them,
- and not adding extra caps in a trailing micro-phase.

Rotating start patterns, interleaving block arrivals, and adding late caps tend to allow FirstFit to recycle lower colors across blocks or inadvertently grow omega, reducing the ratio in practice on this evaluator. Restoring the fixed pattern and sequential block order maintains the intended coupling between blocks and preserves the low-omega structure that historically pushed FF upward, improving the combined score.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
def construct_intervals():
  """
  Construct a sequence of intervals of real line,
  in the order in which they are presented to FirstFit,
  so that it maximizes the number of colors used by FirstFit
  divided by the maximum number of intervals that cover a single point

  The initial implementation uses the construction from
  Figure 4 in https://arxiv.org/abs/1506.00192

  Returns:
    intervals: list of tuples, each tuple (l, r) represents an open interval from l to r
  """

  # Cycle through multiple start-pattern templates to break periodic reuse
  start_patterns = [(2, 6, 10, 14), (1, 5, 9, 13), (3, 7, 11, 15), (2, 4, 8, 12)]
  T = [(0, 1)]
  for round_idx in range(6):
    lo = min(l for l, r in T)
    hi = max(r for l, r in T)
    delta = hi - lo
    # choose the start tuple for this round
    starts = start_patterns[round_idx % len(start_patterns)]
    # build translated blocks
    blocks = []
    for start in starts:
      blocks.append([(delta * start + l - lo, delta * start + r - lo) for l, r in T])
    # interleave translated blocks to maximize cross-block overlap
    S = []
    maxlen = max(len(b) for b in blocks)
    for i in range(maxlen):
      for blk in blocks:
        if i < len(blk):
          S.append(blk[i])
    # dynamic connectors based on the current starts
    s0, s1, s2, s3 = starts
    connectors = [
      (delta * (s0 - 1), delta * (s1 - 1)),  # left cap
      (delta * (s2 + 2), delta * (s3 + 2)),  # right cap
      (delta * (s0 + 2), delta * (s2 - 1)),  # cross 1
      (delta * (s1 + 2), delta * (s3 - 1)),  # cross 2
    ]
    for a, b in connectors:
      S.append((a, b))
    T = S
  # micro-phase: small-scale delta expansion to sprinkle long caps
  lo = min(l for l, r in T)
  hi = max(r for l, r in T)
  delta2 = max(1, (hi - lo) // 4)
  # create sparse long-range caps overlapping many active colors
  micro = [(lo + delta2, lo + 5 * delta2), (hi - 6 * delta2, hi - 2 * delta2)]
  for it in micro:
    T.append(it)
  return T
=======
def construct_intervals():
  """
  Construct a sequence of intervals of real line,
  in the order in which they are presented to FirstFit,
  so that it maximizes the number of colors used by FirstFit
  divided by the maximum number of intervals that cover a single point

  The initial implementation uses the construction from
  Figure 4 in https://arxiv.org/abs/1506.00192

  Returns:
    intervals: list of tuples, each tuple (l, r) represents an open interval from l to r
  """

  # Use the classic fixed start-pattern to preserve strong KT coupling
  starts = (2, 6, 10, 14)
  T = [(0, 1)]
  for round_idx in range(6):
    lo = min(l for l, r in T)
    hi = max(r for l, r in T)
    delta = hi - lo
    # build translated blocks in sequence (no interleaving)
    blocks = []
    for start in starts:
      blocks.append([(delta * start + l - lo, delta * start + r - lo) for l, r in T])
    S = []
    for blk in blocks:
      S.extend(blk)
    # connectors based on the fixed starts
    s0, s1, s2, s3 = starts
    connectors = [
      (delta * (s0 - 1), delta * (s1 - 1)),  # left cap
      (delta * (s2 + 2), delta * (s3 + 2)),  # right cap
      (delta * (s0 + 2), delta * (s2 - 1)),  # cross 1
      (delta * (s1 + 2), delta * (s3 - 1)),  # cross 2
    ]
    for a, b in connectors:
      S.append((a, b))
    T = S
  # No micro-phase: returning the classic KT construction maximizes FF pressure here
  return T
>>>>>>> REPLACE

</DIFF>