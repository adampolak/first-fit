--- a/original.py
+++ b/original.py
@@ -1,54 +1,161 @@
 # EVOLVE-BLOCK-START
 
-def construct_intervals(rounds=2):
-  """
-  Construct a sequence of intervals of real line,
-  in the order in which they are presented to FirstFit,
-  so that it tends to maximize the number of colors used by FirstFit
-  divided by the maximum number of intervals that cover a single point
-  through a recursive wave construction.
+def construct_intervals(rounds=2, seed_lo=0.0, seed_scale=1.0):
+    """
+    Deterministic rotating multiscale construction.
 
-  The construction generalizes the two-round pattern used in Figure 4 of
-  https://arxiv.org/abs/1506.00192 to a multi-round recursive expansion.
+    Inputs:
+      - rounds: number of main recursion rounds (keeps same signature as original).
+                Typical use: 2..6. Default=2.
+      - seed_lo, seed_scale: knobs for seed placement/scale (kept for compatibility).
 
-  Returns:
-    intervals: list of tuples, each tuple (l, r) represents an open interval from l to r
-  """
-  T = [(0, 1)]
-  for round_idx in range(rounds):
+    Output:
+      - list of open intervals (l, r) in the order presented to FirstFit.
+    """
+
+    # -- Key knobs (exposed for experimentation) --
+    phase2_rounds = 2           # small-scale refinement rounds after main rounds
+    bridge_fraction = 0.5       # fraction used to place light bridges between blocks
+    caps_per_round = 3          # small caps added each round (keeps omega low)
+    micro_scale = 0.12          # micro-gadget scale relative to delta
+    # ------------------------------------------------
+
+    # Seed: 4 disjoint unit intervals to provide richer early interactions
+    T = [
+        (seed_lo + 0.0 * seed_scale, seed_lo + 1.0 * seed_scale),
+        (seed_lo + 2.0 * seed_scale, seed_lo + 3.0 * seed_scale),
+        (seed_lo + 4.0 * seed_scale, seed_lo + 5.0 * seed_scale),
+        (seed_lo + 6.0 * seed_scale, seed_lo + 7.0 * seed_scale),
+    ]
+
+    # Rotating 4-cycle of start patterns (each has 4 starts -> branching factor 4)
+    start_patterns = [
+        (2, 6, 10, 14),
+        (1, 5, 9, 13),
+        (3, 7, 11, 15),
+        (2, 4, 8, 12),
+    ]
+
+    # Template bank: 4-interval gadget variants (keeps omega small)
+    template_bank = [
+        ((1.0, 5.0), (12.0, 16.0), (4.0, 9.0), (8.0, 13.0)),
+        ((0.5, 4.5), (11.0, 15.0), (3.5, 8.5), (7.0, 12.0)),
+        ((1.0, 4.0), (6.0, 9.0), (3.0, 7.0), (9.0, 13.0)),
+        ((2.0, 6.0), (7.0, 11.0), (0.0, 3.0), (10.0, 14.0)),
+    ]
+
+    # Main multiscale rounds (rotating starts and templates)
+    for it in range(max(1, int(rounds))):
+        lo = min(l for l, r in T)
+        hi = max(r for l, r in T)
+        delta = hi - lo if hi > lo else 1.0
+
+        # pick the start pattern (rotating)
+        starts = list(start_patterns[it % len(start_patterns)])
+
+        # vary the order of block insertion each round to disrupt predictable reuse
+        if it % 3 == 0:
+            block_order = starts
+        elif it % 3 == 1:
+            block_order = list(reversed(starts))
+        else:
+            # cyclic rotate
+            block_order = starts[1:] + starts[:1]
+
+        S = []
+        # append translated copies of T according to block_order
+        for bi, st in enumerate(block_order):
+            # alternate inner clone order across blocks/runs
+            clone_order = T if ((it + bi) % 2 == 0) else list(reversed(T))
+            base_off = delta * st - lo
+            for (l, r) in clone_order:
+                S.append((l + base_off, r + base_off))
+
+            # light deterministic bridge to the "next" start (couples colors across blocks)
+            if bi + 1 < len(block_order):
+                nxt = block_order[bi + 1]
+                # place a short bridge that connects the interior of current block
+                # to the interior of the next block (keeps omega small)
+                b_lo = delta * (st + bridge_fraction * 0.25)
+                b_hi = delta * (nxt - bridge_fraction * 0.25)
+                # ensure bridge has positive length
+                if b_hi > b_lo:
+                    S.append((b_lo, b_lo + max(0.2 * delta, 1.0)))
+
+        # append selected template gadget (one of the template_bank, rotates)
+        template = template_bank[it % len(template_bank)]
+        for (a, b) in template:
+            S.append((delta * a, delta * b))
+
+        # add a micro-gadget in the middle block to create fine-grained pressure
+        mid_start = block_order[len(block_order) // 2]
+        for (a, b) in template:
+            # micro scaled copy inserted inside the mid block (small-scale)
+            S.append((delta * (mid_start + micro_scale * a),
+                      delta * (mid_start + micro_scale * b)))
+
+        # add a few small caps to nudge FirstFit to create new colors (short intervals)
+        max_start = max(starts)
+        if max_start <= 0:
+            cap_positions = [1, 2, 3]
+        else:
+            # deterministic but spread positions
+            cap_positions = [int(max_start * (i + 1) / (caps_per_round + 1)) for i in range(caps_per_round)]
+        for j in cap_positions:
+            cap_lo = delta * (j + 0.1)
+            cap_hi = cap_lo + max(0.08 * delta, 0.5)
+            S.append((cap_lo, cap_hi))
+
+        # prepare for next round
+        T = S
+
+    # Second small-scale refinement phase to add interactions at a smaller delta
+    # (helps couple colors across scales)
+    # compute current span
     lo = min(l for l, r in T)
     hi = max(r for l, r in T)
-    delta = hi - lo
-    S = []
-    # In earlier rounds we apply a compact set of shifts; in later rounds,
-    # we widen the set of shifts to inject more waves and increase color usage.
-    # Use a denser set of shifts each round to amplify FirstFit pressure
-    starts = [2, 4, 6, 8, 10, 12, 14, 16]
-    for start in starts:
-      S += [(delta * start + l - lo, delta * start + r - lo) for l, r in T]
-    # additional local blocks to create overlapping waves without increasing omega too much
-    S += [
-      (delta * 1, delta * 5),
-      (delta * 12, delta * 16),
-      (delta * 4, delta * 9),
-      (delta * 8, delta * 13)
+    delta = hi - lo if hi > lo else 1.0
+    delta2 = max(1.0, delta / 3.0)  # smaller-scale expansion factor
+
+    # a small set of starts for the fine-scale phase
+    fine_starts_cycle = [
+        (1, 3, 5, 7),
+        (2, 5, 8, 11)
     ]
-    T = S
-  return T
 
-  # return [  # Figure 3, OPT=2, FF=4
-  #   (2,3),
-  #   (6,7),
-  #   (10,11),
-  #   (14,15),
-  #   (1,5),
-  #   (12,16),
-  #   (4,9),
-  #   (8,13),
-  # ]
+    for p in range(phase2_rounds):
+        starts = list(fine_starts_cycle[p % len(fine_starts_cycle)])
+        S = []
+        for bi, st in enumerate(starts):
+            clone_order = T if ((p + bi) % 2 == 0) else list(reversed(T))
+            base_off = delta2 * st - lo
+            for (l, r) in clone_order:
+                S.append((l * (delta2 / delta) + base_off, r * (delta2 / delta) + base_off))
+
+            # tiny bridge inside fine-scale
+            if bi + 1 < len(starts):
+                nxt = starts[bi + 1]
+                b_lo = delta2 * (st + 0.3)
+                b_hi = b_lo + max(0.04 * delta2, 0.2)
+                S.append((b_lo, b_hi))
+
+        # add a tiny template (choose from bank, scaled down)
+        template = template_bank[(it + p) % len(template_bank)]
+        for (a, b) in template:
+            S.append((delta2 * a, delta2 * b))
+
+        # micro caps
+        for k in range(2):
+            c_lo = delta2 * (starts[0] + 0.2 + k * 0.7)
+            c_hi = c_lo + max(0.03 * delta2, 0.15)
+            S.append((c_lo, c_hi))
+
+        T = S
+
+    return T
 
 # EVOLVE-BLOCK-END
 
 def run_experiment(**kwargs):
   """Main called by evaluator"""
   return construct_intervals()