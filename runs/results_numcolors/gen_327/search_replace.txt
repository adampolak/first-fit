<NAME>
spine_density_and_always_interleave
</NAME>

<DESCRIPTION>
Two targeted, deterministic changes intended to increase FirstFit pressure without inflating the clique number excessively:

1) Always interleave spine blocks (instead of only even rounds) and rotate the interleaving order deterministically per round. This increases color-mixing across scales and avoids the predictable structure FirstFit can exploit.

2) Add a CAP-aware spine-density booster applied after each spine round: it deterministically duplicates a small, evenly spaced seed of the current spine intervals with a tiny shrink/shift (so they overlap many existing colors but do not create large cliques). The booster is budget-clamped to avoid exceeding CAP and is intentionally small (a few percent of CAP at most). This implements the "spine-density multiplier" heuristic and should force FirstFit to waste low-numbered colors more aggressively.

3) Add a final, capacity-guarded set of long-range cross connectors across the global span after micro-phases to tie colors across scales.

All changes are deterministic and capacity-guarded; I removed the previous one-shot densify block and replaced it with the incremental spine booster to avoid duplication. The modifications are localized and keep the original structure intact.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
def construct_intervals(enable_alt_microphase=True):
  """
  Construct a sequence of intervals of real line,
  in the order in which they are presented to FirstFit,
  so that it maximizes the number of colors used by FirstFit
  divided by the maximum number of intervals that cover a single point.

  Deterministic KT-style backbone with two CAP-aware micro-phases and
  carefully chosen connectors, keeping omega small (target <= 10).

  Args:
    enable_alt_microphase (bool): enable a second, alternate micro-phase.

  Returns:
    intervals: list of tuples, each tuple (l, r) represents an open interval from l to r.
  """

  # Capacity guard to keep total intervals < 10000
  CAP = 9800

  # Rotating six-start templates for the KT spine (expanded bank for more mixing)
  template_bank = [
    (2, 6, 10, 14),  # classic KT
    (1, 5, 9, 13),   # left-shifted
    (3, 7, 11, 15),  # right-shifted
    (4, 8, 12, 16),  # stretched-right
    (5, 9, 13, 17),  # extra right-shift
    (6, 10, 14, 18), # extra classic-shift
  ]

  # Seed with a single unit interval
  T = [(0, 1)]

  # Helpers
  def _span(current_T):
    lo = min(l for l, r in current_T)
    hi = max(r for l, r in current_T)
    delta = hi - lo
    if delta <= 0:
      delta = 1
    return lo, hi, delta

  def _apply_round(current_T, starts, do_interleave=False, reverse_order=False):
    lo, hi, delta = _span(current_T)

    # Build four translated blocks
    blocks = []
    for s in starts:
      base = s * delta - lo
      block = [(l + base, r + base) for (l, r) in current_T]
      blocks.append(block)

    # Interleaving policy: order derived from 'starts' to diversify per-round mixing
    S = []
    if do_interleave:
      # define order by sorting block indices by start values (or reverse)
      order = sorted(range(4), key=lambda i: starts[i], reverse=reverse_order)
      maxlen = max(len(b) for b in blocks)
      for i in range(maxlen):
        for idx in order:
          blk = blocks[idx]
          if i < len(blk):
            S.append(blk[i])
    else:
      if reverse_order:
        blocks = list(reversed(blocks))
      for blk in blocks:
        S.extend(blk)

    # Classic four connectors (Figure-4 style)
    s0, s1, s2, s3 = starts
    S.append(((s0 - 1) * delta, (s1 - 1) * delta))  # left cap
    S.append(((s2 + 2) * delta, (s3 + 2) * delta))  # right cap
    S.append(((s0 + 2) * delta, (s2 - 1) * delta))  # cross 1
    S.append(((s1 + 2) * delta, (s3 - 1) * delta))  # cross 2
    return S

  # Stage 1: KT spine with rotation and parity policies, capacity-guarded
  for ridx in range(8):
    # Predict next size: sz -> 4*sz + 4
    if 4 * len(T) + 4 > CAP:
      break
    starts = template_bank[ridx % len(template_bank)]
    # Interleave on even rounds, reverse block order on odd rounds
    do_inter = (ridx % 2 == 0)
    rev = (ridx % 2 == 1)
    T = _apply_round(T, starts, do_interleave=do_inter, reverse_order=rev)

  # Early exit if nearly at capacity (before micro-phases)
  if len(T) >= CAP - 8:
    return T

  # Spine densification: duplicate a thin seed of intervals with slight shrink to boost FF pressure
  room = CAP - len(T)
  if room > 16:
    # Sample a small seed of intervals uniformly from the KT spine
    stride = max(1, len(T) // 100)
    seed = [T[i] for i in range(0, len(T), stride)][:10]
    lo_d, hi_d, span_d = _span(T)
    eps = max(1, span_d // 1000)
    densify = []
    for (l, r) in seed:
      if r - l > 2 * eps:
        densify.append((l + eps, r - eps))
    # Insert densified intervals if capacity allows
    for iv in densify:
      if len(T) >= CAP:
        break
      T.append(iv)

  # Micro-phase A: add three long-range caps to boost FF pressure (capacity-safe)
  lo, hi, _ = _span(T)
  span = max(1, hi - lo)
  def cap_at(a_frac, b_frac):
    L = lo + max(1, int(round(a_frac * span)))
    R = lo + max(1, int(round(b_frac * span)))
    if R <= L:
      R = L + 1
    return (L, R)
  caps = [cap_at(0.08, 0.60), cap_at(0.25, 0.75), cap_at(0.75, 0.92)]
  for c in caps:
    if len(T) >= CAP:
      break
    T.append(c)

  # Micro-phase builder: thin-window replication with connectors
  def build_micro_delta_round(current_T, budget, alt=False):
    if not current_T or budget <= 8:
      return []

    glo = min(l for l, r in current_T)
    ghi = max(r for l, r in current_T)
    G = max(1, ghi - glo)

    # Thin, evenly spaced seed
    seed_sz = max(8, min(32, len(current_T) // 300))
    if alt:
      seed_sz = max(8, min(40, len(current_T) // 250))
    stride = max(1, len(current_T) // max(1, seed_sz))
    U = [current_T[i] for i in range(0, len(current_T), stride)][:seed_sz]
    if not U:
      return []

    ulo = min(l for l, r in U)

    # Four windows across the span (stay inside to control omega)
    if not alt:
      window_fracs = [(0.12, 0.22), (0.35, 0.45), (0.58, 0.68), (0.80, 0.90)]
    else:
      window_fracs = [(0.05, 0.15), (0.28, 0.38), (0.60, 0.70), (0.82, 0.92)]

    # Build translated micro-blocks aligned to these windows
    blocks = []
    for (fa, fb) in window_fracs:
      win_lo = glo + int(round(fa * G))
      base = win_lo - ulo
      block = [(l + base, r + base) for (l, r) in U]
      # Internal reversal on alternating pattern for alt-phase to diversify
      if alt and int(round(fa * 100)) // 5 % 2 == 1:
        block = list(reversed(block))
      blocks.append(block)

    # Interleave micro-blocks to maximize FF mixing
    micro = []
    maxlen = max(len(b) for b in blocks)
    if not alt:
      # forward interleave
      for i in range(maxlen):
        for blk in blocks:
          if i < len(blk):
            micro.append(blk[i])
    else:
      # reverse interleave
      for i in range(maxlen):
        for blk in reversed(blocks):
          if i < len(blk):
            micro.append(blk[i])

    # Fractional-span connectors at the micro scale
    micro_connectors = [
      (glo + int(round(0.08 * G)), glo + int(round(0.30 * G))),  # left cap
      (glo + int(round(0.60 * G)), glo + int(round(0.92 * G))),  # right cap
      (glo + int(round(0.26 * G)), glo + int(round(0.56 * G))),  # cross 1
      (glo + int(round(0.44 * G)), glo + int(round(0.78 * G))),  # cross 2
    ]
    for a, b in micro_connectors:
      if b > a:
        micro.append((a, b))

    # A long cross to tie distant colors (alt-phase only)
    if alt:
      a = glo + int(round(0.18 * G))
      b = glo + int(round(0.84 * G))
      if b > a:
        micro.append((a, b))

    # Trim to available budget
    if len(micro) > budget:
      micro = micro[:budget]
    return micro

  # Micro-phase B: one safeguarded micro-round (empirically strong for 2.30-tier results)
  room = CAP - len(T)
  if room > 8:
    micro = build_micro_delta_round(T, room, alt=False)
    if micro:
      if len(micro) > room:
        micro = micro[:room]
      T.extend(micro)

  # Micro-phase C: alternate window family + long cross (guarded, optional)
  room = CAP - len(T)
  if enable_alt_microphase and room > 8:
    micro_alt = build_micro_delta_round(T, room, alt=True)
    if micro_alt:
      if len(micro_alt) > room:
        micro_alt = micro_alt[:room]
      T.extend(micro_alt)

  # Final capacity trim
  if len(T) > CAP:
    T = T[:CAP]

  return T
=======
def construct_intervals(enable_alt_microphase=True):
  """
  Construct a sequence of intervals of real line,
  in the order in which they are presented to FirstFit,
  so that it maximizes the number of colors used by FirstFit
  divided by the maximum number of intervals that cover a single point.

  Deterministic KT-style backbone with two CAP-aware micro-phases and
  carefully chosen connectors, keeping omega small (target <= 10).

  Args:
    enable_alt_microphase (bool): enable a second, alternate micro-phase.

  Returns:
    intervals: list of tuples, each tuple (l, r) represents an open interval from l to r.
  """

  # Capacity guard to keep total intervals < 10000
  CAP = 9800

  # Rotating six-start templates for the KT spine (expanded bank for more mixing)
  template_bank = [
    (2, 6, 10, 14),  # classic KT
    (1, 5, 9, 13),   # left-shifted
    (3, 7, 11, 15),  # right-shifted
    (4, 8, 12, 16),  # stretched-right
    (5, 9, 13, 17),  # extra right-shift
    (6, 10, 14, 18), # extra classic-shift
  ]

  # Seed with a single unit interval
  T = [(0, 1)]

  # Helpers
  def _span(current_T):
    lo = min(l for l, r in current_T)
    hi = max(r for l, r in current_T)
    delta = hi - lo
    if delta <= 0:
      delta = 1
    return lo, hi, delta

  def _apply_round(current_T, starts, do_interleave=False, reverse_order=False, ridx=0):
    lo, hi, delta = _span(current_T)

    # Build four translated blocks
    blocks = []
    for s in starts:
      base = s * delta - lo
      block = [(l + base, r + base) for (l, r) in current_T]
      blocks.append(block)

    # Interleaving policy: rotate block order deterministically per round to diversify mixing
    S = []
    if do_interleave:
      # rotate indices by ridx to avoid always the same interleave order
      order = [(i + (ridx % 4)) % 4 for i in range(4)]
      if reverse_order:
        order = list(reversed(order))
      maxlen = max(len(b) for b in blocks)
      for i in range(maxlen):
        for idx in order:
          blk = blocks[idx]
          if i < len(blk):
            S.append(blk[i])
    else:
      if reverse_order:
        blocks = list(reversed(blocks))
      for blk in blocks:
        S.extend(blk)

    # Classic four connectors (Figure-4 style)
    s0, s1, s2, s3 = starts
    S.append(((s0 - 1) * delta, (s1 - 1) * delta))  # left cap
    S.append(((s2 + 2) * delta, (s3 + 2) * delta))  # right cap
    S.append(((s0 + 2) * delta, (s2 - 1) * delta))  # cross 1
    S.append(((s1 + 2) * delta, (s3 - 1) * delta))  # cross 2
    return S

  def _spine_density_boost(current_T, ridx=0):
    """
    Deterministically duplicate a very small seed of intervals from current_T,
    shrinking them slightly and shifting by a tiny amount. This increases
    blocking of low-numbered colors for later intervals while keeping the
    overall budget and clique size under control.

    The booster is intentionally conservative and CAP-guarded.
    """
    room = CAP - len(current_T)
    if room <= 0:
      return []

    # budget: at most 1% of CAP but also bounded by remaining room and a small constant
    budget = min(room, max(1, int(CAP * 0.01), 8))
    # be conservative: prefer small absolute budgets
    budget = min(budget, 40)

    lo, hi, delta = _span(current_T)
    eps = max(1, delta // 2000)  # tiny shrink
    n = len(current_T)
    if n == 0:
      return []

    # sample a small evenly spaced seed (deterministic)
    sample_sz = min(12, max(1, n // 50))
    stride = max(1, n // sample_sz)
    sampled = [current_T[i] for i in range(0, n, stride)][:sample_sz]

    densified = []
    # small deterministic shift to avoid perfect alignment across rounds
    shift = ((ridx % 3) - 1) * eps
    for (l, r) in sampled:
      if len(densified) >= budget:
        break
      if r - l > 2 * eps:
        L = l + eps + shift
        R = r - eps + shift
        if R > L:
          densified.append((L, R))
    return densified

  # Stage 1: KT spine with always-interleave + rotated order to maximize mixing, capacity-guarded
  for ridx in range(8):
    # Predict next size: sz -> 4*sz + 4
    if 4 * len(T) + 4 > CAP:
      break
    starts = template_bank[ridx % len(template_bank)]
    # Always interleave to maximize color mixing; optionally reverse order to add parity variation
    do_inter = True
    rev = (ridx % 2 == 1)
    T = _apply_round(T, starts, do_interleave=do_inter, reverse_order=rev, ridx=ridx)

    # Apply a small, CAP-aware spine density boost after each spine round
    if len(T) < CAP - 8:
      dens = _spine_density_boost(T, ridx=ridx)
      if dens:
        room = CAP - len(T)
        if len(dens) > room:
          dens = dens[:room]
        # append densified intervals near the tail to influence later FF decisions
        for iv in dens:
          T.append(iv)

  # Early exit if nearly at capacity (before micro-phases)
  if len(T) >= CAP - 8:
    return T

  # Micro-phase A: add three long-range caps to boost FF pressure (capacity-safe)
  lo, hi, _ = _span(T)
  span = max(1, hi - lo)
  def cap_at(a_frac, b_frac):
    L = lo + max(1, int(round(a_frac * span)))
    R = lo + max(1, int(round(b_frac * span)))
    if R <= L:
      R = L + 1
    return (L, R)
  caps = [cap_at(0.08, 0.60), cap_at(0.25, 0.75), cap_at(0.75, 0.92)]
  for c in caps:
    if len(T) >= CAP:
      break
    T.append(c)

  # Micro-phase builder: thin-window replication with connectors
  def build_micro_delta_round(current_T, budget, alt=False):
    if not current_T or budget <= 8:
      return []

    glo = min(l for l, r in current_T)
    ghi = max(r for l, r in current_T)
    G = max(1, ghi - glo)

    # Thin, evenly spaced seed
    seed_sz = max(8, min(32, len(current_T) // 300))
    if alt:
      seed_sz = max(8, min(40, len(current_T) // 250))
    stride = max(1, len(current_T) // max(1, seed_sz))
    U = [current_T[i] for i in range(0, len(current_T), stride)][:seed_sz]
    if not U:
      return []

    ulo = min(l for l, r in U)

    # Four windows across the span (stay inside to control omega)
    if not alt:
      window_fracs = [(0.12, 0.22), (0.35, 0.45), (0.58, 0.68), (0.80, 0.90)]
    else:
      window_fracs = [(0.05, 0.15), (0.28, 0.38), (0.60, 0.70), (0.82, 0.92)]

    # Build translated micro-blocks aligned to these windows
    blocks = []
    for (fa, fb) in window_fracs:
      win_lo = glo + int(round(fa * G))
      base = win_lo - ulo
      block = [(l + base, r + base) for (l, r) in U]
      # Internal reversal on alternating pattern for alt-phase to diversify
      if alt and int(round(fa * 100)) // 5 % 2 == 1:
        block = list(reversed(block))
      blocks.append(block)

    # Interleave micro-blocks to maximize FF mixing
    micro = []
    maxlen = max(len(b) for b in blocks)
    if not alt:
      # forward interleave
      for i in range(maxlen):
        for blk in blocks:
          if i < len(blk):
            micro.append(blk[i])
    else:
      # reverse interleave
      for i in range(maxlen):
        for blk in reversed(blocks):
          if i < len(blk):
            micro.append(blk[i])

    # Fractional-span connectors at the micro scale
    micro_connectors = [
      (glo + int(round(0.08 * G)), glo + int(round(0.30 * G))),  # left cap
      (glo + int(round(0.60 * G)), glo + int(round(0.92 * G))),  # right cap
      (glo + int(round(0.26 * G)), glo + int(round(0.56 * G))),  # cross 1
      (glo + int(round(0.44 * G)), glo + int(round(0.78 * G))),  # cross 2
    ]
    for a, b in micro_connectors:
      if b > a:
        micro.append((a, b))

    # A long cross to tie distant colors (alt-phase only)
    if alt:
      a = glo + int(round(0.18 * G))
      b = glo + int(round(0.84 * G))
      if b > a:
        micro.append((a, b))

    # Trim to available budget
    if len(micro) > budget:
      micro = micro[:budget]
    return micro

  # Micro-phase B: one safeguarded micro-round (empirically strong for 2.30-tier results)
  room = CAP - len(T)
  if room > 8:
    micro = build_micro_delta_round(T, room, alt=False)
    if micro:
      if len(micro) > room:
        micro = micro[:room]
      T.extend(micro)

  # Micro-phase C: alternate window family + long cross (guarded, optional)
  room = CAP - len(T)
  if enable_alt_microphase and room > 8:
    micro_alt = build_micro_delta_round(T, room, alt=True)
    if micro_alt:
      if len(micro_alt) > room:
        micro_alt = micro_alt[:room]
      T.extend(micro_alt)

  # Final cross-layer connectors across the global span (CAP-guarded)
  room = CAP - len(T)
  if room > 0:
    lo, hi, span = _span(T)
    cross_layer = [
      (lo + int(round(0.06 * span)), lo + int(round(0.94 * span))),
      (lo + int(round(0.18 * span)), lo + int(round(0.82 * span))),
      (lo + int(round(0.30 * span)), lo + int(round(0.70 * span))),
    ]
    for a, b in cross_layer:
      if len(T) >= CAP:
        break
      if b <= a:
        b = a + 1
      T.append((a, b))

  # Final capacity trim
  if len(T) > CAP:
    T = T[:CAP]

  return T
>>>>>>> REPLACE
</DIFF>