--- a/original.py
+++ b/original.py
@@ -1,180 +1,203 @@
 # EVOLVE-BLOCK-START
 
-def construct_intervals(seed_count=1):
+def construct_intervals(seed_count=1, rounds=6):
   """
   Construct a sequence of intervals on the real line, in the order presented to FirstFit,
   to maximize FF colors divided by the clique number.
+
+  Inputs:
+    seed_count (int): kept for interface compatibility; default=1.
+    rounds (int): number of backbone rounds; default=6.
+
   Returns:
     intervals: list of (l, r) tuples (open intervals).
   """
 
-  # Capacity guard tuned to return after six spine rounds (skipping micro-phase) and < 10000
+  # Capacity guard to keep total intervals < 10000
   CAP = 9800
 
-  # Stage 1: Deterministic KT-style spine (no interleaving), 6 rounds, classic connectors.
-  spine_starts = (2, 6, 10, 14)
-
-  # Seed: keep a single unit interval; multi-seed tends to inflate omega too early.
-  T = [(0, 1)] if seed_count <= 1 else [(0, 1)]
-
-  def apply_spine_round(current_T, starts):
+  # Four core KT starts; rotate them round-robin to diversify coupling
+  template_bank = [
+    (2, 6, 10, 14),  # T1: classic KT
+    (1, 5, 9, 13),   # T2: left-shifted
+    (3, 7, 11, 15),  # T3: right-shifted
+    (4, 8, 12, 16),  # T4: alternate
+  ]
+  core_starts = (2, 6, 10, 14)  # micro-gadgets use the canonical four-start scheme
+
+  # Optional translation growth multipliers; alternating helps long-range coupling
+  K_cycle = [1, 1, 2, 1]  # conservative: mostly 1, occasionally 2 for long-span hooks
+
+  # Seed with one unit interval (multi-seed tends to inflate omega too early)
+  T = [(0, 1)]
+
+  def thin_seed(current_T, max_seed):
+    """Evenly sample up to max_seed intervals for micro gadgets."""
+    n = len(current_T)
+    if n == 0 or max_seed <= 0:
+      return []
+    step = max(1, n // max_seed)
+    return current_T[::step][:max_seed]
+
+  def interleave_blocks(blocks):
+    """Interleave four blocks element-wise to increase FF pressure."""
+    S = []
+    maxlen = max(len(b) for b in blocks)
+    for i in range(maxlen):
+      for blk in blocks:
+        if i < len(blk):
+          S.append(blk[i])
+    return S
+
+  def apply_spine_round(current_T, starts, ridx, K=1, do_interleave=False):
+    """
+    Build one KT-style spine round with optional parity-based interleaving
+    and extended connectors. Returns the round output list.
+    """
     # Compute span and delta
     lo = min(l for l, r in current_T)
     hi = max(r for l, r in current_T)
     delta = hi - lo
     if delta <= 0:
       delta = 1
-
-    # Four translated blocks sequentially (no interleaving)
-    S = []
-    for s in starts:
-      base = s * delta - lo
-      S.extend((l + base, r + base) for (l, r) in current_T)
-
-    # Classic connectors (Figure 4 style)
+    deltaK = delta * max(1, int(K))
+
+    # Build four translated blocks; alternate internal order to impede color reuse
+    blocks = []
+    for b_idx, s in enumerate(starts):
+      base = s * deltaK - lo
+      src = current_T if ((ridx + b_idx) % 2 == 0) else list(reversed(current_T))
+      block = [(l + base, r + base) for (l, r) in src]
+      blocks.append(block)
+
+    # Assemble S via parity rule
+    S = interleave_blocks(blocks) if do_interleave else [x for blk in blocks for x in blk]
+
+    # Extended connectors at this scale (classic + cross3 + cross4)
     s0, s1, s2, s3 = starts
     connectors = [
-      ((s0 - 1) * delta, (s1 - 1) * delta),  # left cap
-      ((s2 + 2) * delta, (s3 + 2) * delta),  # right cap
-      ((s0 + 2) * delta, (s2 - 1) * delta),  # cross 1
-      ((s1 + 2) * delta, (s3 - 1) * delta),  # cross 2
+      ((s0 - 1) * deltaK, (s1 - 1) * deltaK),  # left cap
+      ((s2 + 2) * deltaK, (s3 + 2) * deltaK),  # right cap
+      ((s0 + 2) * deltaK, (s2 - 1) * deltaK),  # cross 1
+      ((s1 + 2) * deltaK, (s3 - 1) * deltaK),  # cross 2
+      ((s0 + 3) * deltaK, (s3 + 3) * deltaK),  # cross3 (longer)
+      ((s1 + 4) * deltaK, (s2 + 4) * deltaK),  # cross4 (extended)
     ]
-    S.extend(connectors)
-    return S
-
-  # Perform exactly six spine rounds, rotating start templates to diversify structure.
-  template_bank = [
-    (2, 6, 10, 14),  # classic KT
-    (1, 5, 9, 13),   # left-shifted
-    (3, 7, 11, 15),  # right-shifted
-    (4, 8, 12, 16),  # alternate
-  ]
-  bank_size = len(template_bank)
-  for ridx in range(6):
-    # Rotate starts per round to break symmetry
-    starts = template_bank[ridx % bank_size]
-    # Predict next size: sz -> 4*sz + 4
-    nxt_size = 4 * len(T) + 4
-    if nxt_size > CAP:
-      break
-    T = apply_spine_round(T, starts)
-
-  # If we are already near the cap, return the strong baseline.
-  if len(T) >= CAP:
-    return T
-
-  # Stage 2: Two delta2-driven micro extension rounds (thin sampling; four-start translations).
-  # Goals:
-  #  - Raise FF pressure via cross-scale coupling and interleaving parity,
-  #  - Keep omega in check by using thin seeds and sparse caps/connectors,
-  #  - Respect strict capacity guard.
-
-  def thin_seed(current_T, max_seed):
-    """Take a thin, evenly spaced sample of current_T of size <= max_seed."""
-    n = len(current_T)
-    if n == 0 or max_seed <= 0:
-      return []
-    step = max(1, n // max_seed)
-    U = current_T[::step][:max_seed]
-    return U
-
-  def micro_round(current_T, round_id, budget):
+    # Spread connectors through S by inserting after each block boundary where possible
+    # to enhance arrival-order effects without altering asymptotics.
+    # If we cannot place neatly, append at the end.
+    placed = 0
+    out = []
+    quarter = len(S) // 4 if len(S) >= 4 else 0
+    cut_points = [quarter, 2 * quarter, 3 * quarter]
+    cp_idx = 0
+    for idx, itv in enumerate(S):
+      out.append(itv)
+      if cp_idx < len(cut_points) and idx + 1 == cut_points[cp_idx]:
+        # insert up to two connectors at each cut
+        take = min(2, len(connectors) - placed)
+        out.extend(connectors[placed:placed + take])
+        placed += take
+        cp_idx += 1
+    # append any remaining connectors
+    if placed < len(connectors):
+      out.extend(connectors[placed:])
+
+    return out
+
+  def micro_gadget(current_T, round_id, budget):
+    """
+    Localized four-start micro gadget at half-scale with parity interleaving
+    opposite to the spine parity for this round. Includes cross3/cross4 and sparse caps.
+    """
     if budget <= 0 or not current_T:
       return []
 
     glo = min(l for l, r in current_T)
     ghi = max(r for l, r in current_T)
     G = max(1, ghi - glo)
-
-    # Use delta2 at half-scale to avoid expanding the global span too aggressively.
     delta2 = max(1, G // 2)
 
-    # Thin seed: bounded and deterministic size to respect budget
-    # Keep micro blocks small: target at most ~ (budget//6) per block (four blocks + ~8 extras).
-    per_block_target = max(16, min(64, budget // 8))
+    # Thin seed capped to budget; keep small to guard omega
+    per_block_target = max(8, min(64, budget // 10))
     U = thin_seed(current_T, per_block_target)
-
     if not U:
       return []
 
-    # Build four translated blocks using the same 4-start template,
-    # with deterministic parity-based interleaving policy:
-    # - Rounds with round_id % 2 == 0: forward interleave
-    # - Rounds with round_id % 2 == 1: reverse interleave
-    starts = spine_starts
+    ulo = min(l for l, r in U)
     blocks = []
-    ulo = min(l for l, r in U)
-    for s in starts:
-      base = s * delta2 - ulo
+    for s in core_starts:
+      base = s * delta2 - ulo + glo
       block = [(l + base, r + base) for (l, r) in U]
-      # Add a tiny deterministic internal reversal to break symmetry every other block
-      if ((s // 2) % 2) == (round_id % 2):
+      # Internal reversal keyed to parity to break symmetry
+      if ((s // 2) ^ round_id) & 1:
         block = list(reversed(block))
       blocks.append(block)
 
-    micro = []
-    if round_id % 2 == 0:
-      # Forward interleave
-      maxlen = max(len(b) for b in blocks)
-      for i in range(maxlen):
-        for blk in blocks:
-          if i < len(blk):
-            micro.append(blk[i])
-    else:
-      # Reverse interleave (swap block order)
-      maxlen = max(len(b) for b in blocks)
-      for i in range(maxlen):
-        for blk in reversed(blocks):
-          if i < len(blk):
-            micro.append(blk[i])
-
-    # Deterministic connectors at delta2 scale, including a cross3 extension
-    s0, s1, s2, s3 = starts
+    # Interleave for even round_id; sequential for odd (opposite to spine typical)
+    M = interleave_blocks(blocks) if (round_id % 2 == 0) else [x for b in blocks for x in b]
+
+    s0, s1, s2, s3 = core_starts
     connectors = [
-      ((s0 - 1) * delta2 + glo, (s1 - 1) * delta2 + glo),  # left cap (localized)
-      ((s2 + 2) * delta2 + glo, (s3 + 2) * delta2 + glo),  # right cap
-      ((s0 + 2) * delta2 + glo, (s2 - 1) * delta2 + glo),  # cross 1
-      ((s1 + 2) * delta2 + glo, (s3 - 1) * delta2 + glo),  # cross 2
-      ((s0 + 3) * delta2 + glo, (s3 + 3) * delta2 + glo),  # cross3 (longer range)
-      ((s1 + 4) * delta2 + glo, (s2 + 4) * delta2 + glo),  # cross4 (extended coupling)
+      ((s0 - 1) * delta2 + glo, (s1 - 1) * delta2 + glo),
+      ((s2 + 2) * delta2 + glo, (s3 + 2) * delta2 + glo),
+      ((s0 + 2) * delta2 + glo, (s2 - 1) * delta2 + glo),
+      ((s1 + 2) * delta2 + glo, (s3 - 1) * delta2 + glo),
+      ((s0 + 3) * delta2 + glo, (s3 + 3) * delta2 + glo),
+      ((s1 + 4) * delta2 + glo, (s2 + 4) * delta2 + glo),
     ]
-    micro.extend(connectors)
-
-    # Sparse micro caps: add three long but safe caps at half-scale
-    cap1 = (glo + (delta2 // 4), glo + int(1.8 * delta2))
-    cap2 = (glo + int(0.9 * delta2), glo + int(2.6 * delta2))
+    M.extend(connectors)
+
+    # Sparse caps: two long and one mid cap
+    cap1 = (glo + (delta2 // 4), glo + int(1.75 * delta2))
+    cap2 = (glo + int(0.9 * delta2), glo + int(2.5 * delta2))
     mid = glo + G // 2
     cap3 = (mid - max(1, delta2 // 8), mid + max(1, delta2 // 8))
     for cap in (cap1, cap2, cap3):
       if cap[1] > cap[0]:
-        micro.append(cap)
-
-    # Enforce budget
-    if len(micro) > budget:
-      micro = micro[:budget]
-    return micro
-
-  # Execute two micro rounds with strong guards
-  remaining = CAP - len(T)
-  mr1 = micro_round(T, round_id=0, budget=max(0, remaining // 2))
-  if mr1:
-    room = CAP - len(T)
-    if len(mr1) > room:
-      mr1 = mr1[:room]
-    T.extend(mr1)
-
-  remaining = CAP - len(T)
-  mr2 = micro_round(T, round_id=1, budget=max(0, remaining))
-  if mr2:
-    room = CAP - len(T)
-    if len(mr2) > room:
-      mr2 = mr2[:room]
-    T.extend(mr2)
+        M.append(cap)
+
+    if len(M) > budget:
+      M = M[:budget]
+    return M
+
+  # Backbone with in-round micro towers
+  for ridx in range(max(1, int(rounds))):
+    # Predict next size; include a conservative overhead for micro gadgets
+    # Growth per spine round: n -> 4n + O(1). Reserve micro budget per round.
+    n = len(T)
+    # micro overhead target per round (small, omega-safe)
+    micro_target = 120 if n < 4000 else 64
+    predicted = 4 * n + 10 + micro_target
+    if predicted > CAP:
+      break
+
+    starts = template_bank[ridx % len(template_bank)]
+    K = K_cycle[ridx % len(K_cycle)]
+    do_interleave = (ridx % 2 == 0)  # parity-based interleaving on even rounds
+    S = apply_spine_round(T, starts, ridx=ridx, K=K, do_interleave=do_interleave)
+
+    # In-round micro gadget: conservative, capacity-aware
+    room = CAP - (len(S))
+    mg_budget = max(0, min(micro_target, room))
+    if mg_budget > 0:
+      M = micro_gadget(S, round_id=ridx, budget=mg_budget)
+      # Insert micro gadget after roughly half of S to maximize mixing
+      if M:
+        half = len(S) // 2
+        S = S[:half] + M + S[half:]
+
+    T = S
+
+    # Capacity guard
+    if len(T) >= CAP:
+      T = T[:CAP]
+      break
 
   return T
 
 # EVOLVE-BLOCK-END
 
 def run_experiment(**kwargs):
   """Main called by evaluator"""
   return construct_intervals()