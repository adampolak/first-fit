<NAME>
kt_backbone_with_micro_rounds
</NAME>

<DESCRIPTION>
I revert the main KT spine to a strict sequential block order (no interleaving) to stabilize the clique number and adhere to the proven backbone pattern. Then I replace the ad-hoc two-cap micro-phase with two delta-scaled micro-rounds that thin-sample the spine, add four translated micro-blocks with parity-controlled internal reversals, and attach sparse cross-scale connectors (including a longer cross3). This mirrors successful recursive strategies inspired by KT-style constructions and thin “micro” injections observed to increase FirstFit while keeping omega bounded. I also add a hard CAP guard to stay below 10k intervals and gate the micro-phase by remaining capacity. This change aims to restore and exceed the prior strong 2.20 combined score baseline while respecting the omega ≤ 10 constraint.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
def construct_intervals():
  """
  Construct a sequence of intervals of real line,
  in the order in which they are presented to FirstFit,
  so that it maximizes the number of colors used by FirstFit
  divided by the maximum number of intervals that cover a single point

  The initial implementation uses the construction from
  Figure 4 in https://arxiv.org/abs/1506.00192

  Returns:
    intervals: list of tuples, each tuple (l, r) represents an open interval from l to r
  """

  # Use the classic fixed start-pattern to preserve strong KT coupling
=======
def construct_intervals():
  """
  Construct a sequence of intervals of real line,
  in the order in which they are presented to FirstFit,
  so that it maximizes the number of colors used by FirstFit
  divided by the maximum number of intervals that cover a single point

  The initial implementation uses the construction from
  Figure 4 in https://arxiv.org/abs/1506.00192

  Returns:
    intervals: list of tuples, each tuple (l, r) represents an open interval from l to r
  """

  # Capacity guard to keep total intervals < 10000
  CAP = 9800

  # Use the classic fixed start-pattern to preserve strong KT coupling
>>>>>>> REPLACE
<<<<<<< SEARCH
    S = []
    # interleave blocks on even rounds, sequential on odd rounds
    if round_idx % 2 == 0:
      maxlen = max(len(b) for b in blocks)
      for i in range(maxlen):
        for blk in blocks:
          if i < len(blk):
            S.append(blk[i])
    else:
      for blk in blocks:
        S.extend(blk)
    # connectors based on the fixed starts
=======
    S = []
    # keep sequential order every round to stabilize omega and reproduce KT backbone
    for blk in blocks:
      S.extend(blk)
    # connectors based on the fixed starts
>>>>>>> REPLACE
<<<<<<< SEARCH
  # Micro-phase: add two long sparse caps to boost late FirstFit color usage
  lo = min(l for l, r in T)
  hi = max(r for l, r in T)
  delta = hi - lo if hi > lo else 1
  # cap across almost entire span but avoid increasing omega
  cap1 = (lo + 0.1 * delta, lo + 0.9 * delta)
  cap2 = (lo + 0.2 * delta, lo + 0.8 * delta)
  T.append(cap1)
  T.append(cap2)
  return T
=======
  # Stage 2: Two delta2-driven micro extension rounds (thin sampling; four-start translations).
  # Skip if near capacity.
  if len(T) < CAP - 16:
    def thin_seed(current_T, max_seed):
      n = len(current_T)
      if n == 0 or max_seed <= 0:
        return []
      step = max(1, n // max_seed)
      return current_T[::step][:max_seed]

    def micro_round(current_T, round_id, budget):
      if budget <= 0 or not current_T:
        return []
      glo = min(l for l, r in current_T)
      ghi = max(r for l, r in current_T)
      G = max(1, ghi - glo)
      # Use half-scale to avoid expanding the global span too aggressively
      delta2 = max(1, G // 2)

      # Thin seed: bounded and deterministic size to respect budget
      per_block_target = max(8, min(64, budget // 12))
      U = thin_seed(current_T, per_block_target)
      if not U:
        return []

      # Build four translated blocks using the same 4-start template,
      # with deterministic parity-based internal reversal
      blocks = []
      ulo = min(l for l, r in U)
      for s in starts:
        base = s * delta2 - ulo
        block = [(l + base, r + base) for (l, r) in U]
        if ((s // 2) % 2) == (round_id % 2):
          block = list(reversed(block))
        blocks.append(block)

      micro = []
      # Parity-based interleaving across blocks
      maxlen = max(len(b) for b in blocks)
      if round_id % 2 == 0:
        for i in range(maxlen):
          for blk in blocks:
            if i < len(blk):
              micro.append(blk[i])
      else:
        for i in range(maxlen):
          for blk in reversed(blocks):
            if i < len(blk):
              micro.append(blk[i])

      # Deterministic connectors at delta2 scale, including a longer cross3
      s0, s1, s2, s3 = starts
      connectors = [
        ((s0 - 1) * delta2 + glo, (s1 - 1) * delta2 + glo),  # left cap
        ((s2 + 2) * delta2 + glo, (s3 + 2) * delta2 + glo),  # right cap
        ((s0 + 2) * delta2 + glo, (s2 - 1) * delta2 + glo),  # cross 1
        ((s1 + 2) * delta2 + glo, (s3 - 1) * delta2 + glo),  # cross 2
        ((s0 + 3) * delta2 + glo, (s3 + 3) * delta2 + glo),  # cross3 (long range)
      ]
      micro.extend(connectors)

      # Sparse micro caps to press FirstFit locally without raising omega much
      cap1 = (glo + (delta2 // 4), glo + int(1.8 * delta2))
      cap2 = (glo + int(0.9 * delta2), glo + int(2.6 * delta2))
      mid = glo + G // 2
      cap3 = (mid - max(1, delta2 // 8), mid + max(1, delta2 // 8))
      for cap in (cap1, cap2, cap3):
        if cap[1] > cap[0]:
          micro.append(cap)

      # Enforce budget
      if len(micro) > budget:
        micro = micro[:budget]
      return micro

    remaining = CAP - len(T)
    mr1 = micro_round(T, round_id=0, budget=max(0, remaining // 2))
    if mr1:
      room = CAP - len(T)
      if len(mr1) > room:
        mr1 = mr1[:room]
      T.extend(mr1)

    remaining = CAP - len(T)
    mr2 = micro_round(T, round_id=1, budget=max(0, remaining))
    if mr2:
      room = CAP - len(T)
      if len(mr2) > room:
        mr2 = mr2[:room]
      T.extend(mr2)

  return T
>>>>>>> REPLACE

</DIFF>