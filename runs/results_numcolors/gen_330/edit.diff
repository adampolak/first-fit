--- a/original.py
+++ b/original.py
@@ -1,347 +1,277 @@
 # EVOLVE-BLOCK-START
 
 def construct_intervals(rounds=6,
                         rotate_starts=True,
                         reverse_block_parity=True,
                         interleave_blocks=True,
                         phase2_iters=2,
                         seed_count=1):
   """
-  Crossover construction combining KT-style spine + diversified multi-seed micro phases.
-
-  Parameters:
-    rounds (int): desired KT expansion depth (predictive cap may reduce actual rounds).
-    rotate_starts (bool): rotate among strong start templates when True.
-    reverse_block_parity (bool): flip block order parity to diversify arrival order.
-    interleave_blocks (bool): allow interleaving of translated blocks on selected rounds.
-    phase2_iters (int): up to two delta-scale micro rounds (CAP-guarded).
-    seed_count (int): optional small multi-seed (keeps early omega low but richer coupling).
-
-  Returns:
-    intervals: list of (l, r) integer tuples in FF presentation order.
+  Hex-spine with deterministic rotation, enforced interleaving, dual CAP-aware micro phases,
+  and bounded long-range connectors. Returns intervals (l, r) in FirstFit presentation order.
   """
 
-  # Hard capacity guard to keep total count < 10000
+  # Hard capacity guard to keep total intervals < 10000
   CAP = 9800
 
-  # Template bank for KT-like rounds (rotated)
-  template_bank = [
-    (2, 6, 10, 14),  # classic KT
-    (1, 5, 9, 13),   # left-shift
-    (3, 7, 11, 15),  # right-shift
-    (4, 8, 12, 16),  # stretched-right
+  # Six-template start bank (hex spine)
+  # The two extra templates beyond the classic four diversify color coupling across rounds.
+  template_bank6 = [
+    (2, 6, 10, 14),  # T1: classic KT
+    (1, 5, 9, 13),   # T2: left-shifted
+    (3, 7, 11, 15),  # T3: right-shifted
+    (4, 8, 12, 16),  # T4: stretched-right
+    (2, 4, 8, 12),   # T5: compressed-left pair
+    (5, 9, 13, 17),  # T6: stretched-far right
   ]
 
-  # Secondary small connector bank (diversified templates used by the light-bridge rounds)
-  connector_bank = [
-    ((1, 5), (12, 16), (4, 9), (8, 13)),
-    ((0, 4), (11, 15), (3, 8), (7, 12)),
-    ((1, 4), (6, 9), (3, 7), (9, 13)),
-    ((2, 6), (7, 11), (0, 3), (10, 14)),
-  ]
-
-  # Seed initialization: either single unit interval (classic KT) or a few sparse seeds
+  # Deterministic seed for template rotation (no randomness; reproducible)
+  BASE_SEED = 131071
+
+  # Seed initialization: one unit interval; multi-seed allowed but constrained
   if seed_count <= 1:
     T = [(0, 1)]
   else:
-    # deterministic sparse multi-seed, limit to avoid early clique blow-up
     seeds = min(4, max(1, int(seed_count)))
     step = 3
     T = [(i * step, i * step + 1) for i in range(seeds)]
 
-  # Utility: compute span and guard minimal delta
+  # Helpers
   def _span_delta(current_T):
     lo = min(l for l, r in current_T)
     hi = max(r for l, r in current_T)
     delta = hi - lo
     if delta <= 0:
       delta = 1
     return lo, hi, int(delta)
 
-  # Classic KT connectors (scale-preserving integer endpoints)
-  def _append_kt_connectors(S, starts, delta, lo):
+  # Classic KT connectors (four caps/crosses), scale-preserving
+  def _append_connectors(S, starts, delta):
     s0, s1, s2, s3 = starts
-    # scale by delta and shift by lo to keep integer coordinates consistent
-    S.append(((s0 - 1) * delta + lo, (s1 - 1) * delta + lo))  # left cap
-    S.append(((s2 + 2) * delta + lo, (s3 + 2) * delta + lo))  # right cap
-    S.append(((s0 + 2) * delta + lo, (s2 - 1) * delta + lo))  # cross 1
-    S.append(((s1 + 2) * delta + lo, (s3 - 1) * delta + lo))  # cross 2
-
-  # Apply one KT-style round: translate blocks, optionally interleave/reverse, append connectors
-  def _apply_kt_round(current_T, starts, do_interleave=False, reverse_order=False):
+    S.append(((s0 - 1) * delta, (s1 - 1) * delta))  # left cap
+    S.append(((s2 + 2) * delta, (s3 + 2) * delta))  # right cap
+    S.append(((s0 + 2) * delta, (s2 - 1) * delta))  # cross 1
+    S.append(((s1 + 2) * delta, (s3 - 1) * delta))  # cross 2)
+
+  # Build a spine round: always interleave blocks (mandated), optional reverse of block order
+  def _apply_spine_round(current_T, starts, ridx, enforce_interleave=True, allow_reverse=True):
     lo, hi, delta = _span_delta(current_T)
 
-    # Build four translated blocks (integer arithmetic)
+    # Build four translated copies
     blocks = []
     for s in starts:
-      base_off = s * delta - lo
-      block = [(l + base_off, r + base_off) for (l, r) in current_T]
-      blocks.append(block)
-
+      base = s * delta - lo
+      blk = [(l + base, r + base) for (l, r) in current_T]
+      blocks.append(blk)
+
+    # Assemble S with strong interleaving to maximize color mixing
     S = []
-    if do_interleave:
-      order = list(range(4))
-      if reverse_order:
-        order.reverse()
+    order = list(range(4))
+    if allow_reverse and (ridx % 2 == 1):
+      order.reverse()
+    if enforce_interleave:
       maxlen = max(len(b) for b in blocks)
       for i in range(maxlen):
         for idx in order:
           blk = blocks[idx]
           if i < len(blk):
             S.append(blk[i])
     else:
-      if reverse_order:
-        blocks = list(reversed(blocks))
-      for blk in blocks:
-        S.extend(blk)
-
-    _append_kt_connectors(S, starts, delta, lo)
+      for idx in order:
+        S.extend(blocks[idx])
+
+    # Classic connectors
+    _append_connectors(S, starts, delta)
     return S
 
-  # Predictive bound: KT growth per round is size -> 4*size + 4
+  # Tiny per-round density booster: add a handful of short pins near edges, CAP-guarded
+  def _edge_pins(current_T, max_add=6):
+    if max_add <= 0 or not current_T:
+      return []
+    lo, hi, G = _span_delta(current_T)
+    if G <= 4:
+      return []
+    # Place pins in low-density edge windows to avoid inflating omega
+    # Fractions chosen away from core spine windows
+    fracs = [0.03, 0.07, 0.93, 0.97]
+    eps = max(1, G // 512)
+    pins = []
+    for f in fracs:
+      a = lo + int(round(f * G))
+      pins.append((a, a + eps))
+    return pins[:max_add]
+
+  # Predictive spine growth: sz -> 4*sz + 4 per round
   def _max_rounds_within_cap(initial_size, max_rounds):
     sz = initial_size
     done = 0
-    for _ in range(max(0, int(max_rounds))):
-      nxt = 4 * sz + 4
+    for k in range(max(0, int(max_rounds))):
+      nxt = 4 * sz + 4  # KT recurrence
       if nxt > CAP:
         break
       sz = nxt
       done += 1
     return done, sz
 
-  # Stage 1: KT spine with rotating templates and parity-based interleaving
+  # Stage 1: Hex spine with deterministic rotation and mandated interleaving
   depth, _ = _max_rounds_within_cap(len(T), rounds)
   for ridx in range(depth):
-    starts = template_bank[ridx % len(template_bank)] if rotate_starts else template_bank[0]
-    do_inter = bool(interleave_blocks and (ridx % 2 == 0))
-    rev = bool(reverse_block_parity and (ridx % 2 == 1))
-    T = _apply_kt_round(T, starts, do_interleave=do_inter, reverse_order=rev)
+    # Deterministic template selection (six-template rotation)
+    if rotate_starts:
+      h = (BASE_SEED * (ridx + 1) + 977 * ridx) % 6
+      starts = template_bank6[h]
+    else:
+      starts = template_bank6[0]
+    # Enforce interleaving irrespective of the incoming flag to maximize pressure
+    T = _apply_spine_round(T, starts, ridx,
+                           enforce_interleave=True,
+                           allow_reverse=True if reverse_block_parity else False)
+    # Lightweight edge pins to slightly densify without raising omega (strictly bounded)
+    if len(T) < CAP - 16:
+      pins = _edge_pins(T, max_add=4 if ridx % 2 == 0 else 2)
+      room = CAP - len(T)
+      if room > 0 and pins:
+        T.extend(pins[:room])
+
     if len(T) >= CAP:
       return T[:CAP]
 
-  # If nearly at capacity return baseline
+  # Early return if nearly full
   if len(T) >= CAP - 16:
     return T[:CAP]
 
-  # Insert a few long-range caps near the tail (helps mixing late FF colors without raising omega much)
-  def _cap_at(lo, delta, a_frac, b_frac):
-    L = lo + max(1, int(round(a_frac * delta)))
-    R = lo + max(1, int(round(b_frac * delta)))
-    if R <= L:
-      R = L + 1
-    return (L, R)
-
-  lo, hi, delta = _span_delta(T)
-  tail_caps = [
-    _cap_at(lo, delta, 0.08, 0.60),
-    _cap_at(lo, delta, 0.25, 0.75),
-    _cap_at(lo, delta, 0.75, 0.92)
-  ]
-  # Insert compactly near the tail (but capacity-guarded)
-  room = CAP - len(T)
-  if room > 0:
-    for cap in tail_caps[:room]:
-      T.append(cap)
-
-  if len(T) >= CAP - 12:
+  # Stage 1.5: Long-range deterministic connectors (guarded)
+  def _global_connectors(current_T, limit=6):
+    lo, hi, G = _span_delta(current_T)
+    con_fracs = [(0.05, 0.37), (0.18, 0.62), (0.26, 0.78), (0.44, 0.86), (0.60, 0.92), (0.08, 0.30)]
+    out = []
+    for (fa, fb) in con_fracs[:limit]:
+      a = lo + int(round(fa * G))
+      b = lo + int(round(fb * G))
+      if b > a:
+        out.append((a, b))
+    return out
+
+  # Reserve a fraction of remaining CAP for connectors and micro phases
+  remain = CAP - len(T)
+  if remain > 0:
+    # Connector budget clamped small to avoid omega inflation
+    conn_budget = min(10, max(4, remain // 1000))
+    conns = _global_connectors(T, limit=conn_budget)
+    add = conns[:remain]
+    T.extend(add)
+  if len(T) >= CAP - 8:
     return T[:CAP]
 
-  # Stage 2: delta-scale micro rounds - derive a thin seed and place translated micro-blocks in windows
+  # Stage 2: Dual micro phases with explicit CAP budgeting
+  # Allocate a fraction of the remaining capacity to micro passes
+  remain = CAP - len(T)
+  if remain <= 8:
+    return T[:CAP]
+
+  micro_total = remain
+  # Reserve budgets: A gets 55%, B gets 45% (rounded)
+  budget_A = int(0.55 * micro_total)
+  budget_B = micro_total - budget_A
+
+  # Thin seed
   def _thin_seed(current_T, max_seed):
     n = len(current_T)
     if n == 0 or max_seed <= 0:
       return []
     step = max(1, n // max_seed)
-    U = current_T[::step][:max_seed]
-    return U
-
-  def _build_delta_micro(current_T, budget, iter_id=0, alt=False):
-    if not current_T or budget <= 8:
-      return []
-
+    return [current_T[i] for i in range(0, n, step)][:max_seed]
+
+  def _build_micro(current_T, budget, window_fracs, connectors=True, reverse=False):
+    if not current_T or budget <= 0:
+      return []
     glo = min(l for l, r in current_T)
     ghi = max(r for l, r in current_T)
     G = max(1, ghi - glo)
 
-    # seed size chosen small to keep omega low
-    base_seed = max(8, min(36, len(current_T) // 250))
-    seed_sz = base_seed if not alt else max(8, min(40, len(current_T) // 220))
+    # Seed size: small to protect omega, yet provide mixing
+    seed_sz = max(12, min(40, len(current_T) // 250))
     U = _thin_seed(current_T, seed_sz)
     if not U:
       return []
-
     ulo = min(l for l, r in U)
 
-    # windows: primary ones slightly shifted by iter_id; alternate windows distinct
-    if not alt:
-      shift = (iter_id % 3) * 0.02
-      window_fracs = [
-        (0.12 + shift, 0.22 + shift),
-        (0.35 + shift, 0.45 + shift),
-        (0.58 + shift, 0.68 + shift),
-        (0.80 + shift, 0.90 + shift),
-      ]
-      # clamp
-      window_fracs = [(max(0.05, min(0.90, a)), max(0.10, min(0.95, b))) for (a, b) in window_fracs]
-    else:
-      window_fracs = [(0.05, 0.15), (0.28, 0.38), (0.60, 0.70), (0.82, 0.92)]
-
+    # Build translated micro-blocks aligned to windows
     blocks = []
     for (fa, fb) in window_fracs:
       win_lo = glo + int(round(fa * G))
-      base_off = win_lo - ulo
-      block = [(l + base_off, r + base_off) for (l, r) in U]
-      # parity-breaking reversal to diversify arrivals
-      tag = iter_id + (1 if alt else 0)
-      if ((int(round(fa * 100)) // 5) + tag) % 2 == 1:
-        block = list(reversed(block))
-      blocks.append(block)
-
-    # Interleave micro-blocks with block order varying by iter_id
+      base = win_lo - ulo
+      blk = [(l + base, r + base) for (l, r) in U]
+      blocks.append(blk)
+    if reverse:
+      blocks = list(reversed(blocks))
+
+    # Interleave micro blocks fully
     micro = []
-    block_order = list(range(len(blocks)))
-    if (iter_id % 2) == 1:
-      block_order.reverse()
     maxlen = max(len(b) for b in blocks)
     for i in range(maxlen):
-      for idx in block_order:
-        blk = blocks[idx]
+      for blk in blocks:
         if i < len(blk):
           micro.append(blk[i])
 
-    # Deterministic fractional connectors on micro-scale (keep them short relative to G)
-    micro_connectors = [
-      (glo + int(round(0.08 * G)), glo + int(round(0.30 * G))),
-      (glo + int(round(0.60 * G)), glo + int(round(0.92 * G))),
-      (glo + int(round(0.26 * G)), glo + int(round(0.56 * G))),
-      (glo + int(round(0.44 * G)), glo + int(round(0.78 * G))),
-    ]
-    if alt:
-      micro_connectors.append((glo + int(round(0.18 * G)), glo + int(round(0.84 * G))))
-
-    for a, b in micro_connectors:
-      if b > a:
-        micro.append((a, b))
-
-    # trim to budget
+    # Add fractional connectors across the micro windows (short)
+    if connectors:
+      micro_connectors = [
+        (glo + int(round(0.08 * G)), glo + int(round(0.30 * G))),
+        (glo + int(round(0.26 * G)), glo + int(round(0.56 * G))),
+        (glo + int(round(0.44 * G)), glo + int(round(0.78 * G))),
+        (glo + int(round(0.60 * G)), glo + int(round(0.92 * G))),
+      ]
+      for a, b in micro_connectors:
+        if b > a:
+          micro.append((a, b))
+
+    # Trim to budget
     if len(micro) > budget:
       micro = micro[:budget]
     return micro
 
-  steps = min(max(0, int(phase2_iters)), 2)
-  for iter_id in range(steps):
+  # Micro-pass A: left/inner windows (denser toward the core)
+  windows_A = [(0.12, 0.22), (0.36, 0.46), (0.58, 0.68), (0.80, 0.90)]
+  microA = _build_micro(T, budget_A, windows_A, connectors=True, reverse=False)
+  if microA:
     room = CAP - len(T)
-    if room <= 8:
-      break
-    micro = _build_delta_micro(T, room, iter_id=iter_id, alt=False)
-    if not micro:
-      break
-    if len(micro) > room:
-      micro = micro[:room]
-    T.extend(micro)
-
-  # Secondary alternate micro-phase to capture missed interactions
-  room = CAP - len(T)
-  if room > 8:
-    microB = _build_delta_micro(T, room, iter_id=steps, alt=True)
-    if microB:
-      if len(microB) > room:
-        microB = microB[:room]
-      T.extend(microB)
-
-  if len(T) >= CAP - 8:
-    return T[:CAP]
-
-  # Stage 3: light-bridge round inspired by diversified design:
-  # use a small connector template, alternating block orders and short caps to press FF colors
-  lo, hi, delta = _span_delta(T)
-  if delta <= 0:
-    return T[:CAP]
-
-  # pick a connector template deterministically
-  template = connector_bank[0]
-  # adopt a small set of starts derived from the KT templates for diversity
-  start_patterns = [
-    (2, 6, 10, 14),
-    (1, 5, 9, 13),
-    (3, 7, 11, 15),
-    (2, 4, 8, 12),
-  ]
-  starts = start_patterns[0]
-
-  S = []
-  # Choose block order variant depending on parity of current size to diversify ordering
-  if len(T) % 3 == 0:
-    block_order = list(starts)
-  elif len(T) % 3 == 1:
-    block_order = list(reversed(starts))
-  else:
-    block_order = list(starts[1:]) + [starts[0]]
-
-  # build translated blocks (use small reversed sub-blocks occasionally)
-  for i, st in enumerate(block_order):
-    inner = T if ((len(T) + i) % 2 == 0) else list(reversed(T))
-    base_off = delta * st - lo
-    for (l, r) in inner:
-      S.append((l + base_off, r + base_off))
-    # add a tiny light-bridge interval tying this block to next (short to avoid omega growth)
-    if i + 1 < len(block_order):
-      nxt = block_order[i + 1]
-      bstart = delta * (st + 0.5) - lo
-      bend = delta * (nxt + 0.5) - lo
-      # make bridge extremely short and integerized
-      a = int(min(bstart, bend) + max(1, delta // 1000))
-      b = int(max(bstart, bend) - max(1, delta // 1000))
-      if b > a:
-        S.append((a, b))
-
-  # append small connector gadget (scaled)
-  for (a, b) in template:
-    A = int(round(a * delta))
-    B = int(round(b * delta))
-    if B > A:
-      S.append((lo + A, lo + B))
-
-  # add a few sparse short caps between translated blocks
-  max_st = max(starts)
-  step = max(2, int(max_st // 3))
-  for j in range(2, max_st, step):
-    a = int(lo + delta * (j - 0.4) + 1)
-    b = int(lo + delta * (j + 0.6) - 1)
-    if b > a:
-      S.append((a, b))
-
-  # Capacity guard and append
-  room = CAP - len(T)
-  if room > 0:
-    if len(S) > room:
-      S = S[:room]
-    T.extend(S)
-
-  # Final micro pins (optional, very short intervals to tie windows)
-  if len(T) < CAP - 4:
-    glo2 = min(l for l, r in T)
-    ghi2 = max(r for l, r in T)
-    G2 = max(1, ghi2 - glo2)
-    eps = max(1, G2 // 512)
+    if len(microA) > room:
+      microA = microA[:room]
+    T.extend(microA)
+
+  # Micro-pass B: right/outer windows (shifted to avoid cliques and overlap cores)
+  remain = CAP - len(T)
+  if remain > 0:
+    budget_B = min(budget_B, remain)
+  windows_B = [(0.10, 0.20), (0.30, 0.40), (0.62, 0.72), (0.84, 0.94)]
+  microB = _build_micro(T, budget_B, windows_B, connectors=True, reverse=True)
+  if microB:
+    room = CAP - len(T)
+    if len(microB) > room:
+      microB = microB[:room]
+    T.extend(microB)
+
+  # Final tiny pin fill if space remains (keep very small to avoid omega growth)
+  remain = CAP - len(T)
+  if remain > 0:
+    lo, hi, G = _span_delta(T)
+    eps = max(1, G // 1024)
     pins = []
-    # create a few pins at fractional positions
-    for frac in (0.09, 0.27, 0.64, 0.83):
-      mid = glo2 + int(round(frac * G2))
-      pins.append((mid, mid + eps))
-    room = CAP - len(T)
-    if room > 0:
-      pins = pins[:room]
-      T.extend(pins)
-
-  # Final trim
+    # Deterministic positions away from core windows
+    for f in (0.06, 0.24, 0.76, 0.94):
+      a = lo + int(round(f * G))
+      pins.append((a, a + eps))
+    if pins:
+      T.extend(pins[:remain])
+
+  # Final capacity trim
   if len(T) > CAP:
     T = T[:CAP]
   return T
 
 # EVOLVE-BLOCK-END
 
 def run_experiment(**kwargs):
   """Main called by evaluator"""
   return construct_intervals()