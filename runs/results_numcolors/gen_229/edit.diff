--- a/original.py
+++ b/original.py
@@ -1,291 +1,266 @@
 # EVOLVE-BLOCK-START
 
 def construct_intervals(seed_count=1):
   """
-  Construct a sequence of intervals of real line,
-  in the order in which they are presented to FirstFit,
-  so that it maximizes the number of colors used by FirstFit
-  divided by the maximum number of intervals that cover a single point
-
-  The initial implementation uses the construction from
-  Figure 4 in https://arxiv.org/abs/1506.00192
-
-  Returns:
-    intervals: list of tuples, each tuple (l, r) represents an open interval from l to r
+  Construct a sequence of intervals on the real line, in the order presented to FirstFit,
+  to maximize FirstFit colors divided by the clique number (omega).
+
+  Structural pipeline:
+    1) KT-style rotating-template backbone (six rounds, parity interleaving)
+    2) Sparse long caps layer (tail insert)
+    3) Micro-phase A (primary fractional windows)
+    4) Micro-phase B (alternate fractional windows)
+    5) Cross4 connector layer (long-range couplers, gated)
+
+  Inputs:
+    seed_count (int): kept for API compatibility; multi-seeding is guarded.
+
+  Output:
+    list of (l, r) integer tuples (open intervals), in presentation order.
   """
 
-  # Capacity guard to keep total intervals < 10000
-  CAP = 9800
-
-  # Use the classic fixed start-pattern to preserve strong KT coupling
-  spine_starts = (2, 6, 10, 14)
-
-  # Seed with multiple disjoint unit intervals if requested (new capability)
-  if seed_count <= 1:
-    T = [(0, 1)]
-  else:
-    step = 3
-    T = [(i * step, i * step + 1) for i in range(seed_count)]
-
-  # Stage 1: six KT rounds, alternating interleaving to raise FF pressure
-  for ridx in range(6):
-    # Predict next size: size -> 4*size + 4; abort if it would exceed CAP
-    nxt_size = 4 * len(T) + 4
-    if nxt_size > CAP:
-      break
-    lo = min(l for l, r in T)
-    hi = max(r for l, r in T)
-    delta = hi - lo
-    if delta <= 0:
-      delta = 1
-    # Build four translated blocks
+  # ------------------------------
+  # Global guards and parameters
+  # ------------------------------
+  CAP = 9800  # hard capacity guard
+  BASE_SEED = 911382323
+
+  # Templates for the KT spine
+  TEMPLATE_BANK = [
+    (2, 6, 10, 14),  # classic KT
+    (1, 5, 9, 13),   # left-shifted
+    (3, 7, 11, 15),  # right-shifted
+    (4, 8, 12, 16),  # stretched-right
+  ]
+
+  # Window families for micro-phases
+  WINDOWS_PRIMARY = [(0.12, 0.22), (0.35, 0.45), (0.58, 0.68), (0.80, 0.90)]
+  WINDOWS_ALT     = [(0.05, 0.15), (0.28, 0.38), (0.60, 0.70), (0.82, 0.92)]
+
+  # ------------------------------
+  # Utility helpers
+  # ------------------------------
+  def _span(T):
+    lo = min(l for l, _ in T)
+    hi = max(r for _, r in T)
+    G = hi - lo
+    if G <= 0:
+      G = 1
+    return lo, hi, G
+
+  def _predict_next_size(sz):
+    # KT recurrence: n -> 4*n + 4 (four copies + four classic connectors)
+    return 4 * sz + 4
+
+  def _dhash(*xs):
+    # Small deterministic hash, stable across runs
+    h = BASE_SEED
+    for v in xs:
+      h = ((h ^ (v + 0x9e3779b97f4a7c15)) * 0xbf58476d1ce4e5b9) & 0xFFFFFFFFFFFFFFFF
+      h ^= (h >> 27)
+    return h
+
+  def _thin_seed(T, max_seed):
+    n = len(T)
+    if n == 0 or max_seed <= 0:
+      return []
+    step = max(1, n // max_seed)
+    return T[::step][:max_seed]
+
+  # ------------------------------
+  # Spine builder (KT-style rounds)
+  # ------------------------------
+  def _apply_spine_round(T, starts, interleave=False, reverse_order=False):
+    lo, hi, G = _span(T)
     blocks = []
-    for start in spine_starts:
-      base = start * delta - lo
+    for s in starts:
+      base = s * G - lo
       blocks.append([(l + base, r + base) for (l, r) in T])
-    # Interleave on even rounds, sequential on odd rounds
+
     S = []
-    if ridx % 2 == 0:
+    if interleave:
+      order = list(range(4))
+      if reverse_order:
+        order.reverse()
       maxlen = max(len(b) for b in blocks)
       for i in range(maxlen):
-        for blk in blocks:
+        for idx in order:
+          blk = blocks[idx]
           if i < len(blk):
             S.append(blk[i])
     else:
+      if reverse_order:
+        blocks = list(reversed(blocks))
       for blk in blocks:
         S.extend(blk)
-    # Classic connectors (Figure 4 style)
-    s0, s1, s2, s3 = spine_starts
-    connectors = [
-      ((s0 - 1) * delta, (s1 - 1) * delta),  # left cap
-      ((s2 + 2) * delta, (s3 + 2) * delta),  # right cap
-      ((s0 + 2) * delta, (s2 - 1) * delta),  # cross 1
-      ((s1 + 2) * delta, (s3 - 1) * delta),  # cross 2
-    ]
-    S.extend(connectors)
-    T = S
-
-  # If we are already near the cap, return the strong baseline.
-  if len(T) >= CAP - 16:
+
+    s0, s1, s2, s3 = starts
+    S.append(((s0 - 1) * G, (s1 - 1) * G))  # left cap
+    S.append(((s2 + 2) * G, (s3 + 2) * G))  # right cap
+    S.append(((s0 + 2) * G, (s2 - 1) * G))  # cross 1
+    S.append(((s1 + 2) * G, (s3 - 1) * G))  # cross 2
+    return S
+
+  def build_spine(rounds=6, rotate=True):
+    # Seed: single unit interval to keep early omega low
+    T = [(0, 1)] if seed_count <= 1 else [(0, 1)]
+    for ridx in range(max(0, int(rounds))):
+      nxt = _predict_next_size(len(T))
+      if nxt > CAP:
+        break
+      starts = TEMPLATE_BANK[ridx % len(TEMPLATE_BANK)] if rotate else TEMPLATE_BANK[0]
+      inter = (ridx % 2 == 0)
+      rev = (ridx % 2 == 1)
+      T = _apply_spine_round(T, starts, interleave=inter, reverse_order=rev)
+      if len(T) >= CAP:
+        return T[:CAP]
     return T
 
-  # Stage 2: Two delta2-driven micro extension rounds (thin sampling; four-start translations).
-  # Goals:
-  #  - Raise FF pressure via cross-scale coupling and interleaving parity,
-  #  - Keep omega in check by using thin seeds and sparse caps/connectors,
-  #  - Respect strict capacity guard.
-
-  def thin_seed(current_T, max_seed):
-    """Take a thin, evenly spaced sample of current_T of size <= max_seed."""
-    n = len(current_T)
-    if n == 0 or max_seed <= 0:
+  # ------------------------------
+  # Caps layer (sparse long caps)
+  # ------------------------------
+  def inject_caps(T):
+    if len(T) >= CAP - 8:
+      return T
+    lo, hi, G = _span(T)
+    def cap_at(a, b):
+      L = lo + max(1, int(round(a * G)))
+      R = lo + max(1, int(round(b * G)))
+      if R <= L:
+        R = L + 1
+      return (L, R)
+    caps = [cap_at(0.08, 0.60), cap_at(0.25, 0.75), cap_at(0.75, 0.92)]
+    for c in caps:
+      if len(T) >= CAP:
+        break
+      T.append(c)
+    return T
+
+  # ------------------------------
+  # Micro-phase builders
+  # ------------------------------
+  def _build_micro_windows(T, budget, windows, iter_id=0, jitter=False):
+    if not T or budget <= 8:
       return []
-    step = max(1, n // max_seed)
-    U = current_T[::step][:max_seed]
-    return U
-
-  def micro_round(current_T, round_id, budget):
-    if budget <= 0 or not current_T:
-      return []
-
-    glo = min(l for l, r in current_T)
-    ghi = max(r for l, r in current_T)
-    G = max(1, ghi - glo)
-
-    # Use delta2 at half-scale to avoid expanding the global span too aggressively.
-    delta2 = max(1, G // 2)
-
-    # Thin seed: bounded and deterministic size to respect budget
-    # Keep micro blocks small: target at most ~ (budget//6) per block (four blocks + ~8 extras).
-    per_block_target = max(8, min(64, budget // 12))
-    U = thin_seed(current_T, per_block_target)
-
+    glo, ghi, G = _span(T)
+    # Thin, evenly spaced seed; bounded size for safety
+    seed_sz = max(8, min(40, len(T) // 250))
+    stride = max(1, len(T) // max(1, seed_sz))
+    U = [T[i] for i in range(0, len(T), stride)][:seed_sz]
     if not U:
       return []
-
-    # Build four translated blocks using the same 4-start template,
-    # with deterministic parity-based interleaving policy:
-    # - Rounds with round_id % 2 == 0: forward interleave
-    # - Rounds with round_id % 2 == 1: reverse interleave
+    ulo = min(l for l, _ in U)
+
+    # Optional tiny deterministic jitter across windows
+    j = 0.0
+    if jitter:
+      h = _dhash(iter_id, len(T))
+      j = ((h % 3) - 1) * 0.005  # in {-0.005, 0, 0.005}
+
     blocks = []
-    ulo = min(l for l, r in U)
-    for s in spine_starts:
-      base = s * delta2 - ulo
+    for (fa, fb) in windows:
+      a = max(0.05, min(0.90, fa + j))
+      b = max(a + 0.02, min(0.95, fb + j))
+      win_lo = glo + int(round(a * G))
+      base = win_lo - ulo
       block = [(l + base, r + base) for (l, r) in U]
-      # Add a tiny deterministic internal reversal to break symmetry every other block
-      if ((s // 2) % 2) == (round_id % 2):
+      tag = ((int(round(a * 100)) // 5) + iter_id) % 2
+      if tag == 1:
         block = list(reversed(block))
       blocks.append(block)
 
-    micro = []
-    if round_id % 2 == 0:
-      # Forward interleave
-      maxlen = max(len(b) for b in blocks)
-      for i in range(maxlen):
-        for blk in blocks:
-          if i < len(blk):
-            micro.append(blk[i])
-    else:
-      # Reverse interleave (swap block order)
-      maxlen = max(len(b) for b in blocks)
-      for i in range(maxlen):
-        for blk in reversed(blocks):
-          if i < len(blk):
-            micro.append(blk[i])
-
-    # Deterministic connectors at delta2 scale, including a cross3 extension
-    s0, s1, s2, s3 = spine_starts
-    connectors = [
-      ((s0 - 1) * delta2 + glo, (s1 - 1) * delta2 + glo),  # left cap (localized)
-      ((s2 + 2) * delta2 + glo, (s3 + 2) * delta2 + glo),  # right cap
-      ((s0 + 2) * delta2 + glo, (s2 - 1) * delta2 + glo),  # cross 1
-      ((s1 + 2) * delta2 + glo, (s3 - 1) * delta2 + glo),  # cross 2
-      ((s0 + 3) * delta2 + glo, (s3 + 3) * delta2 + glo),  # cross3 (longer range)
-    ]
-    micro.extend(connectors)
-
-    # Sparse micro caps: add three long but safe caps at half-scale
-    cap1 = (glo + (delta2 // 4), glo + int(1.8 * delta2))
-    cap2 = (glo + int(0.9 * delta2), glo + int(2.6 * delta2))
-    mid = glo + G // 2
-    cap3 = (mid - max(1, delta2 // 8), mid + max(1, delta2 // 8))
-    for cap in (cap1, cap2, cap3):
-      if cap[1] > cap[0]:
-        micro.append(cap)
-
-    # Enforce budget
-    if len(micro) > budget:
-      micro = micro[:budget]
-    return micro
-
-  def build_micro_windows_round(current_T, budget, iter_id=0, alt=False):
-    """
-    A guarded micro-phase that translates a thin seed into 4 window positions
-    along the global span. This couples colors across distant regions while
-    keeping omega low via sparsity and localized connectors.
-    """
-    if not current_T or budget <= 8:
-      return []
-
-    glo = min(l for l, r in current_T)
-    ghi = max(r for l, r in current_T)
-    G = max(1, ghi - glo)
-
-    # Thin seed from current_T, evenly spaced
-    seed_sz = max(8, min(40, len(current_T) // 250))
-    stride = max(1, len(current_T) // max(1, seed_sz))
-    U = [current_T[i] for i in range(0, len(current_T), stride)][:seed_sz]
-    if not U:
-      return []
-
-    ulo = min(l for l, r in U)
-
-    # Two window families: primary (shifted) and alternate (fixed)
-    if not alt:
-      shift = (iter_id % 3) * 0.02
-      window_fracs = [
-        (0.12 + shift, 0.22 + shift),
-        (0.35 + shift, 0.45 + shift),
-        (0.58 + shift, 0.68 + shift),
-        (0.80 + shift, 0.90 + shift),
-      ]
-      window_fracs = [
-        (max(0.05, min(0.90, a)), max(a + 0.02, min(0.95, b)))
-        for (a, b) in window_fracs
-      ]
-    else:
-      window_fracs = [(0.05, 0.15), (0.28, 0.38), (0.60, 0.70), (0.82, 0.92)]
-
-    # Build translated micro-blocks aligned to these windows
-    blocks = []
-    for (fa, fb) in window_fracs:
-      win_lo = glo + int(round(fa * G))
-      base = win_lo - ulo
-      block = [(l + base, r + base) for (l, r) in U]
-      tag = iter_id if not alt else (iter_id + 1)
-      if ((int(round(fa * 100)) // 5) + tag) % 2 == 1:
-        block = list(reversed(block))
-      blocks.append(block)
-
-    # Interleave micro-blocks (forward on even iter, reverse on odd iter)
-    micro = []
-    maxlen = max(len(b) for b in blocks) if blocks else 0
+    # Interleave with parity-based order
     order = list(range(len(blocks)))
     if iter_id % 2 == 1:
       order.reverse()
+    micro = []
+    maxlen = max(len(b) for b in blocks)
     for i in range(maxlen):
       for idx in order:
         blk = blocks[idx]
         if i < len(blk):
           micro.append(blk[i])
 
-    # Fractional-span connectors analogous to KT caps; sparse and localized
-    micro_connectors = [
-      (glo + int(round(0.08 * G)), glo + int(round(0.30 * G))),  # left cap
-      (glo + int(round(0.60 * G)), glo + int(round(0.92 * G))),  # right cap
-      (glo + int(round(0.26 * G)), glo + int(round(0.56 * G))),  # cross 1
-      (glo + int(round(0.44 * G)), glo + int(round(0.78 * G))),  # cross 2
+    # Fractional connectors (KT-analog at global scale)
+    connectors = [
+      (glo + int(round(0.08 * G)), glo + int(round(0.30 * G))),
+      (glo + int(round(0.60 * G)), glo + int(round(0.92 * G))),
+      (glo + int(round(0.26 * G)), glo + int(round(0.56 * G))),
+      (glo + int(round(0.44 * G)), glo + int(round(0.78 * G))),
     ]
-    # Only in alternate phase, add a single long-range cross to strengthen coupling
-    if alt:
-      micro_connectors.append((glo + int(round(0.18 * G)), glo + int(round(0.84 * G))))
-
-    for a, b in micro_connectors:
+    for a, b in connectors:
       if b > a:
         micro.append((a, b))
 
-    # Trim to available budget
+    # Budget trim
     if len(micro) > budget:
       micro = micro[:budget]
     return micro
 
-  # Execute two micro rounds with strong guards
-  remaining = CAP - len(T)
-  mr1 = micro_round(T, round_id=0, budget=max(0, remaining // 2))
-  if mr1:
-    room = CAP - len(T)
-    if len(mr1) > room:
-      mr1 = mr1[:room]
-    T.extend(mr1)
-
-  remaining = CAP - len(T)
-  mr2 = micro_round(T, round_id=1, budget=max(0, remaining))
-  if mr2:
-    room = CAP - len(T)
-    if len(mr2) > room:
-      mr2 = mr2[:room]
-    T.extend(mr2)
-
-  # Secondary windowed micro-phase pulses (capacity-guarded)
-  remaining = CAP - len(T)
-  if remaining > 12:
-    microA = build_micro_windows_round(T, budget=max(12, remaining // 2), iter_id=0, alt=False)
+  # ------------------------------
+  # Cross4 connectors (long-range ties)
+  # ------------------------------
+  def cross4_layer(T, max_add=12):
+    if not T or max_add <= 0:
+      return T
+    glo, ghi, G = _span(T)
+    # Deterministic placement, conservative count and CAP-gated
+    cross = [
+      (glo + int(round(0.10 * G)), glo + int(round(0.85 * G))),
+      (glo + int(round(0.18 * G)), glo + int(round(0.72 * G))),
+      (glo + int(round(0.32 * G)), glo + int(round(0.94 * G))),
+    ]
+    for iv in cross[:max_add]:
+      if len(T) >= CAP:
+        break
+      if iv[1] > iv[0]:
+        T.append(iv)
+    return T
+
+  # ------------------------------
+  # Orchestrate pipeline
+  # ------------------------------
+  T = build_spine(rounds=6, rotate=True)
+
+  if len(T) < CAP - 8:
+    T = inject_caps(T)
+
+  # Micro-phase A (primary windows), CAP-aware
+  room = CAP - len(T)
+  if room > 8:
+    microA = _build_micro_windows(T, budget=min(room, max(12, room // 2)),
+                                  windows=WINDOWS_PRIMARY, iter_id=0, jitter=False)
     if microA:
       take = min(len(microA), CAP - len(T))
       T.extend(microA[:take])
 
-  remaining = CAP - len(T)
-  if remaining > 8:
-    microB = build_micro_windows_round(T, budget=min(128, remaining), iter_id=1, alt=True)
+  # Micro-phase B (alternate windows), CAP-aware
+  room = CAP - len(T)
+  if room > 8:
+    microB = _build_micro_windows(T, budget=min(room, 128),
+                                  windows=WINDOWS_ALT, iter_id=1, jitter=False)
     if microB:
       take = min(len(microB), CAP - len(T))
       T.extend(microB[:take])
 
+  # Cross4 long-range connector layer (final small push), CAP-aware
+  room = CAP - len(T)
+  if room > 0:
+    T = cross4_layer(T, max_add=min(8, room))
+
+  # Final capacity trim
+  if len(T) > CAP:
+    T = T[:CAP]
+
   return T
 
-  # return [  # Figure 3, OPT=2, FF=4
-  #   (2,3),
-  #   (6,7),
-  #   (10,11),
-  #   (14,15),
-  #   (1,5),
-  #   (12,16),
-  #   (4,9),
-  #   (8,13),
-  # ]
+
+def run_experiment(**kwargs):
+  """Main called by evaluator"""
+  return construct_intervals()
 
 # EVOLVE-BLOCK-END
 
 def run_experiment(**kwargs):
   """Main called by evaluator"""
   return construct_intervals()