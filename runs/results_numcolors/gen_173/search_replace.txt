<NAME>
dual_micro_with_cross4
</NAME>

<DESCRIPTION>
We add a second, distinct micro-phase to the end of the KT spine, and parameterize the micro gadget to accept different start templates and scale factors. This follows two proven strategies to raise FirstFit pressure without increasing omega:
- A second delta-scale micro-round using an alternate start set (1,5,9,13) and a smaller scale (G//3) creates cross-scale coupling that the first micro-phase misses. This aligns with the “two-stage micro backbone” heuristic.
- We introduce an optional cross4 connector in the second micro-phase only, which ties distant blocks and increases color mixing while keeping the count of long connectors small to avoid elevating the clique number.

The first micro-phase remains conservative (same starts, scale G//2, no cross4), while the second micro-phase is more aggressive but capacity-gated. We also slightly re-budget the micro-phase calls to leave room for the second phase. These targeted changes aim to exceed the prior alg=22 with opt=10 baseline while staying under CAP and not inflating omega. The spine remains deterministic and stable.

</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    def micro_round(current_T, round_id, budget):
      if budget <= 0 or not current_T:
        return []
      glo = min(l for l, r in current_T)
      ghi = max(r for l, r in current_T)
      G = max(1, ghi - glo)
      # Use half-scale to avoid expanding the global span too aggressively
      delta2 = max(1, G // 2)

      # Thin seed: bounded and deterministic size to respect budget
      per_block_target = max(8, min(64, budget // 12))
      U = thin_seed(current_T, per_block_target)
      if not U:
        return []

      # Build four translated blocks using the same 4-start template,
      # with deterministic parity-based internal reversal
      blocks = []
      ulo = min(l for l, r in U)
      for s in starts:
        base = s * delta2 - ulo
        block = [(l + base, r + base) for (l, r) in U]
        if ((s // 2) % 2) == (round_id % 2):
          block = list(reversed(block))
        blocks.append(block)

      micro = []
      # Parity-based interleaving across blocks
      maxlen = max(len(b) for b in blocks)
      if round_id % 2 == 0:
        for i in range(maxlen):
          for blk in blocks:
            if i < len(blk):
              micro.append(blk[i])
      else:
        for i in range(maxlen):
          for blk in reversed(blocks):
            if i < len(blk):
              micro.append(blk[i])

      # Deterministic connectors at delta2 scale, including a longer cross3
      s0, s1, s2, s3 = starts
      connectors = [
        ((s0 - 1) * delta2 + glo, (s1 - 1) * delta2 + glo),  # left cap
        ((s2 + 2) * delta2 + glo, (s3 + 2) * delta2 + glo),  # right cap
        ((s0 + 2) * delta2 + glo, (s2 - 1) * delta2 + glo),  # cross 1
        ((s1 + 2) * delta2 + glo, (s3 - 1) * delta2 + glo),  # cross 2
        ((s0 + 3) * delta2 + glo, (s3 + 3) * delta2 + glo),  # cross3 (long range)
      ]
      micro.extend(connectors)

      # Sparse micro caps to press FirstFit locally without raising omega much
      cap1 = (glo + (delta2 // 4), glo + int(1.8 * delta2))
      cap2 = (glo + int(0.9 * delta2), glo + int(2.6 * delta2))
      mid = glo + G // 2
      cap3 = (mid - max(1, delta2 // 8), mid + max(1, delta2 // 8))
      for cap in (cap1, cap2, cap3):
        if cap[1] > cap[0]:
          micro.append(cap)

      # Enforce budget
      if len(micro) > budget:
        micro = micro[:budget]
      return micro
=======
    def micro_round(current_T, round_id, budget, starts_param, scale_den=2, include_cross4=False):
      if budget <= 0 or not current_T:
        return []
      glo = min(l for l, r in current_T)
      ghi = max(r for l, r in current_T)
      G = max(1, ghi - glo)
      # Use reduced-scale to avoid expanding the global span too aggressively
      delta2 = max(1, G // max(1, int(scale_den)))

      # Thin seed: bounded and deterministic size to respect budget
      per_block_target = max(8, min(64, budget // 12))
      U = thin_seed(current_T, per_block_target)
      if not U:
        return []

      # Build translated blocks using the provided start template,
      # with deterministic parity-based internal reversal
      blocks = []
      ulo = min(l for l, r in U)
      starts_local = starts_param
      for s in starts_local:
        base = s * delta2 - ulo
        block = [(l + base, r + base) for (l, r) in U]
        if ((s // 2) % 2) == (round_id % 2):
          block = list(reversed(block))
        blocks.append(block)

      micro = []
      # Parity-based interleaving across blocks
      maxlen = max(len(b) for b in blocks)
      if round_id % 2 == 0:
        for i in range(maxlen):
          for blk in blocks:
            if i < len(blk):
              micro.append(blk[i])
      else:
        for i in range(maxlen):
          for blk in reversed(blocks):
            if i < len(blk):
              micro.append(blk[i])

      # Deterministic connectors at delta2 scale, including a longer cross3
      s0, s1, s2, s3 = starts_local[0], starts_local[1], starts_local[2], starts_local[3]
      connectors = [
        ((s0 - 1) * delta2 + glo, (s1 - 1) * delta2 + glo),  # left cap
        ((s2 + 2) * delta2 + glo, (s3 + 2) * delta2 + glo),  # right cap
        ((s0 + 2) * delta2 + glo, (s2 - 1) * delta2 + glo),  # cross 1
        ((s1 + 2) * delta2 + glo, (s3 - 1) * delta2 + glo),  # cross 2
        ((s0 + 3) * delta2 + glo, (s3 + 3) * delta2 + glo),  # cross3 (long range)
      ]
      if include_cross4:
        connectors.append(((s0 + 1) * delta2 + glo, (s3 - 1) * delta2 + glo))  # cross4 (very long)
      micro.extend(connectors)

      # Sparse micro caps to press FirstFit locally without raising omega much
      cap1 = (glo + (delta2 // 4), glo + int(1.8 * delta2))
      cap2 = (glo + int(0.9 * delta2), glo + int(2.6 * delta2))
      mid = glo + G // 2
      cap3 = (mid - max(1, delta2 // 8), mid + max(1, delta2 // 8))
      for cap in (cap1, cap2, cap3):
        if cap[1] > cap[0]:
          micro.append(cap)

      # Enforce budget
      if len(micro) > budget:
        micro = micro[:budget]
      return micro
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
    remaining = CAP - len(T)
    mr1 = micro_round(T, round_id=0, budget=max(0, remaining // 2))
    if mr1:
      room = CAP - len(T)
      if len(mr1) > room:
        mr1 = mr1[:room]
      T.extend(mr1)

    remaining = CAP - len(T)
    mr2 = micro_round(T, round_id=1, budget=max(0, remaining))
    if mr2:
      room = CAP - len(T)
      if len(mr2) > room:
        mr2 = mr2[:room]
      T.extend(mr2)
=======
    remaining = CAP - len(T)
    mr1 = micro_round(T, round_id=0, budget=max(0, remaining // 3), starts_param=starts, scale_den=2, include_cross4=False)
    if mr1:
      room = CAP - len(T)
      if len(mr1) > room:
        mr1 = mr1[:room]
      T.extend(mr1)

    remaining = CAP - len(T)
    mr2 = micro_round(T, round_id=1, budget=max(0, remaining // 2), starts_param=starts, scale_den=2, include_cross4=False)
    if mr2:
      room = CAP - len(T)
      if len(mr2) > room:
        mr2 = mr2[:room]
      T.extend(mr2)

    # Second micro-phase with distinct starts and smaller scale to amplify cross-scale coupling
    remaining = CAP - len(T)
    alt_starts = (1, 5, 9, 13)
    mr3 = micro_round(T, round_id=2, budget=max(0, remaining), starts_param=alt_starts, scale_den=3, include_cross4=True)
    if mr3:
      room = CAP - len(T)
      if len(mr3) > room:
        mr3 = mr3[:room]
      T.extend(mr3)
>>>>>>> REPLACE

</DIFF>