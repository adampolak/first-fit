--- a/original.py
+++ b/original.py
@@ -1,348 +1,361 @@
 # EVOLVE-BLOCK-START
 
 def _span_delta(T):
     """Return (lo, hi, delta) for current interval set T."""
     lo = min(l for l, _ in T)
     hi = max(r for _, r in T)
     delta = hi - lo
     if delta <= 0:
         delta = 1
     return lo, hi, delta
+
 
 def _svc_connectors(starts, delta):
     """Produce four canonical connectors given the start-pattern and block delta."""
     s0, s1, s2, s3 = starts
     return [
         ((s0 - 1) * delta, (s1 - 1) * delta),  # left cap
         ((s2 + 2) * delta, (s3 + 2) * delta),  # right cap
         ((s0 + 2) * delta, (s2 - 1) * delta),  # cross 1
         ((s1 + 2) * delta, (s3 - 1) * delta),  # cross 2
     ]
 
+
 def _translate_blocks(T, starts, delta, lo):
-    """Create four translated blocks from current T and a given start-pattern."""
+    """Create translated blocks from current T and a given start-pattern."""
     blocks = []
     for s in starts:
         base = s * delta - lo
         block = [(l + base, r + base) for (l, r) in T]
         blocks.append(block)
     return blocks
 
-def _assemble_from_blocks(blocks, interleave=False, reverse_order=False):
-    """Flatten blocks into S, optionally interleaving."""
+
+def _assemble_from_blocks(blocks, interleave=False, reverse_order=False, order=None):
+    """Flatten blocks into S, optionally interleaving with a given block order."""
     if not interleave:
         if reverse_order:
             blocks = list(reversed(blocks))
         S = []
         for blk in blocks:
             S.extend(blk)
         return S
 
     # Interleave across blocks
     maxlen = max((len(b) for b in blocks), default=0)
-    order = list(range(len(blocks)))
+    idxs = list(range(len(blocks)))
+    if order is not None:
+        idxs = [i for i in order if 0 <= i < len(blocks)]
+        if len(idxs) != len(blocks):
+            # fall back if order malformed
+            idxs = list(range(len(blocks)))
     if reverse_order:
-        order = list(reversed(order))
+        idxs = list(reversed(idxs))
     S = []
     for i in range(maxlen):
-        for idx in order:
-            blk = blocks[idx]
+        for bi in idxs:
+            blk = blocks[bi]
             if i < len(blk):
                 S.append(blk[i])
     return S
 
-def _apply_round(current_T, starts, do_interleave=False, reverse_order=False):
-    """One KT-round: translate 4 blocks, assemble, then append connectors."""
+
+def _apply_round(current_T, starts, do_interleave=False, reverse_order=False, interleave_order=None):
+    """One KT-style round: translate blocks, assemble, and append connectors."""
     lo, hi, delta = _span_delta(current_T)
-    # translate 4 blocks
     blocks = _translate_blocks(current_T, starts, delta, lo)
-    S = _assemble_from_blocks(blocks, interleave=do_interleave, reverse_order=reverse_order)
-    # append canonical connectors
+    S = _assemble_from_blocks(blocks, interleave=do_interleave, reverse_order=reverse_order, order=interleave_order)
     S += _svc_connectors(starts, delta)
     return S
 
+
 def _insert_tail_caps(T, caps, cap_cap):
-    """Safely insert tail caps up to a cap_cap budget."""
+    """Safely insert tail caps up to a cap_cap budget (insert near the tail to mix arrivals)."""
     room = cap_cap - len(T)
     if room <= 0:
         return T
+    out = list(T)
     for i, iv in enumerate(caps[:room]):
-        pos = len(T) - (i * 2 + 1)
+        pos = len(out) - (i * 2 + 1)
         if pos < 0:
-            T.append(iv)
+            out.append(iv)
         else:
-            T.insert(pos, iv)
-    return T
+            out.insert(pos, iv)
+    return out
+
+
+def _thin_seed(current_T, max_seed):
+    """Evenly spaced thin seed from current_T, bounded by max_seed."""
+    n = len(current_T)
+    if n <= 0 or max_seed <= 0:
+        return []
+    step = max(1, n // max_seed)
+    return current_T[::step][:max_seed]
+
+
+def _density_pins(current_T, budget, pattern_id=0):
+    """
+    Create very short pin intervals based on a thin seed of current_T.
+    Pins are placed in staggered small windows to increase FF pressure without boosting omega.
+    """
+    if budget <= 0 or not current_T:
+        return []
+    glo = min(l for l, _ in current_T)
+    ghi = max(r for _, r in current_T)
+    G = max(1, ghi - glo)
+
+    # Very thin pins
+    eps = max(1, G // 2048)
+    # Seed size bounded by budget to avoid explosion
+    seed_sz = max(8, min(24, len(current_T) // 500, budget))
+    U = _thin_seed(current_T, seed_sz)
+    if not U:
+        return []
+
+    ulo = min(l for l, _ in U)
+
+    # Choose three small central windows depending on pattern_id
+    if pattern_id % 2 == 0:
+        centers = [0.46, 0.52, 0.70]
+    else:
+        centers = [0.30, 0.50, 0.78]
+
+    pins = []
+    for wi, cf in enumerate(centers):
+        base = glo + int(round(cf * G)) - ulo
+        for idx, (l, r) in enumerate(U):
+            mid = (l + r) // 2
+            # small deterministic jitter tied to wi and idx
+            jit = (idx + 2 * wi + pattern_id) % 5
+            L = mid + base - (eps // 2) + jit
+            R = L + eps
+            if R > L:
+                pins.append((L, R))
+            if len(pins) >= budget:
+                return pins
+    return pins[:budget]
+
+
+def _append_long_connectors(current_T, max_count=5):
+    """
+    Add up to max_count long-range connectors across the global span,
+    placed to avoid central piling (to mitigate omega growth).
+    """
+    if not current_T or max_count <= 0:
+        return []
+    lo = min(l for l, _ in current_T)
+    hi = max(r for _, r in current_T)
+    G = max(1, hi - lo)
+    # Left, mid-left, mid-right, right families (avoid the exact center repeatedly)
+    fracs = [
+        (0.06, 0.26),
+        (0.18, 0.52),
+        (0.36, 0.62),
+        (0.54, 0.86),
+        (0.74, 0.94),
+    ]
+    conns = []
+    for (fa, fb) in fracs[:max_count]:
+        L = lo + int(round(fa * G))
+        R = lo + int(round(fb * G))
+        if R > L:
+            conns.append((L, R))
+    return conns
+
+
+def _build_micro_pass(current_T, budget, windows, seed_bounds=(16, 48), iter_tag=0):
+    """
+    Build a KT-like micro pass using distinct windows. Uses thin seed, interleaves blocks,
+    and appends fractional-span connectors. Capacity guarded by budget.
+    """
+    if not current_T or budget <= 8:
+        return []
+
+    glo = min(l for l, _ in current_T)
+    ghi = max(r for _, r in current_T)
+    G = max(1, ghi - glo)
+
+    min_seed, max_seed = seed_bounds
+    base_seed = max(min_seed, min(max_seed, max(min_seed, len(current_T) // 300)))
+    U = _thin_seed(current_T, base_seed)
+    if not U:
+        return []
+
+    ulo = min(l for l, _ in U)
+
+    blocks = []
+    # Slight deterministic shift to avoid exact repetition across passes
+    sh = (iter_tag % 3) * 0.01
+    for (fa, fb) in windows:
+        fa2 = max(0.05, min(0.93, fa + sh))
+        win_lo = glo + int(round(fa2 * G))
+        base = win_lo - ulo
+        block = [(l + base, r + base) for (l, r) in U]
+        # Parity reversal per window to destructure FF reuse patterns
+        if int(fa2 * 100) % 2 == 1:
+            block = list(reversed(block))
+        blocks.append(block)
+
+    # Interleave with a fixed, reproducible order to maximize mixing
+    order = list(range(len(blocks)))
+    if iter_tag % 2 == 1:
+        order = list(reversed(order))
+    micro = _assemble_from_blocks(blocks, interleave=True, reverse_order=False, order=order)
+
+    # Fractional-span connectors specialized for micro scale
+    connectors = [
+        (glo + int(round(0.08 * G)), glo + int(round(0.30 * G))),
+        (glo + int(round(0.44 * G)), glo + int(round(0.78 * G))),
+        (glo + int(round(0.60 * G)), glo + int(round(0.92 * G))),
+    ]
+    for a, b in connectors:
+        if b > a:
+            micro.append((a, b))
+
+    if len(micro) > budget:
+        micro = micro[:budget]
+    return micro
+
 
 def construct_intervals(seed_count=1):
     """
-    Deterministic KT-spine with modular, readable structure.
-    Produces a sequence of intervals for FirstFit with omega kept moderate.
-    Returns a list of (l, r) integer pairs with r > l, capped at 9800.
+    Six-template KT spine with deterministic interleaving, per-round short pin boosts,
+    two-pass CAP-aware micro phases, and long-range connectors.
+
+    Returns a list of (l, r) integer open intervals, length < 9800.
     """
     CAP = 9800
-
-    # Deterministic rotate templates
-    template_bank = [
-        (2, 6, 10, 14),  # classic KT
-        (1, 5, 9, 13),   # left-shifted
-        (3, 7, 11, 15),  # right-shifted
-        (4, 8, 12, 16),  # stretched-right
+    BASE_SEED = 137  # deterministic knob for orders/jitters (no randomness used)
+
+    # Six distinct start-pattern templates (KT-like)
+    templates6 = [
+        (2, 6, 10, 14),  # T1 classic KT
+        (1, 5, 9, 13),   # T2 left-shifted
+        (3, 7, 11, 15),  # T3 right-shifted
+        (4, 8, 12, 16),  # T4 stretched-right
+        (2, 8, 10, 12),  # T5 inner symmetric
+        (1, 7, 11, 15),  # T6 wide skew
     ]
 
-    # Seed sequence
+    # Seed sequence (multi-seed disabled by default to avoid early omega inflation)
     if seed_count <= 1:
         T = [(0, 1)]
     else:
         step = 3
         seeds = min(4, max(1, int(seed_count)))
         T = [(i * step, i * step + 1) for i in range(seeds)]
 
-    # Stage 1: six KT-style rounds with alternating interleave/reverse order
-    for ridx in range(6):
-        starts = template_bank[ridx % len(template_bank)]
-        nxt_size = 4 * len(T) + 4
-        if nxt_size > CAP:
+    # Spine parameters
+    ROUNDS = 6
+    DENSITY_BUDGET_TOTAL = 120  # total short pins across spine rounds (CAP-safe)
+    density_used = 0
+
+    # Stage 1: six-round hexaspine with deterministic interleaving and tiny pin boosts
+    for ridx in range(ROUNDS):
+        # capacity prediction for the next round only (ignoring tiny density pins)
+        if 4 * len(T) + 4 > CAP - (DENSITY_BUDGET_TOTAL - density_used):
             break
-        do_interleave = (ridx % 2 == 0)      # even rounds interleave
-        reverse_order = (ridx % 2 == 1)      # odd rounds reverse order
-        T = _apply_round(T, starts, do_interleave=do_interleave, reverse_order=reverse_order)
+
+        starts = templates6[(ridx + BASE_SEED) % len(templates6)]
+        do_interleave = (ridx % 2 == 0)  # even rounds interleave
+        reverse_order = (ridx % 3 == 1)  # occasional sequential reversal improves coupling
+        interleave_order = [0, 2, 1, 3] if (ridx + BASE_SEED) % 2 == 0 else [1, 3, 0, 2]
+
+        T = _apply_round(T, starts, do_interleave=do_interleave, reverse_order=reverse_order, interleave_order=interleave_order)
         if len(T) >= CAP:
             return T[:CAP]
 
-    # Stage 1b (optional): early return guard
-    if len(T) >= CAP - 16:
-        return T[:CAP]
-
-    # Micro-phase A: tail caps to mix colors without exploding omega
-    lo, hi, delta = _span_delta(T)
-    tail_caps = [
-        (lo + max(1, int(round(delta * 0.08))), lo + max(1, int(round(delta * 0.60)))),
-        (lo + max(1, int(round(delta * 0.25))), lo + max(1, int(round(delta * 0.75)))),
-        (lo + max(1, int(round(delta * 0.75))), lo + max(1, int(round(delta * 0.92)))),
-    ]
-    T = _insert_tail_caps(T, tail_caps, CAP)
-
-    if len(T) >= CAP - 16:
-        return T[:CAP]
-
-    # Stage 2: delta2 micro-rounds with thin seeds
-    def _thin_seed(current_T, max_seed):
-        n = len(current_T)
-        if n == 0 or max_seed <= 0:
-            return []
-        step = max(1, n // max_seed)
-        return current_T[::step][:max_seed]
-
-    def _build_micro_round(current_T, budget, iter_id=0, alt=False):
-        if not current_T or budget <= 8:
-            return []
-
-        glo = min(l for l, _ in current_T)
-        ghi = max(r for _, r in current_T)
-        G = max(1, ghi - glo)
-
-        # seed
-        seed_sz = max(8, min(40, len(current_T) // 250))
-        if alt:
-            seed_sz = max(8, min(64, len(current_T) // 200))
-        U = _thin_seed(current_T, seed_sz)
-        if not U:
-            return []
-
-        ulo = min(l for l, _ in U)
-
-        if not alt:
-            shift = (iter_id % 3) * 0.02
-            window_fracs = [
-                (0.12 + shift, 0.22 + shift),
-                (0.35 + shift, 0.45 + shift),
-                (0.58 + shift, 0.68 + shift),
-                (0.80 + shift, 0.90 + shift),
-            ]
-            window_fracs = [
-                (max(0.05, min(0.90, a)),
-                 max(0.10, min(0.95, b)))
-                for (a, b) in window_fracs
-            ]
-        else:
-            window_fracs = [(0.05, 0.15), (0.28, 0.38), (0.60, 0.70), (0.82, 0.92)]
-
-        blocks = []
-        for (fa, fb) in window_fracs:
-            win_lo = glo + int(round(fa * G))
-            base = win_lo - ulo
-            block = [(l + base, r + base) for (l, r) in U]
-            # small parity perturbation
-            tag = iter_id if not alt else (iter_id + 1)
-            if ((int(round(fa * 100)) // 5) + tag) % 2 == 1:
-                block = list(reversed(block))
-            blocks.append(block)
-
-        micro = _assemble_from_blocks(blocks, interleave=True, reverse_order=(iter_id % 2 == 1))
-
-        # connectors
-        micro_connectors = [
-            (glo + int(round(0.08 * G)), glo + int(round(0.30 * G))),
-            (glo + int(round(0.60 * G)), glo + int(round(0.92 * G))),
-            (glo + int(round(0.26 * G)), glo + int(round(0.56 * G))),
-            (glo + int(round(0.44 * G)), glo + int(round(0.78 * G))),
+        # Per-round tiny density boost using pins (short intervals)
+        room = CAP - len(T)
+        if room > 8 and density_used < DENSITY_BUDGET_TOTAL:
+            # Allocate pins this round, decreasing toward later rounds
+            pins_this_round = min(20 - 2 * ridx, DENSITY_BUDGET_TOTAL - density_used, room)
+            pins = _density_pins(T, pins_this_round, pattern_id=ridx)
+            if pins:
+                T.extend(pins)
+                density_used += len(pins)
+            if len(T) >= CAP:
+                return T[:CAP]
+
+    # Stage 1b: append 4â€“5 long-range connectors (capacity- and omega-conscious)
+    if len(T) < CAP - 8:
+        max_long = 5 if (BASE_SEED % 2 == 1) else 4
+        long_conns = _append_long_connectors(T, max_count=max_long)
+        room = CAP - len(T)
+        if long_conns and room > 0:
+            if len(long_conns) > room:
+                long_conns = long_conns[:room]
+            T.extend(long_conns)
+
+    if len(T) >= CAP - 8:
+        # almost at cap; return safely
+        return [(int(l), int(r) if int(r) > int(l) else int(l) + 1) for (l, r) in T[:CAP]]
+
+    # Stage 2: two-pass CAP-aware micro phases with non-overlapping window families
+
+    # Pass 1: windows A,B (inside span), moderate seed
+    WINDOWS_PASS1 = [(0.12, 0.20), (0.28, 0.36), (0.52, 0.60), (0.74, 0.82)]
+    # Pass 2: windows C,D (shifted set), slightly different ordering/seed
+    WINDOWS_PASS2 = [(0.20, 0.28), (0.36, 0.44), (0.60, 0.68), (0.82, 0.90)]
+
+    # Budget split: reserve a fraction for pass2 and for tail caps
+    room_total = CAP - len(T)
+    if room_total > 12:
+        # Split roughly 60/40 between two passes, keep a small hold-back for final caps
+        pass1_budget = max(8, (room_total * 6) // 10)
+        pass1 = _build_micro_pass(T, pass1_budget, WINDOWS_PASS1, seed_bounds=(16, 48), iter_tag=0)
+        if pass1:
+            if len(pass1) > pass1_budget:
+                pass1 = pass1[:pass1_budget]
+            T.extend(pass1)
+
+    if len(T) < CAP - 8:
+        room_left = CAP - len(T)
+        if room_left > 8:
+            pass2_budget = room_left - 4  # keep few slots for final tail caps
+            pass2 = _build_micro_pass(T, pass2_budget, WINDOWS_PASS2, seed_bounds=(20, 48), iter_tag=1)
+            if pass2:
+                if len(pass2) > pass2_budget:
+                    pass2 = pass2[:pass2_budget]
+                T.extend(pass2)
+
+    # Stage 3: final tail caps (a few) to strengthen late coupling without omega blow-up
+    if len(T) < CAP - 4:
+        lo, hi, delta = _span_delta(T)
+        tail_caps = [
+            (lo + max(1, int(round(delta * 0.08))), lo + max(1, int(round(delta * 0.60)))),
+            (lo + max(1, int(round(delta * 0.25))), lo + max(1, int(round(delta * 0.75)))),
+            (lo + max(1, int(round(delta * 0.75))), lo + max(1, int(round(delta * 0.92)))),
+            (lo + max(1, int(round(delta * 0.14))), lo + max(1, int(round(delta * 0.70)))),
         ]
-        for a, b in micro_connectors:
-            if b > a:
-                micro.append((a, b))
-
-        if len(micro) > budget:
-            micro = micro[:budget]
-        return micro
-
-    # Run two main micro rounds (safe cap)
-    steps = 2
-    for it in range(steps):
-        room = CAP - len(T)
-        if room <= 8:
-            break
-        micro = _build_micro_round(T, room, iter_id=it, alt=False)
-        if not micro:
-            break
-        if len(micro) > room:
-            micro = micro[:room]
-        T.extend(micro)
-
-    # Alternate micro family
-    room = CAP - len(T)
-    if room > 8:
-        micro_alt = _build_micro_round(T, room, iter_id=2, alt=True)
-        if micro_alt:
-            if len(micro_alt) > room:
-                micro_alt = micro_alt[:room]
-            T.extend(micro_alt)
-
-    # Stage 3: small pinning micro-phase (short intervals to cap omega)
-    if len(T) < CAP - 8:
-        glo2 = min(l for l, _ in T)
-        ghi2 = max(r for _, r in T)
-        G2 = max(1, ghi2 - glo2)
-        U2 = _thin_seed(T, max(8, min(24, len(T) // 400)))
-        if U2:
-            ulo2 = min(l for l, r in U2)
-            eps = max(1, G2 // 512)
-            windows2 = [(0.05, 0.15), (0.28, 0.38), (0.60, 0.70), (0.82, 0.92)]
-            blocks2 = []
-            for (fa, fb) in windows2:
-                win_lo2 = glo2 + int(round(fa * G2))
-                base2 = win_lo2 - ulo2
-                block = []
-                for idx, (l, r) in enumerate(U2):
-                    mid = (l + r) // 2
-                    L = mid + base2 - (eps // 2) + (idx % 3)
-                    R = L + eps
-                    if R > L:
-                        block.append((L, R))
-                blocks2.append(block)
-
-            micro2 = []
-            if blocks2:
-                maxlen2 = max(len(b) for b in blocks2)
-                order2 = [3, 1, 0, 2]
-                for i in range(maxlen2):
-                    for idx in order2:
-                        blk = blocks2[idx]
-                        if i < len(blk):
-                            micro2.append(blk[i])
-
-            caps2 = [
-                (glo2 + int(round(0.09 * G2)), glo2 + int(round(0.09 * G2)) + eps),
-                (glo2 + int(round(0.64 * G2)), glo2 + int(round(0.64 * G2)) + eps),
-            ]
-            for a, b in caps2:
-                if b > a:
-                    micro2.append((a, b))
-
-            room2 = CAP - len(T)
-            if room2 > 0:
-                if len(micro2) > room2:
-                    micro2 = micro2[:room2]
-                T.extend(micro2)
-
-    # Stage 4: tower-and-cap micro-phase (five towers with caps)
-    if len(T) < CAP - 12:
-        glo3 = min(l for l, r in T)
-        ghi3 = max(r for l, r in T)
-        G3 = max(1, ghi3 - glo3)
-
-        U3 = _thin_seed(T, max(12, min(36, len(T) // 300)))
-        if U3:
-            ulo3 = min(l for l, r in U3)
-            eps3 = max(1, G3 // 768)
-
-            towers = [(0.10, 0.18), (0.28, 0.36), (0.46, 0.54), (0.64, 0.72), (0.82, 0.90)]
-            levels = 3
-            tower_blocks = []
-            for t_idx, (fa, fb) in enumerate(towers):
-                win_lo3 = glo3 + int(round(fa * G3))
-                base3 = win_lo3 - ulo3
-                block = []
-                for idx, (l, r) in enumerate(U3):
-                    mid = (l + r) // 2
-                    for lv in range(levels):
-                        jitter = (idx + lv + t_idx) % 4
-                        L = mid + base3 - (eps3 // 2) + jitter + lv
-                        R = L + eps3
-                        if R > L:
-                            block.append((L, R))
-                tower_blocks.append(block)
-
-            tower_phase = []
-            if tower_blocks:
-                maxlen3 = max(len(b) for b in tower_blocks)
-                order3 = [0, 2, 4, 1, 3]
-                for i in range(maxlen3):
-                    for idx in order3:
-                        blk = tower_blocks[idx]
-                        if i < len(blk):
-                            tower_phase.append(blk[i])
-
-            caps3 = [
-                (glo3 + int(round(0.15 * G3)), glo3 + int(round(0.45 * G3))),
-                (glo3 + int(round(0.38 * G3)), glo3 + int(round(0.70 * G3))),
-                (glo3 + int(round(0.60 * G3)), glo3 + int(round(0.88 * G3))),
-            ]
-            for a, b in caps3:
-                if b > a:
-                    tower_phase.append((a, b))
-
-            room3 = CAP - len(T)
-            if room3 > 0 and tower_phase:
-                if len(tower_phase) > room3:
-                    tower_phase = tower_phase[:room3]
-                T.extend(tower_phase)
-
-    # Final capacity guard
+        T = _insert_tail_caps(T, tail_caps, CAP)
+
+    # Final capacity guard and normalization to integer endpoints
     if len(T) > CAP:
         T = T[:CAP]
 
-    # Normalize endpoints to integers with r > l
     if not T:
         return []
+
+    # Shift to non-negative if needed
     min_l = min(l for l, _ in T)
     if min_l < 0:
         T = [(l - min_l, r - min_l) for (l, r) in T]
 
     intervals = []
     for (l, r) in T:
         li = int(l)
         ri = int(r)
         if ri <= li:
             ri = li + 1
         intervals.append((li, ri))
 
     if len(intervals) > CAP:
         intervals = intervals[:CAP]
     return intervals
 
 # EVOLVE-BLOCK-END
 
 def run_experiment(**kwargs):
   """Main called by evaluator"""
   return construct_intervals()