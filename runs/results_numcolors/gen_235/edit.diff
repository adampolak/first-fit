--- a/original.py
+++ b/original.py
@@ -1,208 +1,162 @@
 # EVOLVE-BLOCK-START
 
 def construct_intervals(seed_count=1):
-  """
-  Construct a sequence of intervals of real line,
-  in the order in which they are presented to FirstFit,
-  so that it maximizes the number of colors used by FirstFit
-  divided by the maximum number of intervals that cover a single point
+    """
+    Same I/O as original: returns list of (l, r) open intervals.
+    Implements an improved KT spine + multi-phase micro-gadget strategy.
+    """
+    # hard cap and gating margin
+    CAP = 9800
+    CAP_MARGIN = 32
+    # density multiplier for spine
+    K_DENSITY = 2
 
-  The initial implementation uses the construction from
-  Figure 4 in https://arxiv.org/abs/1506.00192
+    # four strong KT templates
+    template_bank = [
+        (2, 6, 10, 14),
+        (1, 5, 9, 13),
+        (3, 7, 11, 15),
+        (4, 8, 12, 16),
+    ]
 
-  Returns:
-    intervals: list of tuples, each tuple (l, r) represents an open interval from l to r
-  """
+    # seed
+    T = [(0,1)] if seed_count<=1 else [(i*3,i*3+1) for i in range(seed_count)]
 
-  # Capacity guard to keep the total count under 10000 and allow a micro-phase
-  CAP = 9800
+    # helper: span and delta
+    def span_delta(X):
+        lo = min(l for l,r in X)
+        hi = max(r for l,r in X)
+        d = hi-lo if hi>lo else 1
+        return lo, hi, d
 
-  # Rotate among four strong start-pattern templates to couple colors across scales
-  template_bank = [
-    (2, 6, 10, 14),
-    (1, 5, 9, 13),
-    (3, 7, 11, 15),
-    (4, 8, 12, 16),
-  ]
+    # append connectors
+    def append_connectors(S, starts, delta, cross4=False):
+        s0,s1,s2,s3 = starts
+        S.append(((s0-1)*delta, (s1-1)*delta))
+        S.append(((s2+2)*delta, (s3+2)*delta))
+        S.append(((s0+2)*delta, (s2-1)*delta))
+        S.append(((s1+2)*delta, (s3-1)*delta))
+        if cross4:
+            S.append(((s0+4)*delta, (s3+4)*delta))
 
-  # Seed with multiple disjoint unit intervals if requested (new capability)
-  if seed_count <= 1:
-    T = [(0, 1)]
-  else:
-    step = 3
-    T = [(i * step, i * step + 1) for i in range(seed_count)]
+    # Stage1: KT rounds with density K_DENSITY
+    def apply_round(X, starts, interleave, rev, cross4=False):
+        lo,hi,delta = span_delta(X)
+        blocks=[]
+        for s in starts:
+            base = s*K_DENSITY*delta - lo
+            blocks.append([(l+base, r+base) for l,r in X])
+        S=[]
+        if interleave:
+            maxlen = max(len(b) for b in blocks)
+            order = list(range(4))
+            if rev: order.reverse()
+            for i in range(maxlen):
+                for idx in order:
+                    blk=blocks[idx]
+                    if i<len(blk): S.append(blk[i])
+        else:
+            if rev: blocks.reverse()
+            for blk in blocks: S.extend(blk)
+        append_connectors(S, starts, delta, cross4)
+        return S
 
-  # Six KT-style rounds with deterministic parity interleaving
-  for round_idx in range(6):
-    starts = template_bank[round_idx % 4]
-    lo = min(l for l, r in T)
-    hi = max(r for l, r in T)
-    delta = hi - lo if hi > lo else 1
-    # build translated blocks
-    blocks = []
-    for start in starts:
-      blocks.append([(delta * start + l - lo, delta * start + r - lo) for l, r in T])
-    S = []
-    # interleave blocks on even rounds, sequential on odd rounds
-    if round_idx % 2 == 0:
-      maxlen = max(len(b) for b in blocks)
-      for i in range(maxlen):
-        for blk in blocks:
-          if i < len(blk):
-            S.append(blk[i])
-    else:
-      for blk in blocks:
-        S.extend(blk)
-    # connectors based on the active starts
-    s0, s1, s2, s3 = starts
-    connectors = [
-      (delta * (s0 - 1), delta * (s1 - 1)),  # left cap
-      (delta * (s2 + 2), delta * (s3 + 2)),  # right cap
-      (delta * (s0 + 2), delta * (s2 - 1)),  # cross 1
-      (delta * (s1 + 2), delta * (s3 - 1)),  # cross 2
-    ]
-    for a, b in connectors:
-      S.append((a, b))
-    T = S
+    # predict how many rounds fit
+    def fit_rounds(initial, maxr):
+        sz=initial; cnt=0
+        for i in range(maxr):
+            nxt = 4*sz+4
+            if nxt>CAP: break
+            sz=nxt; cnt+=1
+        return cnt
 
-  # Micro-phase A: add three long-range caps to boost late FirstFit color usage while controlling omega
-  lo = min(l for l, r in T)
-  hi = max(r for l, r in T)
-  delta = hi - lo if hi > lo else 1
-  def cap_at(a_frac, b_frac):
-    l0 = lo + max(1, int(round(a_frac * delta)))
-    r0 = lo + max(1, int(round(b_frac * delta)))
-    return (l0, r0)
-  capA = cap_at(0.08, 0.60)
-  capB = cap_at(0.25, 0.75)
-  capC = cap_at(0.75, 0.92)
-  for cap in (capA, capB, capC):
-    if cap[1] > cap[0]:
-      T.append(cap)
+    # run spine
+    rounds=6
+    depth = fit_rounds(len(T), rounds)
+    for i in range(depth):
+        starts = template_bank[i%4]
+        inter = (i%2==0)
+        rev   = (i%2==1)
+        # sprinkle a long‐range connector on the last round
+        cross4 = (i==depth-1)
+        T = apply_round(T, starts, inter, rev, cross4=cross4)
 
-  # Micro-phase B: a thin delta2 micro-round (capacity-guarded) to increase FF colors without raising omega much
-  if len(T) < CAP - 16:
-    glo = min(l for l, r in T)
-    ghi = max(r for l, r in T)
-    G = ghi - glo if ghi > glo else 1
+    # if near capacity, skip micro-phases
+    if len(T) > CAP - CAP_MARGIN:
+        return T
 
-    # Thin seed of current T (small and evenly spaced)
-    seed_sz = max(8, min(32, len(T) // 300))
-    stride = max(1, len(T) // max(1, seed_sz))
-    U = [T[i] for i in range(0, len(T), stride)][:seed_sz]
+    lo,hi,delta = span_delta(T)
+    # simple long‐caps near tail
+    def mkcap(a,b):
+        L=lo+max(1,int(round(a*delta)))
+        R=lo+max(1,int(round(b*delta)))
+        return (L,R) if R>L else (L,L+1)
+    tail_caps = [mkcap(0.08,0.60), mkcap(0.25,0.75), mkcap(0.75,0.92)]
+    # insert near end to hit many active colors
+    out = T[:]
+    for idx,cap in enumerate(tail_caps):
+        pos = len(out)-(2*idx+1)
+        if pos<0: out.append(cap)
+        else:     out.insert(pos, cap)
+    T = out[:CAP]
 
-    if U:
-      ulo = min(l for l, r in U)
+    # Stage2: two delta2 micro-phases
+    def build_micro(X, budget, windows, iter_id):
+        glo,ghi,G = *span_delta(X), None
+        glo,ghi,_ = span_delta(X)
+        G = ghi-glo if ghi>glo else 1
+        # thin seed
+        seed_sz = max(8, min(40, len(X)//250))
+        stride = max(1, len(X)//seed_sz)
+        U = [X[j] for j in range(0,len(X),stride)][:seed_sz]
+        if not U: return []
+        ulo = min(l for l,r in U)
+        blocks=[]
+        for w_idx,(fa,fb) in enumerate(windows):
+            win_lo = glo+int(round(fa*G))
+            base = win_lo-ulo
+            blk = [(l+base, r+base) for l,r in U]
+            # break symmetry
+            if (w_idx+iter_id)%2: blk.reverse()
+            blocks.append(blk)
+        # interleave
+        micro=[]
+        maxlen=max(len(b) for b in blocks)
+        order=list(range(len(blocks)))
+        if iter_id%2: order.reverse()
+        for i in range(maxlen):
+            for o in order:
+                if i<len(blocks[o]): micro.append(blocks[o][i])
+        # connectors
+        con_fracs = [(0.08,0.30),(0.26,0.56),(0.44,0.78),(0.60,0.92)]
+        for (a,b) in con_fracs:
+            A=glo+int(round(a*G)); B=glo+int(round(b*G))
+            if B>A: micro.append((A,B))
+        return micro[:budget]
 
-      # Four windows across the global span (stay inside to avoid omega spikes)
-      window_fracs = [(0.12, 0.22), (0.35, 0.45), (0.58, 0.68), (0.80, 0.90)]
-      micro_blocks = []
-      for (fa, fb) in window_fracs:
-        win_lo = glo + int(round(fa * G))
-        base = win_lo - ulo
-        block = [(l + base, r + base) for (l, r) in U]
-        micro_blocks.append(block)
+    # primary windows
+    primary_w = [(0.12,0.22),(0.35,0.45),(0.58,0.68),(0.80,0.90)]
+    # alternate windows
+    alt_w     = [(0.05,0.15),(0.28,0.38),(0.60,0.70),(0.82,0.92)]
+    # run two phases if room
+    for phase,(wins,shifted) in enumerate(((primary_w,False),(alt_w,True))):
+        if len(T) > CAP - CAP_MARGIN: break
+        room = CAP - len(T)
+        micro = build_micro(T, room, wins, phase)
+        T.extend(micro)
+    # parabolic micro-phase if still room
+    if len(T) <= CAP - CAP_MARGIN:
+        lo,hi,delta=span_delta(T)
+        par = []
+        for (a,b) in [(0.15,0.60),(0.25,0.80),(0.55,0.95)]:
+            A=lo+int(round(a*delta)); B=lo+int(round(b*delta))
+            if B>A: par.append((A,B))
+        T.extend(par[:CAP-len(T)])
 
-      # Interleave the micro-blocks
-      micro = []
-      maxlen = max(len(b) for b in micro_blocks)
-      for i in range(maxlen):
-        for blk in micro_blocks:
-          if i < len(blk):
-            micro.append(blk[i])
-
-      # Fractional-span connectors at the delta2 scale
-      micro_connectors = [
-        (glo + int(round(0.08 * G)), glo + int(round(0.30 * G))),
-        (glo + int(round(0.60 * G)), glo + int(round(0.92 * G))),
-        (glo + int(round(0.26 * G)), glo + int(round(0.56 * G))),
-        (glo + int(round(0.44 * G)), glo + int(round(0.78 * G))),
-      ]
-      for a, b in micro_connectors:
-        if b > a:
-          micro.append((a, b))
-
-      # Capacity guard
-      room = CAP - len(T)
-      if room > 0:
-        if len(micro) > room:
-          micro = micro[:room]
-        T.extend(micro)
-
-  # Micro-phase C: second guarded micro-round using distinct windows and pin shrinking
-  if len(T) < CAP - 8:
-    glo2 = min(l for l, r in T)
-    ghi2 = max(r for l, r in T)
-    G2 = ghi2 - glo2 if ghi2 > glo2 else 1
-
-    # Thin seed again (slightly smaller to limit omega growth)
-    seed_sz2 = max(8, min(24, len(T) // 400))
-    stride2 = max(1, len(T) // max(1, seed_sz2))
-    U2 = [T[i] for i in range(0, len(T), stride2)][:seed_sz2]
-
-    if U2:
-      ulo2 = min(l for l, r in U2)
-
-      # New window set to avoid stacking with phase B windows
-      windows2 = [(0.05, 0.15), (0.28, 0.38), (0.60, 0.70), (0.82, 0.92)]
-
-      # Short pins to reduce clique growth; slight stagger to avoid co-location
-      eps = max(1, G2 // 512)
-      blocks2 = []
-      for (fa, fb) in windows2:
-        win_lo2 = glo2 + int(round(fa * G2))
-        base2 = win_lo2 - ulo2
-        block = []
-        for idx, (l, r) in enumerate(U2):
-          mid = (l + r) // 2
-          L = mid + base2 - (eps // 2) + (idx % 3)
-          R = L + eps
-          if R > L:
-            block.append((L, R))
-        blocks2.append(block)
-
-      # Interleave with a different order to diversify coupling
-      micro2 = []
-      if blocks2:
-        maxlen2 = max(len(b) for b in blocks2)
-        order2 = [3, 1, 0, 2]
-        for i in range(maxlen2):
-          for idx in order2:
-            blk = blocks2[idx]
-            if i < len(blk):
-              micro2.append(blk[i])
-
-      # Very short cap-pins to tie windows without inflating omega
-      caps2 = [
-        (glo2 + int(round(0.09 * G2)), glo2 + int(round(0.09 * G2)) + eps),
-        (glo2 + int(round(0.64 * G2)), glo2 + int(round(0.64 * G2)) + eps),
-      ]
-      for a, b in caps2:
-        if b > a:
-          micro2.append((a, b))
-
-      # Capacity guard
-      room2 = CAP - len(T)
-      if room2 > 0:
-        if len(micro2) > room2:
-          micro2 = micro2[:room2]
-        T.extend(micro2)
-
-  return T
-
-  # return [  # Figure 3, OPT=2, FF=4
-  #   (2,3),
-  #   (6,7),
-  #   (10,11),
-  #   (14,15),
-  #   (1,5),
-  #   (12,16),
-  #   (4,9),
-  #   (8,13),
-  # ]
+    return T[:CAP]
 
 # EVOLVE-BLOCK-END
 
 def run_experiment(**kwargs):
   """Main called by evaluator"""
   return construct_intervals()