--- a/original.py
+++ b/original.py
@@ -1,60 +1,78 @@
 # EVOLVE-BLOCK-START
 
-def construct_intervals(rounds=2):
-  """
-  Construct a sequence of intervals of real line,
-  in the order in which they are presented to FirstFit,
-  so that it tends to maximize the number of colors used by FirstFit
-  divided by the maximum number of intervals that cover a single point
-  through a recursive wave construction.
+def construct_intervals(rounds=3, seed_lo=0.0, seed_scale=1.0):
+    """
+    Construct a sequence of open intervals that FirstFit colors online,
+    aiming to maximize FF-colors / clique-size (omega).
+    - rounds: number of recursive expansion rounds
+    - seed_lo, seed_scale: initial placement and scale knobs
+    Returns: list of (l, r) intervals in arrival order.
+    """
+    # Seed with several disjoint unit intervals for early overlap coupling
+    T = [
+        (seed_lo, seed_lo + 1.0 * seed_scale),
+        (seed_lo + 2.0 * seed_scale, seed_lo + 3.0 * seed_scale),
+        (seed_lo + 4.0 * seed_scale, seed_lo + 5.0 * seed_scale),
+        (seed_lo + 6.0 * seed_scale, seed_lo + 7.0 * seed_scale),
+    ]
 
-  The construction generalizes the two-round pattern used in Figure 4 of
-  https://arxiv.org/abs/1506.00192 to a multi-round recursive expansion.
+    # Four-interval gadget templates
+    templates = [
+        [(1, 5),   (12, 16), (4, 9),  (8, 13)],   # A
+        [(0.5,4.5),(11,15),  (3.5,8.5),(7,12)],    # B
+        [(1,4),   (6,9),    (3,7),   (9,13)],     # C
+        [(2,6),   (7,11),   (0,3),   (10,14)],    # D
+    ]
+    # Deterministic cycle of start-patterns
+    start_patterns = [
+        (2,6,10,14),                   # compact 4-wave
+        (2,4,6,8,10,12,14,16),         # dense 8-wave
+        (2,5,8,11,14,17,20),           # staggered 7-wave
+    ]
 
-  Returns:
-    intervals: list of tuples, each tuple (l, r) represents an open interval from l to r
-  """
-  T = [(0, 1)]
-  for round_idx in range(rounds):
-    lo = min(l for l, r in T)
-    hi = max(r for l, r in T)
-    delta = hi - lo
-    S = []
-    # In earlier rounds we apply a compact set of shifts; in later rounds,
-    # we widen the set of shifts to inject more waves and increase color usage.
-    # Density-increasing starts: first round uses a core set, subsequent rounds add more starts
-    if round_idx == 0:
-      starts = [2, 4, 6, 8, 10, 12, 14, 16]
-    else:
-      starts = [2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 24, 28]
-    for start in starts:
-      S += [(delta * start + l - lo, delta * start + r - lo) for l, r in T]
-    # additional local blocks to create overlapping waves without increasing omega too much
-    S += [
-      (delta * 1, delta * 5),
-      (delta * 12, delta * 16),
-      (delta * 4, delta * 9),
-      (delta * 8, delta * 13),
-      # extra caps to push color usage further without bloating omega
-      (delta * 0.5, delta * 2.0),
-      (delta * 14.0, delta * 15.0)
-    ]
-    T = S
-  return T
+    for round_idx in range(rounds):
+        lo = min(l for l, r in T)
+        hi = max(r for l, r in T)
+        delta = hi - lo if hi > lo else 1.0
 
-  # return [  # Figure 3, OPT=2, FF=4
-  #   (2,3),
-  #   (6,7),
-  #   (10,11),
-  #   (14,15),
-  #   (1,5),
-  #   (12,16),
-  #   (4,9),
-  #   (8,13),
-  # ]
+        # pick start pattern and template for this round
+        starts = list(start_patterns[round_idx % len(start_patterns)])
+        template = templates[round_idx % len(templates)]
+
+        S = []
+        # clone T into shifted blocks, reversing on odd indices
+        for idx, start in enumerate(starts):
+            base = T if (idx % 2 == 0) else list(reversed(T))
+            # translate each interval in base
+            for (l, r) in base:
+                S.append((delta * start + l - lo, delta * start + r - lo))
+            # light bridge to next block
+            if idx + 1 < len(starts):
+                nxt = starts[idx+1]
+                S.append((delta*(start+0.5), delta*(nxt+0.5)))
+
+        # add the chosen gadget template scaled
+        for (a, b) in template:
+            S.append((delta*a, delta*b))
+
+        # short caps around each start to press local FF usages
+        cap_radius = 0.3
+        cap_length = 1.2
+        for start in starts:
+            mid = delta*start
+            S.append((mid - cap_radius, mid + cap_length))
+
+        # longer sparse caps spanning blocks to couple distant colors
+        max_start = max(starts)
+        for j in range(3, max_start, max(3, max_start//4)):
+            S.append((delta*(j - 1), delta*(j + 2)))
+
+        T = S
+
+    return T
 
 # EVOLVE-BLOCK-END
 
 def run_experiment(**kwargs):
   """Main called by evaluator"""
   return construct_intervals()