<NAME>
add_cap_margin_and_alt_micro_with_cross_connectors
</NAME>

<DESCRIPTION>
I propose three targeted, compatible improvements designed to raise FirstFit pressure while keeping the clique number low:

1. CAP_MARGIN: introduce a small capacity margin (default 64) so micro-phases only run when there is meaningful room. This reduces brittle saturation effects and lets micro-phases run deeper and more effectively without accidentally hitting the cap mid-phase.

2. Alternate micro-phase (alt=True): extend the existing micro_round to support an alternate micro-pattern. The alternate pass uses a different set of window fractions and an initial set of short "blocker" pins per window. The blockers purposely occupy small colors early and are short enough to avoid forming large cliques, but they bias FirstFit toward using more colors later.

3. Final cross-connectors and micro-tail: after micro-rounds, add a few deterministic long-range cross connectors tying distant regions (lightweight, capacity guarded) and also insert a small micro-tail of caps (via the existing helper _append_micro_tail). These strengthen coupling across scales and boost late FF usage.

All changes are capacity-guarded and deterministic. They are local edits (do not rewrite program) and should be safe under the 10000 interval budget. The modifications are intended to increase the competitive_ratio / combined_score by improving micro-phase effectiveness and cross-scale coupling.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
# EVOLVE-BLOCK-START

def _span_delta(T):
  lo = min(l for l, _ in T)
  hi = max(r for _, r in T)
  delta = hi - lo
  if delta <= 0:
    delta = 1
  return lo, hi, delta

def _build_blocks_sequential(T, starts, delta, lo, K=1):
  """
  Build four translated blocks sequentially. No interleaving. This ordering
  is known to amplify FirstFit color pressure. K is a tunable spacing multiplier (default 1).
  """
  S = []
  for s in starts:
    base = s * delta * K - lo
    S.extend((l + base, r + base) for (l, r) in T)
  return S

def _append_connectors(S, starts, delta, add_cross4=False):
  """
  Append the classic four connectors. Optionally add a single long-range cross4
  on the final round to improve pressure while keeping total size under CAP.
  """
  s0, s1, s2, s3 = starts
  S.append(((s0 - 1) * delta, (s1 - 1) * delta))  # left cap
  S.append(((s2 + 2) * delta, (s3 + 2) * delta))  # right cap
  S.append(((s0 + 2) * delta, (s2 - 1) * delta))  # cross 1
  S.append(((s1 + 2) * delta, (s3 - 1) * delta))  # cross 2
  if add_cross4:
    S.append(((s0 + 4) * delta, (s3 + 4) * delta))  # long-range cross (final-round only)

def _append_micro_tail(T, max_extra=8):
  """
  Append a tiny tail of long caps near the end of T. This boosts FF late with minimal
  impact on omega. Caps are inserted near the end (rather than simply appended) to
  intersect many active colors while avoiding a single dense core.
  """
  if not T or max_extra <= 0:
    return T
  lo, hi, delta = _span_delta(T)
  d2 = max(1, delta // 4)
  # Symmetric, sparse long caps
  micro = [
      (lo + 1 * d2, lo + 5 * d2),
      (lo + 3 * d2, lo + 8 * d2),
      (hi - 6 * d2, hi - 2 * d2),
      (hi - 8 * d2, hi - 3 * d2),
  ]
  # Insert near the tail in a staggered fashion
  for i, interval in enumerate(micro[:max_extra]):
    pos = len(T) - (i * 2 + 1)
    if pos < 0:
      T.append(interval)
    else:
      T.insert(pos, interval)
  return T

def construct_intervals(seed_count=1, phase2_iters=2, enable_parabolic=False):
  """
  Construct a sequence of intervals of real line,
  in the order in which they are presented to FirstFit,
  so that it maximizes the number of colors used by FirstFit
  divided by the maximum number of intervals that cover a single point.

  This hybrid combines the six-round KT spine with delta2 micro-rounds
  and an optional parabolic micro-phase for extra FF pressure under control.
  """
  CAP = 9800

  # Stage 1: six KT rounds, deterministic spine with classic connectors
  spine_starts = (2, 6, 10, 14)
  T = [(0, 1)]

  def apply_round(current_T, starts, do_interleave=False):
    lo, hi, delta = _span_delta(current_T)
    blocks = []
    for s in starts:
      base = s * delta - lo
      blocks.append([(l + base, r + base) for (l, r) in current_T])

    S = []
    if do_interleave:
      maxlen = max(len(b) for b in blocks)
      for i in range(maxlen):
        for blk in blocks:
          if i < len(blk):
            S.append(blk[i])
    else:
      for blk in blocks:
        S.extend(blk)

    # connectors
    _append_connectors(S, starts, delta, add_cross4=False)
    return S

  for ridx in range(6):
    nxt_size = 4 * len(T) + 4
    if nxt_size > CAP:
      break
    # alternate interleaving pattern to push FF
    T = apply_round(T, spine_starts, do_interleave=(ridx % 2 == 0))

  # If we are near cap, return baseline
  if len(T) >= CAP - 16:
    return T

  # Stage 2: micro delta2 rounds with a thin seed
  def thin_seed(current_T, max_seed):
    n = len(current_T)
    if n == 0 or max_seed <= 0:
      return []
    step = max(1, n // max_seed)
    U = current_T[::step][:max_seed]
    return U

  def micro_round(current_T, round_id, budget):
    if budget <= 0 or not current_T:
      return []

    glo = min(l for l, r in current_T)
    ghi = max(r for l, r in current_T)
    G = max(1, ghi - glo)
    delta2 = max(1, G // 2)

    per_block_target = max(8, min(64, budget // 12))
    U = thin_seed(current_T, per_block_target)
    if not U:
      return []

    starts = spine_starts
    blocks = []
    ulo = min(l for l, r in U)
    for s in starts:
      base = s * delta2 - ulo
      block = [(l + base, r + base) for (l, r) in U]
      # tiny asymmetry
      if ((s // 2) % 2) == (round_id % 2):
        block = list(reversed(block))
      blocks.append(block)

    micro = []
    if round_id % 2 == 0:
      maxlen = max(len(b) for b in blocks)
      for i in range(maxlen):
        for blk in blocks:
          if i < len(blk):
            micro.append(blk[i])
    else:
      maxlen = max(len(b) for b in blocks)
      for i in range(maxlen):
        for blk in reversed(blocks):
          if i < len(blk):
            micro.append(blk[i])

    # connectors at delta2 scale
    s0, s1, s2, s3 = spine_starts
    connectors = [
      ((s0 - 1) * delta2 + glo, (s1 - 1) * delta2 + glo),
      ((s2 + 2) * delta2 + glo, (s3 + 2) * delta2 + glo),
      ((s0 + 2) * delta2 + glo, (s2 - 1) * delta2 + glo),
      ((s1 + 2) * delta2 + glo, (s3 - 1) * delta2 + glo),
      ((s0 + 3) * delta2 + glo, (s3 + 3) * delta2 + glo),
    ]
    micro.extend(connectors)

    cap1 = (glo + (delta2 // 4), glo + int(1.8 * delta2))
    cap2 = (glo + int(0.9 * delta2), glo + int(2.6 * delta2))
    mid = glo + G // 2
    cap3 = (mid - max(1, delta2 // 8), mid + max(1, delta2 // 8))
    for cap in (cap1, cap2, cap3):
      if cap[1] > cap[0]:
        micro.append(cap)

    if len(micro) > budget:
      micro = micro[:budget]
    return micro

  remaining = CAP - len(T)
  mr1 = micro_round(T, round_id=0, budget=max(0, remaining // 2))
  if mr1:
    room = CAP - len(T)
    if len(mr1) > room:
      mr1 = mr1[:room]
    T.extend(mr1)

  remaining = CAP - len(T)
  mr2 = micro_round(T, round_id=1, budget=max(0, remaining))
  if mr2:
    room = CAP - len(T)
    if len(mr2) > room:
      mr2 = mr2[:room]
    T.extend(mr2)

  # Optional parabolic micro-phase for extra diversity (lightweight)
  if enable_parabolic:
    room = CAP - len(T)
    if room > 0:
      lo = min(l for l, r in T)
      hi = max(r for l, r in T)
      delta = hi - lo if hi > lo else 1
      cap1 = (lo + max(1, int(round(0.15 * delta))), lo + max(1, int(round(0.60 * delta))))
      cap2 = (lo + max(1, int(round(0.25 * delta))), lo + max(1, int(round(0.80 * delta))))
      cap3 = (lo + max(1, int(round(0.55 * delta))), lo + max(1, int(round(0.95 * delta))))
      parabolic = [cap for cap in (cap1, cap2, cap3) if cap[1] > cap[0]]
      if parabolic:
        if len(parabolic) > room:
          parabolic = parabolic[:room]
        T.extend(parabolic)

  # Final return
  return T

# EVOLVE-BLOCK-END
=======
# EVOLVE-BLOCK-START

def _span_delta(T):
  lo = min(l for l, _ in T)
  hi = max(r for _, r in T)
  delta = hi - lo
  if delta <= 0:
    delta = 1
  return lo, hi, delta

def _build_blocks_sequential(T, starts, delta, lo, K=1):
  """
  Build four translated blocks sequentially. No interleaving. This ordering
  is known to amplify FirstFit color pressure. K is a tunable spacing multiplier (default 1).
  """
  S = []
  for s in starts:
    base = s * delta * K - lo
    S.extend((l + base, r + base) for (l, r) in T)
  return S

def _append_connectors(S, starts, delta, add_cross4=False):
  """
  Append the classic four connectors. Optionally add a single long-range cross4
  on the final round to improve pressure while keeping total size under CAP.
  """
  s0, s1, s2, s3 = starts
  S.append(((s0 - 1) * delta, (s1 - 1) * delta))  # left cap
  S.append(((s2 + 2) * delta, (s3 + 2) * delta))  # right cap
  S.append(((s0 + 2) * delta, (s2 - 1) * delta))  # cross 1
  S.append(((s1 + 2) * delta, (s3 - 1) * delta))  # cross 2
  if add_cross4:
    S.append(((s0 + 4) * delta, (s3 + 4) * delta))  # long-range cross (final-round only)

def _append_micro_tail(T, max_extra=8):
  """
  Append a tiny tail of long caps near the end of T. This boosts FF late with minimal
  impact on omega. Caps are inserted near the end (rather than simply appended) to
  intersect many active colors while avoiding a single dense core.
  """
  if not T or max_extra <= 0:
    return T
  lo, hi, delta = _span_delta(T)
  d2 = max(1, delta // 4)
  # Symmetric, sparse long caps
  micro = [
      (lo + 1 * d2, lo + 5 * d2),
      (lo + 3 * d2, lo + 8 * d2),
      (hi - 6 * d2, hi - 2 * d2),
      (hi - 8 * d2, hi - 3 * d2),
  ]
  # Insert near the tail in a staggered fashion
  for i, interval in enumerate(micro[:max_extra]):
    pos = len(T) - (i * 2 + 1)
    if pos < 0:
      T.append(interval)
    else:
      T.insert(pos, interval)
  return T

def construct_intervals(seed_count=1, phase2_iters=2, enable_parabolic=False):
  """
  Construct a sequence of intervals of real line,
  in the order in which they are presented to FirstFit,
  so that it maximizes the number of colors used by FirstFit
  divided by the maximum number of intervals that cover a single point.

  This hybrid combines the six-round KT spine with delta2 micro-rounds
  and an optional parabolic micro-phase for extra FF pressure under control.
  """
  CAP = 9800
  # Small margin to avoid dangerously saturating capacity during micro-phases.
  # This gives micro-phases a meaningful budget to execute without being cut mid-pattern.
  CAP_MARGIN = 64

  # Stage 1: six KT rounds, deterministic spine with classic connectors
  spine_starts = (2, 6, 10, 14)
  T = [(0, 1)]

  def apply_round(current_T, starts, do_interleave=False):
    lo, hi, delta = _span_delta(current_T)
    blocks = []
    for s in starts:
      base = s * delta - lo
      blocks.append([(l + base, r + base) for (l, r) in current_T])

    S = []
    if do_interleave:
      maxlen = max(len(b) for b in blocks)
      for i in range(maxlen):
        for blk in blocks:
          if i < len(blk):
            S.append(blk[i])
    else:
      for blk in blocks:
        S.extend(blk)

    # connectors
    _append_connectors(S, starts, delta, add_cross4=False)
    return S

  for ridx in range(6):
    nxt_size = 4 * len(T) + 4
    if nxt_size > CAP:
      break
    # alternate interleaving pattern to push FF
    T = apply_round(T, spine_starts, do_interleave=(ridx % 2 == 0))

  # If we are near cap (with margin), return baseline to avoid cutting micro-phases short
  if len(T) >= CAP - CAP_MARGIN:
    return T

  # Stage 2: micro delta2 rounds with a thin seed
  def thin_seed(current_T, max_seed):
    n = len(current_T)
    if n == 0 or max_seed <= 0:
      return []
    step = max(1, n // max_seed)
    U = current_T[::step][:max_seed]
    return U

  def micro_round(current_T, round_id, budget, alt=False):
    """
    If alt=False: original micro pattern.
    If alt=True: alternate window placements plus short 'blocker' pins to occupy low-index colors early.
    Both patterns are capacity-guarded and deterministic.
    """
    if budget <= 0 or not current_T:
      return []

    glo = min(l for l, r in current_T)
    ghi = max(r for l, r in current_T)
    G = max(1, ghi - glo)
    # use a slightly smaller local delta to keep windows compact
    delta2 = max(1, G // 3)

    per_block_target = max(8, min(64, budget // 12))
    U = thin_seed(current_T, per_block_target)
    if not U:
      return []

    starts = spine_starts
    blocks = []
    ulo = min(l for l, r in U)

    # window choices differ for alternate pass
    if not alt:
      window_fracs = [(0.12, 0.22), (0.35, 0.45), (0.58, 0.68), (0.80, 0.90)]
    else:
      window_fracs = [(0.05, 0.15), (0.28, 0.38), (0.60, 0.70), (0.82, 0.92)]

    # Build small blockers for alt pass (short, staggered pins that avoid large cliques)
    blockers = []
    if alt:
      for w_idx, (fa, fb) in enumerate(window_fracs):
        w_lo = glo + int(round(fa * G))
        w_hi = glo + int(round(fb * G))
        width = max(4, w_hi - w_lo)
        pin_len = max(1, width // 8)
        P = max(3, min(10, width // max(1, pin_len)))
        phase = (w_idx % 2) * (pin_len // 2)
        for i in range(P):
          L = w_lo + (i * (width - pin_len)) // max(1, (P - 1)) + phase
          R = min(w_hi, L + pin_len)
          if R > L:
            blockers.append((L, R))

    # Build translated micro-blocks aligned to these windows
    for (fa, fb) in window_fracs:
      win_lo = glo + int(round(fa * G))
      base = win_lo - ulo
      block = [(l + base, r + base) for (l, r) in U]
      # slight internal reversal to break symmetry
      tag = int(round(fa * 100)) // 5
      if (tag + round_id + (1 if alt else 0)) % 2 == 1:
        block = list(reversed(block))
      blocks.append(block)

    # Interleave micro-blocks; alternate order depending on round id
    micro = []
    maxlen = max(len(b) for b in blocks)
    order = list(range(len(blocks)))
    if (round_id + (1 if alt else 0)) % 2 == 1:
      order.reverse()
    for i in range(maxlen):
      for idx in order:
        blk = blocks[idx]
        if i < len(blk):
          micro.append(blk[i])

    # Prepend blockers for alternate pass so they occupy early small colors
    if blockers:
      micro = blockers + micro

    # connectors at delta2 scale (slightly shifted by glo to keep inside global span)
    s0, s1, s2, s3 = spine_starts
    connectors = [
      ((s0 - 1) * delta2 + glo, (s1 - 1) * delta2 + glo),
      ((s2 + 2) * delta2 + glo, (s3 + 2) * delta2 + glo),
      ((s0 + 2) * delta2 + glo, (s2 - 1) * delta2 + glo),
      ((s1 + 2) * delta2 + glo, (s3 - 1) * delta2 + glo),
    ]
    for a, b in connectors:
      if b > a:
        micro.append((a, b))

    # some local caps to tie windows together (delta2-scaled)
    mid = glo + G // 2
    small_caps = [
      (glo + max(1, delta2 // 6), glo + max(1, delta2 // 2)),
      (mid - max(1, delta2 // 8), mid + max(1, delta2 // 8)),
      (ghi - max(1, delta2 // 3), ghi - max(1, delta2 // 6)),
    ]
    for cap in small_caps:
      if cap[1] > cap[0]:
        micro.append(cap)

    if len(micro) > budget:
      micro = micro[:budget]
    return micro

  # First micro pass (primary pattern)
  remaining = CAP - len(T)
  room1 = max(0, remaining // 2)
  mr1 = micro_round(T, round_id=0, budget=room1, alt=False)
  if mr1:
    room = CAP - len(T)
    if len(mr1) > room:
      mr1 = mr1[:room]
    T.extend(mr1)

  # Second micro pass (alternate pattern with blockers) if margin allows
  remaining = CAP - len(T)
  if remaining > CAP_MARGIN:
    mr2 = micro_round(T, round_id=1, budget=max(0, remaining), alt=True)
    if mr2:
      room = CAP - len(T)
      if len(mr2) > room:
        mr2 = mr2[:room]
      T.extend(mr2)

  # Add a few lightweight global cross-connectors to tie distant regions (capacity guarded)
  room = CAP - len(T)
  if room > 0 and T:
    glo = min(l for l, r in T)
    ghi = max(r for l, r in T)
    G = max(1, ghi - glo)
    cross4s = [
      (glo + int(round(0.11 * G)), glo + int(round(0.89 * G))),
      (glo + int(round(0.27 * G)), glo + int(round(0.73 * G))),
      (glo + int(round(0.18 * G)), glo + int(round(0.84 * G))),
    ]
    for a, b in cross4s:
      if room == 0:
        break
      if b > a:
        T.append((a, b))
        room -= 1

  # Small micro-tail caps inserted near the tail to increase late FF pressure
  room = CAP - len(T)
  tail_extra = min(6, room)
  if tail_extra > 0:
    T = _append_micro_tail(T, max_extra=tail_extra)

  # Optional parabolic micro-phase for extra diversity (lightweight)
  if enable_parabolic:
    room = CAP - len(T)
    if room > 0:
      lo = min(l for l, r in T)
      hi = max(r for l, r in T)
      delta = hi - lo if hi > lo else 1
      cap1 = (lo + max(1, int(round(0.15 * delta))), lo + max(1, int(round(0.60 * delta))))
      cap2 = (lo + max(1, int(round(0.25 * delta))), lo + max(1, int(round(0.80 * delta))))
      cap3 = (lo + max(1, int(round(0.55 * delta))), lo + max(1, int(round(0.95 * delta))))
      parabolic = [cap for cap in (cap1, cap2, cap3) if cap[1] > cap[0]]
      if parabolic:
        if len(parabolic) > room:
          parabolic = parabolic[:room]
        T.extend(parabolic)

  # Final return
  return T

# EVOLVE-BLOCK-END
>>>>>>> REPLACE
</DIFF>