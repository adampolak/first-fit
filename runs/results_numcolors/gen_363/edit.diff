--- a/original.py
+++ b/original.py
@@ -1,347 +1,309 @@
 # EVOLVE-BLOCK-START
 
 def construct_intervals(seed_count=1):
   """
-  Construct a sequence of intervals on the real line, in the order presented to FirstFit,
-  engineered to drive up FirstFit's color usage while keeping the maximum clique (omega) <= ~10.
-
-  Interface compatibility:
-    - Accepts seed_count (unused by evaluator, but supported).
-    - Returns a list of (l, r) integer tuples with r > l (open intervals).
+  Deterministic CAP-aware six-template backbone with two micro-passes and post-spine connectors.
+  Returns a list of (l, r) integer open intervals, in FF arrival order.
   """
-  CAP = 9800
-
-  # Rotating start templates (Kierstead–Trotter style)
-  template_bank = [
+  CAP = 9800  # strict upper bound
+
+  # Six strong start-template patterns to rotate across spine rounds.
+  TEMPLATE_BANK = [
     (2, 6, 10, 14),  # classic KT
     (1, 5, 9, 13),   # left-shifted
     (3, 7, 11, 15),  # right-shifted
     (4, 8, 12, 16),  # stretched-right
+    (2, 5, 11, 14),  # balanced inward
+    (1, 7, 9, 15),   # mid-stretch
   ]
 
-  # Seed: single unit interval (multi-seed support capped defensively)
+  # Deterministic base seed utilities (no randomness)
+  BASE_SEED = 0xA5F1D3
+  def lcg_next(x):
+    return (x * 1103515245 + 12345) & 0x7FFFFFFF
+
+  # Seed: maintain interface compatibility
   if seed_count <= 1:
     T = [(0, 1)]
   else:
     step = 3
     seeds = min(4, max(1, int(seed_count)))
     T = [(i * step, i * step + 1) for i in range(seeds)]
 
-  def _span_delta(current_T):
-    lo = min(l for l, r in current_T)
-    hi = max(r for l, r in current_T)
-    delta = hi - lo
-    if delta <= 0:
-      delta = 1
-    return lo, hi, delta
-
-  def _append_connectors(S, starts, delta):
-    # Four classic connectors that propagate color pressure without large omega jumps
+  # Utilities
+  def span_delta(seq):
+    lo = min(l for l, r in seq)
+    hi = max(r for l, r in seq)
+    d = hi - lo
+    if d <= 0:
+      d = 1
+    return lo, hi, d
+
+  def predict_next_size(sz):
+    # KT-style recurrence (4 blocks + 4 connectors)
+    return 4 * sz + 4
+
+  def rounds_within_cap(initial_size, max_rounds):
+    sz = initial_size
+    done = 0
+    for _ in range(int(max_rounds)):
+      nxt = predict_next_size(sz)
+      if nxt > CAP:
+        break
+      sz = nxt
+      done += 1
+    return done, sz
+
+  def append_connectors(S, starts, delta, offset=0):
     s0, s1, s2, s3 = starts
-    S.append(((s0 - 1) * delta, (s1 - 1) * delta))  # left cap
-    S.append(((s2 + 2) * delta, (s3 + 2) * delta))  # right cap
-    S.append(((s0 + 2) * delta, (s2 - 1) * delta))  # cross 1
-    S.append(((s1 + 2) * delta, (s3 - 1) * delta))  # cross 2
-
-  def _apply_round(current_T, starts, do_interleave=False, reverse_order=False):
-    lo, hi, delta = _span_delta(current_T)
-
+    S.append((offset + (s0 - 1) * delta, offset + (s1 - 1) * delta))  # left cap
+    S.append((offset + (s2 + 2) * delta, offset + (s3 + 2) * delta))  # right cap
+    S.append((offset + (s0 + 2) * delta, offset + (s2 - 1) * delta))  # cross 1
+    S.append((offset + (s1 + 2) * delta, offset + (s3 - 1) * delta))  # cross 2
+
+  # Deterministic interleaving schedule: even rounds interleave, odd rounds sequential reversed.
+  def apply_spine_round(current_T, starts, interleave, reverse_blocks, density_boost=False, boost_rate=0.08, seed_tag=0):
+    lo, hi, delta = span_delta(current_T)
     # Build four translated blocks
     blocks = []
     for s in starts:
       base = s * delta - lo
       block = [(l + base, r + base) for (l, r) in current_T]
       blocks.append(block)
 
-    # Compose S with chosen policy
+    # Build S
     S = []
-    if do_interleave:
-      order = list(range(4))
-      if reverse_order:
+    if interleave:
+      maxlen = max(len(b) for b in blocks)
+      order = list(range(len(blocks)))
+      if reverse_blocks:
         order.reverse()
-      maxlen = max(len(b) for b in blocks)
       for i in range(maxlen):
         for idx in order:
           blk = blocks[idx]
           if i < len(blk):
             S.append(blk[i])
     else:
-      seq_blocks = list(reversed(blocks)) if reverse_order else blocks
+      seq_blocks = list(reversed(blocks)) if reverse_blocks else blocks
       for blk in seq_blocks:
         S.extend(blk)
 
-    _append_connectors(S, starts, delta)
+    # Per-round modest densification on central subset (CAP-aware)
+    if density_boost and len(S) < CAP:
+      # sample evenly spaced subset and re-embed them slightly left-shifted
+      n = len(S)
+      pick = max(8, min(64, n // 200))
+      stride = max(1, n // max(1, pick))
+      sample = [S[i] for i in range(n // 3, n - n // 3, stride)][:pick]
+      shift = max(1, int(round(boost_rate * delta)))
+      # Alternate direction deterministically by seed_tag
+      shift = -shift if (seed_tag % 2 == 1) else shift
+      densified = []
+      for (l, r) in sample:
+        L = l + shift
+        R = r + shift
+        if R > L:
+          densified.append((L, R))
+      # append densified block, trimming if near CAP
+      free = CAP - len(S)
+      if free > 0 and densified:
+        if len(densified) > free:
+          densified = densified[:free]
+        S.extend(densified)
+
+    # Append connectors at this scale
+    append_connectors(S, starts, delta, offset=0)
     return S
 
-  # Stage 1: Six KT-style rounds with parity-based interleaving
-  for ridx in range(6):
-    starts = template_bank[ridx % len(template_bank)]
-    do_interleave = (ridx % 2 == 0)          # even: interleave
-    reverse_order = (ridx % 2 == 1)          # odd: reverse sequential
-    T = _apply_round(T, starts, do_interleave=do_interleave, reverse_order=reverse_order)
-    if len(T) >= CAP:
-      return T[:CAP]
-
-  # Micro-phase A: a few long caps near the global span to mix late colors
+  # Stage 1: Six-round backbone with six-template rotation and deterministic interleaving
+  max_spine_rounds = 6
+  depth, _ = rounds_within_cap(len(T), max_spine_rounds)
+  seed = BASE_SEED
+  for ridx in range(depth):
+    starts = TEMPLATE_BANK[ridx % len(TEMPLATE_BANK)]
+    interleave = (ridx % 2 == 0)
+    reverse_blocks = (ridx % 2 == 1)
+    density_boost = (ridx >= 1)  # enable from round 2 onwards
+    T = apply_spine_round(T, starts, interleave, reverse_blocks, density_boost=density_boost, boost_rate=0.08, seed_tag=(seed ^ ridx))
+    seed = lcg_next(seed)
+    if len(T) >= CAP - 32:
+      break
+
+  # Stage 1.5: Post-spine deterministic long-range connectors (gate by CAP)
   if len(T) < CAP - 8:
-    lo, hi, delta = _span_delta(T)
-    def cap_at(a_frac, b_frac):
-      L = lo + max(1, int(round(a_frac * delta)))
-      R = lo + max(1, int(round(b_frac * delta)))
-      if R <= L:
-        R = L + 1
-      return (L, R)
-    caps = [cap_at(0.08, 0.60), cap_at(0.25, 0.75), cap_at(0.75, 0.92)]
+    lo, hi, delta = span_delta(T)
+    G = max(1, hi - lo)
+    # 4–6 connectors spanning different fractions; avoid edges to bound omega
+    LR = [
+      (lo + int(0.07 * G), lo + int(0.29 * G)),
+      (lo + int(0.21 * G), lo + int(0.51 * G)),
+      (lo + int(0.49 * G), lo + int(0.79 * G)),
+      (lo + int(0.68 * G), lo + int(0.91 * G)),
+      (lo + int(0.13 * G), lo + int(0.87 * G)),  # one long cross
+    ]
+    # Insert near tail to maximize interaction with many active colors
     room = CAP - len(T)
     if room > 0:
-      caps = caps[:room]
-      # Insert near the tail to avoid disrupting early structure
-      for i, iv in enumerate(caps):
-        pos = len(T) - (i * 2 + 1)
+      add = LR[:min(len(LR), room)]
+      for i, iv in enumerate(add):
+        pos = len(T) - (i * 3 + 1)
         if pos < 0:
           T.append(iv)
         else:
           T.insert(pos, iv)
 
-  if len(T) >= CAP - 16:
-    return T[:CAP]
-
-  # Helper: thin evenly-spaced seed from T
-  def _thin_seed(current_T, max_seed):
+  if len(T) >= CAP - 8:
+    return _normalize_and_trim(T, CAP)
+
+  # Helper: thin seed
+  def thin_seed(current_T, max_seed):
     n = len(current_T)
-    if n == 0 or max_seed <= 0:
+    if n <= 0 or max_seed <= 0:
       return []
     step = max(1, n // max_seed)
     return current_T[::step][:max_seed]
 
-  # Stage 2: delta2-driven micro rounds using thin evenly-spaced seeds
-  def _build_micro_delta_round(current_T, budget, iter_id=0, alt=False):
-    if not current_T or budget <= 8:
+  # Micro builder (window family, deterministic shifts)
+  def build_micro(current_T, budget, iter_id, family_id):
+    if budget <= 8 or not current_T:
       return []
-
-    glo = min(l for l, r in current_T)
-    ghi = max(r for l, r in current_T)
-    G = max(1, ghi - glo)
-
-    # Thin seed (slightly larger for alt to strengthen mixing)
-    base_seed = max(8, min(32, len(current_T) // 300))
-    seed_sz = base_seed if not alt else max(8, min(40, len(current_T) // 250))
-    U = _thin_seed(current_T, seed_sz)
+    glo, ghi, G = span_delta(current_T)
+
+    # seed selection tied to family_id
+    seed_sz = max(12, min(40, len(current_T) // (250 if family_id == 1 else 300)))
+    U = thin_seed(current_T, seed_sz)
     if not U:
       return []
-
     ulo = min(l for l, r in U)
 
-    # Windows with small shifts on primary; distinct family on alt
-    if not alt:
-      shift = (iter_id % 3) * 0.02
-      window_fracs = [
+    # Window families A and B with small deterministic shifts
+    if family_id == 0:
+      shift = ((iter_id + 1) % 3) * 0.015
+      windows = [
         (0.12 + shift, 0.22 + shift),
-        (0.35 + shift, 0.45 + shift),
-        (0.58 + shift, 0.68 + shift),
-        (0.80 + shift, 0.90 + shift),
+        (0.34 + shift, 0.44 + shift),
+        (0.56 + shift, 0.66 + shift),
+        (0.78 + shift, 0.88 + shift),
       ]
-      window_fracs = [(max(0.05, min(0.90, a)), max(0.10, min(0.95, b))) for (a, b) in window_fracs]
     else:
-      window_fracs = [(0.05, 0.15), (0.28, 0.38), (0.60, 0.70), (0.82, 0.92)]
-
+      windows = [
+        (0.08, 0.18),
+        (0.28, 0.38),
+        (0.60, 0.70),
+        (0.82, 0.92),
+      ]
+    # clamp
+    wf = []
+    for a, b in windows:
+      a = max(0.05, min(0.93, a))
+      b = max(a + 0.01, min(0.95, b))
+      wf.append((a, b))
+
+    # Create translated micro-blocks
     blocks = []
-    for (fa, fb) in window_fracs:
+    for (fa, fb) in wf:
       win_lo = glo + int(round(fa * G))
       base = win_lo - ulo
       block = [(l + base, r + base) for (l, r) in U]
-      tag = iter_id if not alt else (iter_id + 1)
-      # Parity-breaking reversal to reduce symmetry
-      if ((int(round(fa * 100)) // 5) + tag) % 2 == 1:
+      # symmetry-breaking reversal by parity
+      if ((int(round(fa * 100)) // 5) + iter_id + family_id) % 2 == 1:
         block = list(reversed(block))
       blocks.append(block)
 
-    # Interleave policy depends on tag parity
+    # Interleave blocks in deterministic order
     micro = []
-    tag = iter_id if not alt else (iter_id + 1)
+    maxlen = max(len(b) for b in blocks) if blocks else 0
     order = list(range(len(blocks)))
-    if tag % 2 == 1:
+    if (iter_id + family_id) % 2 == 1:
       order.reverse()
-    maxlen = max(len(b) for b in blocks)
     for i in range(maxlen):
       for idx in order:
         blk = blocks[idx]
         if i < len(blk):
           micro.append(blk[i])
 
-    # Fractional-span connectors (KT analog) + long-range cross on alt
-    micro_connectors = [
-      (glo + int(round(0.08 * G)), glo + int(round(0.30 * G))),
-      (glo + int(round(0.60 * G)), glo + int(round(0.92 * G))),
-      (glo + int(round(0.26 * G)), glo + int(round(0.56 * G))),
+    # Add fractional-span connectors for micro-level coupling
+    connectors = [
+      (glo + int(round(0.09 * G)), glo + int(round(0.30 * G))),
+      (glo + int(round(0.28 * G)), glo + int(round(0.56 * G))),
       (glo + int(round(0.44 * G)), glo + int(round(0.78 * G))),
+      (glo + int(round(0.62 * G)), glo + int(round(0.90 * G))),
     ]
-    if alt:
-      micro_connectors.append((glo + int(round(0.18 * G)), glo + int(round(0.84 * G))))
-    for a, b in micro_connectors:
+    if family_id == 1:
+      connectors.append((glo + int(round(0.18 * G)), glo + int(round(0.84 * G))))
+    for a, b in connectors:
       if b > a:
         micro.append((a, b))
 
+    # Trim to budget
     if len(micro) > budget:
       micro = micro[:budget]
     return micro
 
-  # Execute two primary micro rounds, then one alt round (capacity-guarded)
-  for iter_id in range(2):
+  # Stage 2: Two deterministic micro passes with separate window families
+  remaining = CAP - len(T)
+  if remaining > 12:
+    # Pass A
+    budgetA = max(8, remaining // 3)
+    microA = build_micro(T, budgetA, iter_id=0, family_id=0)
+    if microA:
+      free = CAP - len(T)
+      if len(microA) > free:
+        microA = microA[:free]
+      T.extend(microA)
+
+  remaining = CAP - len(T)
+  if remaining > 12:
+    # Pass B
+    budgetB = max(8, remaining // 2)
+    microB = build_micro(T, budgetB, iter_id=1, family_id=1)
+    if microB:
+      free = CAP - len(T)
+      if len(microB) > free:
+        microB = microB[:free]
+      T.extend(microB)
+
+  # Final deterministic interleaved tail caps to tie distant regions lightly
+  if len(T) < CAP:
+    lo, hi, d = span_delta(T)
+    d2 = max(1, d // 4)
+    tail = [
+      (lo + d2, lo + 3 * d2),
+      (lo + int(0.35 * d), lo + int(0.72 * d)),
+      (hi - 3 * d2, hi - d2),
+    ]
     room = CAP - len(T)
-    if room <= 8:
-      break
-    micro = _build_micro_delta_round(T, room, iter_id=iter_id, alt=False)
-    if not micro:
-      break
-    if len(micro) > room:
-      micro = micro[:room]
-    T.extend(micro)
-
-  room = CAP - len(T)
-  if room > 8:
-    micro_alt = _build_micro_delta_round(T, room, iter_id=2, alt=True)
-    if micro_alt:
-      avail = CAP - len(T)
-      if len(micro_alt) > avail:
-        micro_alt = micro_alt[:avail]
-      T.extend(micro_alt)
-
-  # Stage 3: pin-shrinking micro-phase (controls omega via short intervals)
-  if len(T) < CAP - 8:
-    glo2 = min(l for l, r in T)
-    ghi2 = max(r for l, r in T)
-    G2 = max(1, ghi2 - glo2)
-    seed_sz2 = max(8, min(24, len(T) // 400))
-    U2 = _thin_seed(T, seed_sz2)
-    if U2:
-      ulo2 = min(l for l, r in U2)
-      eps = max(1, G2 // 512)
-      windows2 = [(0.05, 0.15), (0.28, 0.38), (0.60, 0.70), (0.82, 0.92)]
-      blocks2 = []
-      for (fa, fb) in windows2:
-        win_lo2 = glo2 + int(round(fa * G2))
-        base2 = win_lo2 - ulo2
-        block = []
-        for idx, (l, r) in enumerate(U2):
-          mid = (l + r) // 2
-          L = mid + base2 - (eps // 2) + (idx % 3)
-          R = L + eps
-          if R > L:
-            block.append((L, R))
-        blocks2.append(block)
-
-      micro2 = []
-      if blocks2:
-        maxlen2 = max(len(b) for b in blocks2)
-        order2 = [3, 1, 0, 2]
-        for i in range(maxlen2):
-          for idx in order2:
-            blk = blocks2[idx]
-            if i < len(blk):
-              micro2.append(blk[i])
-
-      # Two short cap-pins to tie windows without inflating omega
-      caps2 = [
-        (glo2 + int(round(0.09 * G2)), glo2 + int(round(0.09 * G2)) + eps),
-        (glo2 + int(round(0.64 * G2)), glo2 + int(round(0.64 * G2)) + eps),
-      ]
-      for a, b in caps2:
-        if b > a:
-          micro2.append((a, b))
-
-      room2 = CAP - len(T)
-      if room2 > 0:
-        if len(micro2) > room2:
-          micro2 = micro2[:room2]
-        T.extend(micro2)
-
-  # Stage 4 (new): tower-and-cap micro-phase
-  # Build staggered short towers across five separated windows, then add a few long caps
-  # that each overlap one level from every tower. At any point, only a local tower pin
-  # is active with the cap, mitigating omega growth.
-  if len(T) < CAP - 12:
-    glo3 = min(l for l, r in T)
-    ghi3 = max(r for l, r in T)
-    G3 = max(1, ghi3 - glo3)
-
-    # Thin seed for pin positioning (moderate size)
-    U3 = _thin_seed(T, max(12, min(36, len(T) // 300)))
-    if U3:
-      ulo3 = min(l for l, r in U3)
-      eps3 = max(1, G3 // 768)  # very short pins
-
-      # Five windows for five towers; each builds 3 staggered pin levels
-      towers = [(0.10, 0.18), (0.28, 0.36), (0.46, 0.54), (0.64, 0.72), (0.82, 0.90)]
-      levels = 3
-      tower_blocks = []
-      for t_idx, (fa, fb) in enumerate(towers):
-        win_lo3 = glo3 + int(round(fa * G3))
-        base3 = win_lo3 - ulo3
-        block = []
-        for idx, (l, r) in enumerate(U3):
-          mid = (l + r) // 2
-          # three levels staggered slightly to avoid co-location
-          for lv in range(levels):
-            jitter = (idx + lv + t_idx) % 4
-            L = mid + base3 - (eps3 // 2) + jitter + lv  # increasing shift by level
-            R = L + eps3
-            if R > L:
-              block.append((L, R))
-        tower_blocks.append(block)
-
-      # Interleave towers round-robin to distribute local density
-      tower_phase = []
-      if tower_blocks:
-        maxlen3 = max(len(b) for b in tower_blocks)
-        order3 = [0, 2, 4, 1, 3]
-        for i in range(maxlen3):
-          for idx in order3:
-            blk = tower_blocks[idx]
-            if i < len(blk):
-              tower_phase.append(blk[i])
-
-      # Add a few long caps that span across the tower windows but avoid edges
-      caps3 = [
-        (glo3 + int(round(0.15 * G3)), glo3 + int(round(0.45 * G3))),
-        (glo3 + int(round(0.38 * G3)), glo3 + int(round(0.70 * G3))),
-        (glo3 + int(round(0.60 * G3)), glo3 + int(round(0.88 * G3))),
-      ]
-      for a, b in caps3:
-        if b > a:
-          tower_phase.append((a, b))
-
-      room3 = CAP - len(T)
-      if room3 > 0 and tower_phase:
-        if len(tower_phase) > room3:
-          tower_phase = tower_phase[:room3]
-        T.extend(tower_phase)
-
-  # Final capacity guard
-  if len(T) > CAP:
-    T = T[:CAP]
-
-  # Normalize and ensure integer endpoints with r > l
+    add = tail[:room]
+    for i, iv in enumerate(add):
+      pos = len(T) - (2 * i + 1)
+      if pos < 0:
+        T.append(iv)
+      else:
+        T.insert(pos, iv)
+
+  return _normalize_and_trim(T, CAP)
+
+
+def _normalize_and_trim(T, CAP):
+  # Normalize to non-negative integers and ensure r > l
   if not T:
     return []
   min_l = min(l for l, r in T)
   if min_l < 0:
     T = [(l - min_l, r - min_l) for (l, r) in T]
-
-  intervals = []
+  out = []
   for (l, r) in T:
     li = int(l)
     ri = int(r)
     if ri <= li:
       ri = li + 1
-    intervals.append((li, ri))
-
-  if len(intervals) > CAP:
-    intervals = intervals[:CAP]
-  return intervals
+    out.append((li, ri))
+  if len(out) > CAP:
+    out = out[:CAP]
+  return out
 
 # EVOLVE-BLOCK-END
 
 def run_experiment(**kwargs):
   """Main called by evaluator"""
   return construct_intervals()