<DIFF>
<<<<<<< SEARCH
  # Stage 1: KT spine with rotation and parity policies, capacity-guarded
  for ridx in range(8):
    # Predict next size: sz -> 4*sz + 4
    if 4 * len(T) + 4 > CAP:
      break
    starts = template_bank[ridx % len(template_bank)]
    # Always interleave to maximize mixing; vary reverse order every third round
    do_inter = True
    rev = (ridx % 3 == 0)
    T = _apply_round(T, starts, do_interleave=do_inter, reverse_order=rev)
    # Spine-density boost: duplicate a small fraction of intervals shrunk slightly to increase FF pressure
    if len(T) < CAP:
      lo_s, hi_s, span_s = _span(T)
      eps = max(1, span_s // 1000)
      # boost up to 10 intervals or 20% of current T, staying within capacity
      boost = min(10, CAP - len(T), len(T) // 5)
      for (l_s, r_s) in T[:boost]:
        if r_s - l_s > 2 * eps:
          T.append((l_s + eps, r_s - eps))
=======
  # Stage 1: KT spine with rotation and parity policies, capacity-guarded
  for ridx in range(12):
    # Predict next size: sz -> 4*sz + 4
    if 4 * len(T) + 4 > CAP:
      break
    starts = template_bank[ridx % len(template_bank)]
    # Always interleave to maximize mixing; vary reverse order every third round
    do_inter = True
    rev = (ridx % 3 == 0)
    T = _apply_round(T, starts, do_interleave=do_inter, reverse_order=rev)
    # Spine-density boost: duplicate a small fraction of intervals shrunk slightly to increase FF pressure
    if len(T) < CAP:
      lo_s, hi_s, span_s = _span(T)
      eps = max(1, span_s // 1000)
      # boost up to 10 intervals or 20% of current T, staying within capacity
      boost = min(20, CAP - len(T), len(T) // 5)
      for (l_s, r_s) in T[:boost]:
        if r_s - l_s > 2 * eps:
          T.append((l_s + eps, r_s - eps))
>>>>>>> REPLACE
</DIFF>