<NAME>
rotating_3start_towers_and_trimmed_finephase
</NAME>

<DESCRIPTION>
I propose three coordinated changes to increase FirstFit pressure while reducing interval bloat and keeping omega modest.

1) Rotate over 3-start patterns instead of 4-start patterns and tune knobs:
- Switch the start pattern cycle to three-start patterns (e.g., (2,6,10), (1,5,9), (3,7,11), (4,8,12)). This reduces the per-round clone factor while still coupling across blocks, often improving FF pressure per interval.
- Trim the fine-scale phase rounds from 2 to 1 and reduce caps per round. Increase micro-gadget scale slightly (0.18) to make the few micro-insertions more influential. These changes aim to improve the combined score by decreasing the overall interval count while maintaining or improving the competitive ratio.

2) Add “tower” layers per block:
- Introduce a small set of staggered tower intervals that span approximately two blocks with offsets across layers. Towers promote cross-block color coupling and hinder early color reuse by FirstFit while keeping the clique number controlled because layers are staggered and spans avoid creating a single large point of overlap.

3) Trim and refocus the fine-scale phase:
- Use a single 3-start fine-phase pattern (1,4,7), drop the extra templates and micro-caps, and add one cap-coupler interval spanning from the interior of the first to the last fine-scale block. This keeps the second phase lightweight but effective at knitting colors across scales.

Together these changes leverage known heuristics: a low-omega “spine” of long intervals plus carefully crafted waves and caps that force upward FirstFit usage without inflating omega or interval count.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    phase2_rounds = 2           # small-scale refinement rounds after main rounds
    bridge_fraction = 0.5       # fraction used to place light bridges between blocks
    caps_per_round = 3          # small caps added each round (keeps omega low)
    micro_scale = 0.12          # micro-gadget scale relative to delta
=======
    phase2_rounds = 1           # trim fine phase to reduce bloat, keep coupling
    bridge_fraction = 0.5       # fraction used to place light bridges between blocks
    caps_per_round = 2          # fewer caps, rely on towers for coupling
    micro_scale = 0.18          # slightly larger micro-gadget for stronger pressure
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
    # Rotating 4-cycle of start patterns (each has 4 starts -> branching factor 4)
    start_patterns = [
        (2, 6, 10, 14),
        (1, 5, 9, 13),
        (3, 7, 11, 15),
        (2, 4, 8, 12),
    ]
=======
    # Rotating cycle of 3-start patterns (reduced branching, better density control)
    start_patterns = [
        (2, 6, 10),
        (1, 5, 9),
        (3, 7, 11),
        (4, 8, 12),
    ]
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
        # add a micro-gadget in the middle block to create fine-grained pressure
        mid_start = block_order[len(block_order) // 2]
        for (a, b) in template:
            # micro scaled copy inserted inside the mid block (small-scale)
            S.append((delta * (mid_start + micro_scale * a),
                      delta * (mid_start + micro_scale * b)))
=======
        # add a micro-gadget in the middle block to create fine-grained pressure
        mid_start = block_order[len(block_order) // 2]
        for (a, b) in template:
            # micro scaled copy inserted inside the mid block (small-scale)
            S.append((delta * (mid_start + micro_scale * a),
                      delta * (mid_start + micro_scale * b)))

        # Add a small tower: 3 staggered layers spanning about two blocks.
        # Towers couple colors across adjacent blocks without creating large cliques.
        tower_layers = 3
        layer_shift = 0.55  # offset within block
        span_blocks = 1.9   # span slightly less than 2 blocks to avoid single-point cliques
        for bi, st in enumerate(block_order[:-1]):  # tie current to next
            for layer in range(tower_layers):
                off = layer * (layer_shift / max(1, tower_layers - 1))
                t_lo = delta * (st + 0.2 + off)
                t_hi = delta * (st + span_blocks + 0.2 + off)
                if t_hi > t_lo:
                    S.append((t_lo, t_hi))
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
    fine_starts_cycle = [
        (1, 3, 5, 7),
        (2, 5, 8, 11)
    ]
=======
    fine_starts_cycle = [
        (1, 4, 7),
    ]
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
            # tiny bridge inside fine-scale
            if bi + 1 < len(starts):
                nxt = starts[bi + 1]
                b_lo = delta2 * (st + 0.3)
                b_hi = b_lo + max(0.04 * delta2, 0.2)
                S.append((b_lo, b_hi))

        # add a tiny template (choose from bank, scaled down)
        template = template_bank[(it + p) % len(template_bank)]
        for (a, b) in template:
            S.append((delta2 * a, delta2 * b))

        # micro caps
        for k in range(2):
            c_lo = delta2 * (starts[0] + 0.2 + k * 0.7)
            c_hi = c_lo + max(0.03 * delta2, 0.15)
            S.append((c_lo, c_hi))
=======
            # tiny bridge inside fine-scale
            if bi + 1 < len(starts):
                nxt = starts[bi + 1]
                b_lo = delta2 * (st + 0.35)
                b_hi = b_lo + max(0.05 * delta2, 0.25)
                S.append((b_lo, b_hi))

        # Single cap-coupler across the fine-scale span to tie ends together
        S.append((delta2 * (starts[0] + 0.4), delta2 * (starts[-1] - 0.4)))
>>>>>>> REPLACE

</DIFF>