<NAME>
spine_seq_no_micro
</NAME>

<DESCRIPTION>
I remove both micro-phases (which were inflating the clique to 10 in practice) and switch the main spine presentation to be strictly sequential with per-block parity reversal. This follows the classical KT adversary more closely and tends to keep omega at 9 while still sustaining high FirstFit pressure. I also fix the spine starts to the classic template [2, 6, 10, 14] to stabilize the clique growth across rounds. Together, these changes are designed to push the ratio back up to around 21/9 â‰ˆ 2.33 or better, improving upon the current 2.30 result.

Key changes:
- Always present blocks sequentially and reverse every other block to disrupt color reuse without increasing omega.
- Fix the start pattern to the classic (2,6,10,14) for all rounds to keep the maximum clique smaller.
- Disable micro-phase A and B entirely to avoid extra overlaps that were raising omega to 10 with limited gains for FF.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    starts = template_bank[round_idx % 4]
=======
    # Fix to the classic KT starts to stabilize omega while preserving FF pressure
    starts = template_bank[0]
>>>>>>> REPLACE

<<<<<<< SEARCH
    S = []
    # interleave blocks on even rounds, sequential on odd rounds
    if round_idx % 2 == 0:
      maxlen = max(len(b) for b in blocks)
      for i in range(maxlen):
        for blk in blocks:
          if i < len(blk):
            S.append(blk[i])
    else:
      for blk in blocks:
        S.extend(blk)
=======
    # Always present blocks sequentially; reverse every other block to increase FF pressure
    S = []
    for bidx, blk in enumerate(blocks):
      if bidx % 2 == 1:
        blk = list(reversed(blk))
      S.extend(blk)
>>>>>>> REPLACE

<<<<<<< SEARCH
  # Micro-phase A: add three long-range caps to boost late FirstFit color usage while controlling omega
  lo = min(l for l, r in T)
  hi = max(r for l, r in T)
  delta = hi - lo if hi > lo else 1
  def cap_at(a_frac, b_frac):
    l0 = lo + max(1, int(round(a_frac * delta)))
    r0 = lo + max(1, int(round(b_frac * delta)))
    return (l0, r0)
  capA = cap_at(0.08, 0.60)
  capB = cap_at(0.25, 0.75)
  capC = cap_at(0.75, 0.92)
  for cap in (capA, capB, capC):
    if cap[1] > cap[0]:
      T.append(cap)

  # Micro-phase B: a thin delta2 micro-round (capacity-guarded) to increase FF colors without raising omega much
  if len(T) < CAP - 16:
    glo = min(l for l, r in T)
    ghi = max(r for l, r in T)
    G = ghi - glo if ghi > glo else 1

    # Thin seed of current T (small and evenly spaced)
    seed_sz = max(8, min(32, len(T) // 300))
    stride = max(1, len(T) // max(1, seed_sz))
    U = [T[i] for i in range(0, len(T), stride)][:seed_sz]

    if U:
      ulo = min(l for l, r in U)

      # Four windows across the global span (stay inside to avoid omega spikes)
      window_fracs = [(0.12, 0.22), (0.35, 0.45), (0.58, 0.68), (0.80, 0.90)]
      micro_blocks = []
      for (fa, fb) in window_fracs:
        win_lo = glo + int(round(fa * G))
        base = win_lo - ulo
        block = [(l + base, r + base) for (l, r) in U]
        micro_blocks.append(block)

      # Interleave the micro-blocks
      micro = []
      maxlen = max(len(b) for b in micro_blocks)
      for i in range(maxlen):
        for blk in micro_blocks:
          if i < len(blk):
            micro.append(blk[i])

      # Fractional-span connectors at the delta2 scale
      micro_connectors = [
        (glo + int(round(0.08 * G)), glo + int(round(0.30 * G))),
        (glo + int(round(0.60 * G)), glo + int(round(0.92 * G))),
        (glo + int(round(0.26 * G)), glo + int(round(0.56 * G))),
        (glo + int(round(0.44 * G)), glo + int(round(0.78 * G))),
      ]
      for a, b in micro_connectors:
        if b > a:
          micro.append((a, b))

      # Capacity guard
      room = CAP - len(T)
      if room > 0:
        if len(micro) > room:
          micro = micro[:room]
        T.extend(micro)

  return T
=======
  # Micro phases disabled to preserve low clique number and improve FF/OPT ratio
  return T
>>>>>>> REPLACE

</DIFF>