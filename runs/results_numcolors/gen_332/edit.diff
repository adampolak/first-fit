--- a/original.py
+++ b/original.py
@@ -1,256 +1,347 @@
 # EVOLVE-BLOCK-START
 
 def construct_intervals(seed_count=1):
   """
-  Construct a sequence of intervals on the real line, in the order presented to FirstFit,
-  to maximize FF colors divided by the clique number (omega).
+  Enhanced deterministic spine + adaptive micro-phases generator.
 
   Interface preserved: construct_intervals(seed_count=1) -> list[(l, r)]
   """
 
-  # Capacity guard to keep total intervals < 10000
+  # Capacity guard (strict)
   CAP = 9800
 
-  # Four strong KT start templates (empirically best)
+  # Expanded deterministic six-template bank (diverse relative offsets)
   TEMPLATE_BANK = [
     (2, 6, 10, 14),  # classic KT
-    (1, 5, 9, 13),   # left-shifted
-    (3, 7, 11, 15),  # right-shifted
+    (1, 5, 9, 13),   # left shift
+    (3, 7, 11, 15),  # right shift
     (4, 8, 12, 16),  # stretched-right
+    (2, 5, 8, 11),   # compressed stepping
+    (3, 6, 9, 12),   # alternate compressed
   ]
 
-  # Seed with a single unit interval; multi-seed tends to inflate omega too early
-  T = [(0, 1)]
+  # Deterministic interleave-round pattern (apply interleaving on these indices)
+  INTERLEAVE_PATTERN = {1, 2, 4}  # interleave on rounds 1,2,4 (0-based indexing)
+
+  # Seed: single unit interval to avoid early omega inflation.
+  T = [(0, 1)] if seed_count <= 1 else [(0, 1)]
 
   # ---------- Helpers ----------
   def _span_delta(current_T):
+    # Single pass min/max for speed and robustness
+    if not current_T:
+      return 0, 0, 1
     lo = current_T[0][0]
     hi = current_T[0][1]
-    # Single pass for speed
     for l, r in current_T:
       if l < lo: lo = l
       if r > hi: hi = r
     delta = hi - lo
     if delta <= 0:
       delta = 1
     return lo, hi, delta
 
   def _rebase_to_zero(current_T):
     if not current_T:
       return current_T
     lo, _, _ = _span_delta(current_T)
     if lo == 0:
       return current_T
-    # Affine shift that preserves all intersections/order
     return [(l - lo, r - lo) for (l, r) in current_T]
 
   def _append_connectors(S, starts, delta):
-    # Classic four connectors; preserves strong FF pressure with modest omega.
+    # Classic four connectors kept plus modest long-range connector candidate
     s0, s1, s2, s3 = starts
     S.append(((s0 - 1) * delta, (s1 - 1) * delta))  # left cap
     S.append(((s2 + 2) * delta, (s3 + 2) * delta))  # right cap
     S.append(((s0 + 2) * delta, (s2 - 1) * delta))  # cross 1
     S.append(((s1 + 2) * delta, (s3 - 1) * delta))  # cross 2
 
-  def _apply_round(current_T, starts, do_interleave=False, reverse_order=False):
+  def _cap_at(lo, span, a_frac, b_frac):
+    L = lo + max(1, int(round(a_frac * span)))
+    R = lo + max(1, int(round(b_frac * span)))
+    if R <= L:
+      R = L + 1
+    return (L, R)
+
+  def _apply_round(current_T, starts, do_interleave=False, reverse_order=False, density_mult=1.0):
     lo, hi, delta = _span_delta(current_T)
 
-    # Build four translated blocks
-    # Use list comprehension for speed
+    # Build translated blocks
     base_vals = [s * delta - lo for s in starts]
     blocks = [[(l + base, r + base) for (l, r) in current_T] for base in base_vals]
 
-    # Assemble with optional interleaving and reverse order to mix colors
+    # Assemble sequence S either interleaving or sequential
     S = []
     if do_interleave:
-      order = [0, 1, 2, 3]
+      order = list(range(4))
       if reverse_order:
         order.reverse()
       maxlen = max(len(b) for b in blocks)
       for i in range(maxlen):
         for idx in order:
           blk = blocks[idx]
           if i < len(blk):
             S.append(blk[i])
     else:
       if reverse_order:
         blocks = list(reversed(blocks))
       for blk in blocks:
         S.extend(blk)
 
-    # Append classic connectors
+    # Append connectors
     _append_connectors(S, starts, delta)
+
+    # CAP-aware density multiplier:
+    # If density_mult > 1.0, duplicate a tiny deterministic sample of S (spread by small offsets)
+    # but do not exceed CAP and do not grow clique significantly (use tiny offsets inside delta).
+    if density_mult > 1.001 and len(S) < CAP:
+      # Choose deterministic sample size proportional to S and density multiplier
+      extra_budget = int(max(1, min(CAP - len(S), int((density_mult - 1.0) * len(S) / 2))))
+      # Select every k-th element deterministically
+      if extra_budget > 0 and len(S) > 0:
+        step = max(1, len(S) // extra_budget)
+        # small offset fraction to avoid making intervals identical and avoid large cliques
+        offset = max(1, delta // 100)  # at least 1
+        # Insert duplicates near the middle to pressure FF where many colors are active
+        mid = len(S) // 2
+        inserts = []
+        for i in range(0, len(S), step):
+          if len(inserts) >= extra_budget:
+            break
+          l, r = S[i]
+          # Shift by a deterministic sign pattern to spread but keep intersections similar
+          sign = 1 if ((i // step) % 2 == 0) else -1
+          nl = l + sign * offset
+          nr = r + sign * offset
+          if nr <= nl:
+            nr = nl + 1
+          inserts.append((nl, nr))
+        # Insert near mid as alternating insertions to maximize overlap with active colors
+        pos = max(0, mid - len(inserts) // 2)
+        for j, iv in enumerate(inserts):
+          if len(S) >= CAP:
+            break
+          S.insert(min(len(S), pos + 2 * j), iv)
+
     return S
 
-  def _cap_at(lo, span, a_frac, b_frac):
-    L = lo + max(1, int(round(a_frac * span)))
-    R = lo + max(1, int(round(b_frac * span)))
-    if R <= L:
-      R = L + 1
-    return (L, R)
-
-  # Predictive cap-aware number of KT rounds: n -> 4n + 4 per round
+  # Predictive cap-aware number of rounds (4n + 4 growth)
   def _max_rounds_within_cap(initial_size, max_rounds):
     sz = initial_size
     done = 0
     for _ in range(max(0, int(max_rounds))):
       nxt = 4 * sz + 4
       if nxt > CAP:
         break
       sz = nxt
       done += 1
     return done
 
-  # ---------- Stage 1: KT spine with rotation and parity policies ----------
+  # ---------- Stage 1: KT-style spine with six-template rotation ----------
   target_rounds = _max_rounds_within_cap(len(T), 6)
+  # Use a slight adaptive density multiplier schedule per round (bounded)
+  density_schedule = [1.00, 1.06, 1.04, 1.08, 1.03, 1.05]  # deterministic multipliers
+
   for ridx in range(target_rounds):
-    # Rotate starts deterministically
     starts = TEMPLATE_BANK[ridx % len(TEMPLATE_BANK)]
-    # Interleave on even rounds; reverse block order on odd rounds
-    do_inter = (ridx % 2 == 0)
+    # Deterministic interleaving rule from pattern
+    do_inter = (ridx in INTERLEAVE_PATTERN)
     rev = (ridx % 2 == 1)
-    T = _apply_round(T, starts, do_interleave=do_inter, reverse_order=rev)
+    # Use density multiplier from schedule (cycle if fewer entries)
+    density_mult = density_schedule[ridx % len(density_schedule)]
+    # Apply round
+    T = _apply_round(T, starts, do_interleave=do_inter, reverse_order=rev, density_mult=density_mult)
+    # Rebase to keep numbers stable
     if len(T) >= CAP:
       T = T[:CAP]
       return T
-    # Keep numbers bounded without changing structure
     T = _rebase_to_zero(T)
 
-  # Early exit if nearly at capacity
-  if len(T) >= CAP - 8:
+  # Early return guard
+  if len(T) >= CAP - 12:
     return T
 
-  # ---------- Micro-phase A: near-tail long caps ----------
+  # ---------- Deterministic long-range connectors appended after spine ----------
   lo, hi, span = _span_delta(T)
-  caps = [
-    _cap_at(lo, span, 0.08, 0.60),
-    _cap_at(lo, span, 0.25, 0.75),
-    _cap_at(lo, span, 0.75, 0.92),
+  # Add a few long connectors that span large fractions of the current span.
+  long_connectors = [
+    _cap_at(lo, span, 0.02, 0.95),
+    _cap_at(lo, span, 0.10, 0.80),
+    _cap_at(lo, span, 0.30, 0.90),
   ]
-
-  # Insert near tail to couple many active colors without inflating omega
-  def _insert_near_tail(seq, intervals):
-    out = list(seq)
-    for i, iv in enumerate(intervals):
-      pos = len(out) - (i * 2 + 1)
-      if pos < 0:
-        out.append(iv)
-      else:
-        out.insert(pos, iv)
-    return out
-
-  room = CAP - len(T)
-  if room > 0:
-    T = _insert_near_tail(T, caps[:room])
-    T = _rebase_to_zero(T)
-
-  if len(T) >= CAP - 16:
+  for c in long_connectors:
+    if len(T) >= CAP:
+      break
+    # Append near the tail to maximize overlap with active colors
+    T.insert(len(T) - 3 if len(T) >= 3 else len(T), c)
+  T = _rebase_to_zero(T)
+
+  if len(T) >= CAP - 12:
     return T
 
-  # ---------- Stage 2: fractional-span micro rounds (thin, even seed) ----------
-  def _build_micro_delta_round(current_T, budget, iter_id=0, alt=False):
-    if not current_T or budget <= 8:
+  # ---------- Adaptive two-phase micro budgeting ----------
+  remaining = CAP - len(T)
+  # Phase A: allocate a fraction (e.g., 42%) of remaining to primary micro windows
+  phaseA_budget = max(0, int(round(remaining * 0.42)))
+  # Reserve small safety headroom
+  if phaseA_budget > remaining - 8:
+    phaseA_budget = max(0, remaining - 8)
+
+  # Phase B: leftover budget (but keep at least 4 slots for final caps)
+  remaining_after_A = CAP - len(T) - phaseA_budget
+  phaseB_budget = max(0, min(remaining_after_A - 4, CAP - len(T) - phaseA_budget))
+  # Safety cap
+  phaseA_budget = min(phaseA_budget, 8000)
+  phaseB_budget = min(phaseB_budget, 8000)
+
+  def _thin_seed(current_T, max_seed):
+    n = len(current_T)
+    if n == 0 or max_seed <= 0:
       return []
+    step = max(1, n // max_seed)
+    return current_T[::step][:max_seed]
+
+  def _build_micro(current_T, budget, iter_id=0, alt=False):
+    if not current_T or budget <= 4:
+      return []
 
     glo, ghi, G = _span_delta(current_T)
-
-    # Thin seed from current_T, evenly spaced; slightly larger to improve mixing
-    seed_sz = max(8, min(40, len(current_T) // 250))
-    stride = max(1, len(current_T) // max(1, seed_sz))
-    U = [current_T[i] for i in range(0, len(current_T), stride)][:seed_sz]
+    # Seed: adaptively sized but capped
+    seed_sz = max(8, min(48, len(current_T) // 200))
+    U = _thin_seed(current_T, seed_sz)
     if not U:
       return []
 
     ulo = min(l for l, _ in U)
 
-    # Two families of windows: primary (A, with slight shifts) and alternate (B).
+    # Two families of windows; alt uses offset windows to catch missed pairings
     if not alt:
-      shift = (iter_id % 3) * 0.02
+      shift = ((iter_id % 4) * 0.015)
       window_fracs = [
-        (0.12 + shift, 0.22 + shift),
-        (0.35 + shift, 0.45 + shift),
-        (0.58 + shift, 0.68 + shift),
-        (0.80 + shift, 0.90 + shift),
-      ]
-      # Clamp windows conservatively inside the span
-      window_fracs = [
-        (max(0.05, min(0.90, a)), max(0.10, min(0.95, b)))
-        for (a, b) in window_fracs
+        (0.10 + shift, 0.20 + shift),
+        (0.32 + shift, 0.42 + shift),
+        (0.54 + shift, 0.64 + shift),
+        (0.76 + shift, 0.86 + shift),
       ]
     else:
-      window_fracs = [(0.05, 0.15), (0.28, 0.38), (0.60, 0.70), (0.82, 0.92)]
-
-    # Build translated micro-blocks aligned to these windows
+      # alternate windows slightly overlapping different spine parts
+      window_fracs = [
+        (0.05, 0.15),
+        (0.28, 0.38),
+        (0.50, 0.62),
+        (0.70, 0.84),
+      ]
+
     blocks = []
-    for (fa, fb) in window_fracs:
-      win_lo = glo + int(round(fa * G))
+    for idx, (fa, fb) in enumerate(window_fracs):
+      win_lo = glo + int(round(max(0.0, min(0.99, fa)) * G))
       base = win_lo - ulo
       block = [(l + base, r + base) for (l, r) in U]
-      # Alternate internal reversal by block to break symmetry
-      tag = iter_id if not alt else (iter_id + 1)
-      if ((int(round(fa * 100)) // 5) + tag) % 2 == 1:
+      # Deterministic internal reversal to disrupt symmetry
+      if (idx + iter_id) % 2 == 1:
         block = list(reversed(block))
       blocks.append(block)
 
-    # Interleave micro-blocks (forward on even tag, reverse on odd tag)
+    # Interleave blocks to maximize cross-color hits
     micro = []
     maxlen = max(len(b) for b in blocks)
-    block_order = list(range(len(blocks)))
-    tag = iter_id if not alt else (iter_id + 1)
-    if tag % 2 == 1:
-      block_order.reverse()
+    order = list(range(len(blocks)))
+    if iter_id % 2 == 1:
+      order.reverse()
     for i in range(maxlen):
-      for idx in block_order:
-        blk = blocks[idx]
+      for j in order:
+        blk = blocks[j]
         if i < len(blk):
           micro.append(blk[i])
 
-    # Deterministic connectors across windows (fractional-span analog of KT caps)
+    # Micro connectors at fractional scale (careful to not inflate omega)
     micro_connectors = [
-      (glo + int(round(0.08 * G)), glo + int(round(0.30 * G))),  # left cap
-      (glo + int(round(0.60 * G)), glo + int(round(0.92 * G))),  # right cap
-      (glo + int(round(0.26 * G)), glo + int(round(0.56 * G))),  # cross 1
-      (glo + int(round(0.44 * G)), glo + int(round(0.78 * G))),  # cross 2
+      (glo + int(round(0.06 * G)), glo + int(round(0.28 * G))),
+      (glo + int(round(0.34 * G)), glo + int(round(0.58 * G))),
+      (glo + int(round(0.62 * G)), glo + int(round(0.90 * G))),
     ]
     if alt:
-      # One longer cross reserved for alternate micro-phase
-      micro_connectors.append((glo + int(round(0.18 * G)), glo + int(round(0.84 * G))))
+      # add one more cross in alternate
+      micro_connectors.append((glo + int(round(0.18 * G)), glo + int(round(0.82 * G))))
+
     for a, b in micro_connectors:
       if b > a:
         micro.append((a, b))
 
-    # Trim to available budget
+    # Trim micro to budget
     if len(micro) > budget:
       micro = micro[:budget]
     return micro
 
-  # Execute up to two micro-rounds: primary then alternate
-  room = CAP - len(T)
-  if room > 8:
-    microA = _build_micro_delta_round(T, room, iter_id=0, alt=False)
+  # Execute Phase A
+  if phaseA_budget >= 8:
+    microA = _build_micro(T, phaseA_budget, iter_id=0, alt=False)
     if microA:
-      if len(microA) > room:
-        microA = microA[:room]
-      T.extend(microA)
+      # Insert microA evenly across the tail region to maximize simultaneous active colors
+      insert_stride = max(1, len(microA) // 6)
+      pos = len(T) - 2
+      for i, iv in enumerate(microA):
+        if len(T) >= CAP:
+          break
+        # alternate insertion positions to overlap active color windows
+        T.insert(max(0, pos - (i % 3)), iv)
       T = _rebase_to_zero(T)
 
-  room = CAP - len(T)
-  if room > 8:
-    microB = _build_micro_delta_round(T, room, iter_id=1, alt=True)
+  # Execute Phase B (alternate windows) with leftover budget
+  remaining = CAP - len(T)
+  if remaining <= 8:
+    # small final near-tail caps if anything remains
+    if remaining > 0:
+      lo, hi, sp = _span_delta(T)
+      final_caps = [
+        _cap_at(lo, sp, 0.12, 0.55),
+        _cap_at(lo, sp, 0.40, 0.85)
+      ]
+      for cap in final_caps[:remaining]:
+        T.append(cap)
+    T = _rebase_to_zero(T)
+    if len(T) > CAP:
+      T = T[:CAP]
+    return T
+
+  phaseB_budget = remaining - 4 if remaining - 4 >= 8 else remaining - 1
+  if phaseB_budget >= 6:
+    microB = _build_micro(T, phaseB_budget, iter_id=1, alt=True)
     if microB:
-      if len(microB) > room:
-        microB = microB[:room]
-      T.extend(microB)
+      # Append microB primarily near the end, mixing with near-tail caps
+      for i, iv in enumerate(microB):
+        if len(T) >= CAP:
+          break
+        # place microB items near end with slight stagger
+        pos = len(T) - 1 - (i % 5)
+        if pos < 0:
+          T.append(iv)
+        else:
+          T.insert(pos, iv)
       T = _rebase_to_zero(T)
 
-  # Final capacity trim
+  # Final small near-tail caps to use leftover budget and tie colors across windows
+  remaining = CAP - len(T)
+  if remaining > 0:
+    lo, hi, sp = _span_delta(T)
+    tail_caps = [
+      _cap_at(lo, sp, 0.08, 0.60),
+      _cap_at(lo, sp, 0.25, 0.75),
+      _cap_at(lo, sp, 0.75, 0.92),
+    ]
+    for cap in tail_caps[:remaining]:
+      T.append(cap)
+    T = _rebase_to_zero(T)
+
+  # Final trim safety
   if len(T) > CAP:
     T = T[:CAP]
 
   return T
 
 # EVOLVE-BLOCK-END
 
 def run_experiment(**kwargs):
   """Main called by evaluator"""
   return construct_intervals()