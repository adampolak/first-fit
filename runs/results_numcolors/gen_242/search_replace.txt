<NAME>
rotating_spine_cap_margin_gated_micro
</NAME>

<DESCRIPTION>
I switch Stage 1 to a rotating four-template KT spine with parity-controlled interleaving and reverse-order assembly. This aligns with the strongest prior 2.30-tier designs and couples colors across scales more effectively than the fixed spine.

I introduce a CAP_MARGIN guard so micro-phases only run with sufficient headroom, preventing structure-destabilizing late additions near capacity. I also add a long-range cap micro-phase (three deterministic caps) immediately after the spine, a known tactic to raise FirstFit without inflating omega.

I tame the delta2 micro-round by removing the aggressive long cross and two long caps; I keep only the classic four connectors and a single short mid cap, focusing pressure without raising clique size. I gate micro-round execution and windowed micro-phases with CAP_MARGIN and slightly reduce budgets for safety.

Together, these targeted edits reintroduce the proven rotating spine, add disciplined cap injection, and enforce safer, deterministic micro-phase pacing. This should restore or improve the competitive ratio seen in earlier high-performing variants while keeping the interval count under the CAP.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
  # Use the classic fixed start-pattern to preserve strong KT coupling
  spine_starts = (2, 6, 10, 14)
=======
  # Use rotating start-patterns to enhance KT coupling; keep classic as primary
  spine_starts = (2, 6, 10, 14)
  template_bank = [
    (2, 6, 10, 14),
    (1, 5, 9, 13),
    (3, 7, 11, 15),
    (4, 8, 12, 16),
  ]
  # Capacity margin to gate micro-phases safely below CAP
  CAP_MARGIN = 32
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
  # Stage 1: six KT rounds, alternating interleaving to raise FF pressure
  for ridx in range(6):
    # Predict next size: size -> 4*size + 4; abort if it would exceed CAP
    nxt_size = 4 * len(T) + 4
    if nxt_size > CAP:
      break
    lo = min(l for l, r in T)
    hi = max(r for l, r in T)
    delta = hi - lo
    if delta <= 0:
      delta = 1
    # Build four translated blocks
    blocks = []
    for start in spine_starts:
      base = start * delta - lo
      blocks.append([(l + base, r + base) for (l, r) in T])
    # Interleave on even rounds, sequential on odd rounds
    S = []
    if ridx % 2 == 0:
      maxlen = max(len(b) for b in blocks)
      for i in range(maxlen):
        for blk in blocks:
          if i < len(blk):
            S.append(blk[i])
    else:
      for blk in blocks:
        S.extend(blk)
    # Classic connectors (Figure 4 style)
    s0, s1, s2, s3 = spine_starts
    connectors = [
      ((s0 - 1) * delta, (s1 - 1) * delta),  # left cap
      ((s2 + 2) * delta, (s3 + 2) * delta),  # right cap
      ((s0 + 2) * delta, (s2 - 1) * delta),  # cross 1
      ((s1 + 2) * delta, (s3 - 1) * delta),  # cross 2
    ]
    S.extend(connectors)
    T = S
=======
  # Stage 1: six KT rounds, rotating starts and alternating interleaving/reverse order
  for ridx in range(6):
    # Predict next size: size -> 4*size + 4; abort if it would exceed CAP
    nxt_size = 4 * len(T) + 4
    if nxt_size > CAP:
      break
    starts = template_bank[ridx % len(template_bank)]  # rotate among four templates
    lo = min(l for l, r in T)
    hi = max(r for l, r in T)
    delta = hi - lo
    if delta <= 0:
      delta = 1
    # Build four translated blocks
    blocks = []
    for start in starts:
      base = start * delta - lo
      blocks.append([(l + base, r + base) for (l, r) in T])
    # Interleave on even rounds with forward order; on odd rounds, reverse block order
    S = []
    order = list(range(4))
    if ridx % 2 == 1:
      order.reverse()
    if ridx % 2 == 0:
      maxlen = max(len(b) for b in blocks)
      for i in range(maxlen):
        for idx in order:
          blk = blocks[idx]
          if i < len(blk):
            S.append(blk[i])
    else:
      for idx in order:
        S.extend(blocks[idx])
    # Classic connectors (Figure 4 style) using current starts
    s0, s1, s2, s3 = starts
    connectors = [
      ((s0 - 1) * delta, (s1 - 1) * delta),  # left cap
      ((s2 + 2) * delta, (s3 + 2) * delta),  # right cap
      ((s0 + 2) * delta, (s2 - 1) * delta),  # cross 1
      ((s1 + 2) * delta, (s3 - 1) * delta),  # cross 2
    ]
    S.extend(connectors)
    T = S
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
  # If we are already near the cap, return the strong baseline.
  if len(T) >= CAP - 16:
    return T

  # Stage 2: Two delta2-driven micro extension rounds (thin sampling; four-start translations).
  # Goals:
  #  - Raise FF pressure via cross-scale coupling and interleaving parity,
  #  - Keep omega in check by using thin seeds and sparse caps/connectors,
  #  - Respect strict capacity guard.
=======
  # If we are already near the cap, return the strong baseline.
  if len(T) >= CAP - 16:
    return T

  # Micro-phase A: inject three long-range caps (gated by CAP_MARGIN) to boost FF without increasing omega
  if len(T) <= CAP - CAP_MARGIN:
    lo = min(l for l, r in T)
    hi = max(r for l, r in T)
    span = max(1, hi - lo)
    def _cap_at(a_frac, b_frac):
      L = lo + max(1, int(round(a_frac * span)))
      R = lo + max(1, int(round(b_frac * span)))
      if R <= L:
        R = L + 1
      return (L, R)
    for c in (_cap_at(0.08, 0.60), _cap_at(0.25, 0.75), _cap_at(0.75, 0.92)):
      if len(T) < CAP and c[1] > c[0]:
        T.append(c)

  # Stage 2: Two delta2-driven micro extension rounds (thin sampling; four-start translations).
  # Goals:
  #  - Raise FF pressure via cross-scale coupling and interleaving parity,
  #  - Keep omega in check by using thin seeds and sparse caps/connectors,
  #  - Respect strict capacity guard.
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
    # Deterministic connectors at delta2 scale, including a cross3 extension
    s0, s1, s2, s3 = spine_starts
    connectors = [
      ((s0 - 1) * delta2 + glo, (s1 - 1) * delta2 + glo),  # left cap (localized)
      ((s2 + 2) * delta2 + glo, (s3 + 2) * delta2 + glo),  # right cap
      ((s0 + 2) * delta2 + glo, (s2 - 1) * delta2 + glo),  # cross 1
      ((s1 + 2) * delta2 + glo, (s3 - 1) * delta2 + glo),  # cross 2
      ((s0 + 3) * delta2 + glo, (s3 + 3) * delta2 + glo),  # cross3 (longer range)
    ]
    micro.extend(connectors)

    # Sparse micro caps: add three long but safe caps at half-scale
    cap1 = (glo + (delta2 // 4), glo + int(1.8 * delta2))
    cap2 = (glo + int(0.9 * delta2), glo + int(2.6 * delta2))
    mid = glo + G // 2
    cap3 = (mid - max(1, delta2 // 8), mid + max(1, delta2 // 8))
    for cap in (cap1, cap2, cap3):
      if cap[1] > cap[0]:
        micro.append(cap)
=======
    # Deterministic connectors at delta2 scale (keep classic four; avoid long cross to protect omega)
    s0, s1, s2, s3 = spine_starts
    connectors = [
      ((s0 - 1) * delta2 + glo, (s1 - 1) * delta2 + glo),  # left cap (localized)
      ((s2 + 2) * delta2 + glo, (s3 + 2) * delta2 + glo),  # right cap
      ((s0 + 2) * delta2 + glo, (s2 - 1) * delta2 + glo),  # cross 1
      ((s1 + 2) * delta2 + glo, (s3 - 1) * delta2 + glo),  # cross 2
    ]
    micro.extend(connectors)

    # Single short mid cap to tie distant colors without inflating cliques
    mid = glo + G // 2
    cap_mid = (mid - max(1, delta2 // 8), mid + max(1, delta2 // 8))
    if cap_mid[1] > cap_mid[0]:
      micro.append(cap_mid)
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
  # Execute two micro rounds with strong guards
  remaining = CAP - len(T)
  mr1 = micro_round(T, round_id=0, budget=max(0, remaining // 2))
  if mr1:
    room = CAP - len(T)
    if len(mr1) > room:
      mr1 = mr1[:room]
    T.extend(mr1)

  remaining = CAP - len(T)
  mr2 = micro_round(T, round_id=1, budget=max(0, remaining))
  if mr2:
    room = CAP - len(T)
    if len(mr2) > room:
      mr2 = mr2[:room]
    T.extend(mr2)
=======
  # Execute two micro rounds with CAP_MARGIN gating
  remaining = CAP - len(T)
  if len(T) <= CAP - CAP_MARGIN:
    mr1 = micro_round(T, round_id=0, budget=max(0, remaining // 3))
    if mr1:
      room = CAP - len(T)
      if len(mr1) > room:
        mr1 = mr1[:room]
      T.extend(mr1)

    remaining = CAP - len(T)
    if len(T) <= CAP - (CAP_MARGIN // 2):
      mr2 = micro_round(T, round_id=1, budget=max(0, remaining // 2))
      if mr2:
        room = CAP - len(T)
        if len(mr2) > room:
          mr2 = mr2[:room]
        T.extend(mr2)
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
  # Secondary windowed micro-phase pulses (capacity-guarded)
  remaining = CAP - len(T)
  if remaining > 12:
    microA = build_micro_windows_round(T, budget=max(12, remaining // 2), iter_id=0, alt=False)
    if microA:
      take = min(len(microA), CAP - len(T))
      T.extend(microA[:take])

  remaining = CAP - len(T)
  if remaining > 8:
    microB = build_micro_windows_round(T, budget=min(128, remaining), iter_id=1, alt=True)
    if microB:
      take = min(len(microB), CAP - len(T))
      T.extend(microB[:take])
=======
  # Secondary windowed micro-phase pulses (capacity-guarded)
  remaining = CAP - len(T)
  if remaining > 12 and len(T) <= CAP - CAP_MARGIN:
    microA = build_micro_windows_round(T, budget=min(128, max(12, remaining // 2)), iter_id=0, alt=False)
    if microA:
      take = min(len(microA), CAP - len(T))
      T.extend(microA[:take])

  remaining = CAP - len(T)
  if remaining > 8 and len(T) <= CAP - (CAP_MARGIN // 2):
    microB = build_micro_windows_round(T, budget=min(96, remaining), iter_id=1, alt=True)
    if microB:
      take = min(len(microB), CAP - len(T))
      T.extend(microB[:take])
>>>>>>> REPLACE

</DIFF>