<NAME>
micro_phase_delta2_with_cross4
</NAME>

<DESCRIPTION>
I add a safeguarded micro-phase after the 6-round KT spine to push FirstFit’s color usage while keeping the clique number ≤ 10. The micro-phase uses thin, evenly spaced seeds from the final spine, translates them at a half-scale delta (delta2) with a fixed four-start template (2,6,10,14), and interleaves blocks with parity to force more color mixing. I also add a small set of connectors including a cross4 pattern to strengthen cross-scale coupling. The micro-phase is tightly capacity-gated and uses sparse caps to avoid densifying any small region, which helps keep omega from exceeding 10. This approach follows known heuristics from the KT construction and related literature: thin seeding, parity-based interleaving, and cross-scale connectors are effective at raising FF colors without inflating omega. It restores and strengthens the behavior that previously achieved alg≈22 with opt=10, while preserving the strong determinism and <10000 capacity.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    if len(T) > CAP:
      break

  # Return the spine-only construction to avoid omega inflation from micro-phases.
  return T
=======
    if len(T) > CAP:
      break

  # Stage 2: delta2-driven micro extension rounds (thin sampling; four-start translations).
  # Goals:
  #  - Raise FF pressure via cross-scale coupling and interleaving parity,
  #  - Keep omega in check by using thin seeds and sparse caps/connectors,
  #  - Respect strict capacity guard and keep OPT <= 10 by avoiding dense local overlaps.
  remaining = CAP - len(T)
  if remaining <= 16:
    return T

  def thin_seed(current_T, max_seed):
    n = len(current_T)
    if n == 0 or max_seed <= 0:
      return []
    step = max(1, n // max_seed)
    return current_T[::step][:max_seed]

  def micro_round(current_T, round_id, budget):
    if budget <= 0 or not current_T:
      return []

    glo = min(l for l, r in current_T)
    ghi = max(r for l, r in current_T)
    G = max(1, ghi - glo)

    # Use delta2 at half-scale to avoid expanding the global span too aggressively.
    delta2 = max(1, G // 2)

    # Thin seed: bounded and deterministic size to respect budget.
    per_block_target = max(8, min(64, budget // 12))
    U = thin_seed(current_T, per_block_target)
    if not U:
      return []

    # Build four translated blocks using a fixed 4-start template to stabilize omega.
    starts = (2, 6, 10, 14)
    blocks = []
    ulo = min(l for l, r in U)
    for s in starts:
      base = s * delta2 - ulo
      block = [(l + base, r + base) for (l, r) in U]
      # Add a tiny deterministic internal reversal to break symmetry every other block
      if ((s // 2) % 2) == (round_id % 2):
        block = list(reversed(block))
      blocks.append(block)

    micro = []
    if round_id % 2 == 0:
      # Forward interleave
      maxlen = max(len(b) for b in blocks)
      for i in range(maxlen):
        for blk in blocks:
          if i < len(blk):
            micro.append(blk[i])
    else:
      # Reverse interleave (swap block order)
      maxlen = max(len(b) for b in blocks)
      for i in range(maxlen):
        for blk in reversed(blocks):
          if i < len(blk):
            micro.append(blk[i])

    # Deterministic connectors at delta2 scale, including a cross3 and cross4 extension.
    s0, s1, s2, s3 = starts
    connectors = [
      ((s0 - 1) * delta2 + glo, (s1 - 1) * delta2 + glo),  # left cap (localized)
      ((s2 + 2) * delta2 + glo, (s3 + 2) * delta2 + glo),  # right cap
      ((s0 + 2) * delta2 + glo, (s2 - 1) * delta2 + glo),  # cross 1
      ((s1 + 2) * delta2 + glo, (s3 - 1) * delta2 + glo),  # cross 2
      ((s0 + 3) * delta2 + glo, (s3 + 3) * delta2 + glo),  # cross3 (longer range)
      ((s1 + 4) * delta2 + glo, (s2 + 4) * delta2 + glo),  # cross4 (extended coupling)
    ]
    micro.extend(connectors)

    # Sparse micro caps: add three long but safe caps at half-scale
    cap1 = (glo + (delta2 // 4), glo + int(1.8 * delta2))
    cap2 = (glo + int(0.9 * delta2), glo + int(2.6 * delta2))
    mid = glo + G // 2
    cap3 = (mid - max(1, delta2 // 8), mid + max(1, delta2 // 8))
    for cap in (cap1, cap2, cap3):
      if cap[1] > cap[0]:
        micro.append(cap)

    # Enforce budget
    if len(micro) > budget:
      micro = micro[:budget]
    return micro

  # Execute two micro rounds with strong guards
  remaining = CAP - len(T)
  mr1 = micro_round(T, round_id=0, budget=max(0, remaining // 2))
  if mr1:
    room = CAP - len(T)
    if len(mr1) > room:
      mr1 = mr1[:room]
    T.extend(mr1)

  remaining = CAP - len(T)
  mr2 = micro_round(T, round_id=1, budget=max(0, remaining))
  if mr2:
    room = CAP - len(T)
    if len(mr2) > room:
      mr2 = mr2[:room]
    T.extend(mr2)

  return T
>>>>>>> REPLACE

</DIFF>