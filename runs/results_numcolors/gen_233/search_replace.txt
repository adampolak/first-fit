<NAME>
second_microphase_long_connectors
</NAME>

<DESCRIPTION>
I add a new, CAP-guarded Micro-phase D after the existing micro-phase C. This phase introduces a second four-window micro-round with a distinct window pattern and a set of long, pairwise-disjoint connectors. The windows are chosen to complement phases B and C, and the block interleaving order is different to further disrupt FirstFit’s reuse of early colors. The disjoint connector intervals provide long-range coupling while carefully avoiding stacking at a single point, which helps maintain the clique number (omega) at or below 10. The phase respects the global CAP and only appends within available capacity. This targeted addition aims to push FirstFit to use more colors (beyond 23 for omega ≈ 10), leveraging a layered “spine + windows + disjoint connectors” strategy inspired by tower/cap constructions with arrival-order engineering, without increasing omega.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
  # Micro-phase C: second guarded micro-round using distinct windows and pin shrinking
  if len(T) < CAP - 8:
    glo2 = min(l for l, r in T)
    ghi2 = max(r for l, r in T)
    G2 = ghi2 - glo2 if ghi2 > glo2 else 1

    # Thin seed again (slightly smaller to limit omega growth)
    seed_sz2 = max(8, min(24, len(T) // 400))
    stride2 = max(1, len(T) // max(1, seed_sz2))
    U2 = [T[i] for i in range(0, len(T), stride2)][:seed_sz2]

    if U2:
      ulo2 = min(l for l, r in U2)

      # New window set to avoid stacking with phase B windows
      windows2 = [(0.05, 0.15), (0.28, 0.38), (0.60, 0.70), (0.82, 0.92)]

      # Short pins to reduce clique growth; slight stagger to avoid co-location
      eps = max(1, G2 // 512)
      blocks2 = []
      for (fa, fb) in windows2:
        win_lo2 = glo2 + int(round(fa * G2))
        base2 = win_lo2 - ulo2
        block = []
        for idx, (l, r) in enumerate(U2):
          mid = (l + r) // 2
          L = mid + base2 - (eps // 2) + (idx % 3)
          R = L + eps
          if R > L:
            block.append((L, R))
        blocks2.append(block)

      # Interleave with a different order to diversify coupling
      micro2 = []
      if blocks2:
        maxlen2 = max(len(b) for b in blocks2)
        order2 = [3, 1, 0, 2]
        for i in range(maxlen2):
          for idx in order2:
            blk = blocks2[idx]
            if i < len(blk):
              micro2.append(blk[i])

      # Very short cap-pins to tie windows without inflating omega
      caps2 = [
        (glo2 + int(round(0.09 * G2)), glo2 + int(round(0.09 * G2)) + eps),
        (glo2 + int(round(0.64 * G2)), glo2 + int(round(0.64 * G2)) + eps),
      ]
      for a, b in caps2:
        if b > a:
          micro2.append((a, b))

      # Capacity guard
      room2 = CAP - len(T)
      if room2 > 0:
        if len(micro2) > room2:
          micro2 = micro2[:room2]
        T.extend(micro2)

  return T
=======
  # Micro-phase C: second guarded micro-round using distinct windows and pin shrinking
  if len(T) < CAP - 8:
    glo2 = min(l for l, r in T)
    ghi2 = max(r for l, r in T)
    G2 = ghi2 - glo2 if ghi2 > glo2 else 1

    # Thin seed again (slightly smaller to limit omega growth)
    seed_sz2 = max(8, min(24, len(T) // 400))
    stride2 = max(1, len(T) // max(1, seed_sz2))
    U2 = [T[i] for i in range(0, len(T), stride2)][:seed_sz2]

    if U2:
      ulo2 = min(l for l, r in U2)

      # New window set to avoid stacking with phase B windows
      windows2 = [(0.05, 0.15), (0.28, 0.38), (0.60, 0.70), (0.82, 0.92)]

      # Short pins to reduce clique growth; slight stagger to avoid co-location
      eps = max(1, G2 // 512)
      blocks2 = []
      for (fa, fb) in windows2:
        win_lo2 = glo2 + int(round(fa * G2))
        base2 = win_lo2 - ulo2
        block = []
        for idx, (l, r) in enumerate(U2):
          mid = (l + r) // 2
          L = mid + base2 - (eps // 2) + (idx % 3)
          R = L + eps
          if R > L:
            block.append((L, R))
        blocks2.append(block)

      # Interleave with a different order to diversify coupling
      micro2 = []
      if blocks2:
        maxlen2 = max(len(b) for b in blocks2)
        order2 = [3, 1, 0, 2]
        for i in range(maxlen2):
          for idx in order2:
            blk = blocks2[idx]
            if i < len(blk):
              micro2.append(blk[i])

      # Very short cap-pins to tie windows without inflating omega
      caps2 = [
        (glo2 + int(round(0.09 * G2)), glo2 + int(round(0.09 * G2)) + eps),
        (glo2 + int(round(0.64 * G2)), glo2 + int(round(0.64 * G2)) + eps),
      ]
      for a, b in caps2:
        if b > a:
          micro2.append((a, b))

      # Capacity guard
      room2 = CAP - len(T)
      if room2 > 0:
        if len(micro2) > room2:
          micro2 = micro2[:room2]
        T.extend(micro2)

  # Micro-phase D: second four-window micro-phase with distinct windows and long-range connectors
  if len(T) < CAP - 4:
    glo3 = min(l for l, r in T)
    ghi3 = max(r for l, r in T)
    G3 = ghi3 - glo3 if ghi3 > glo3 else 1

    # Thin seed (moderate) from current T for stronger mixing
    seed_sz3 = max(8, min(36, len(T) // 300))
    stride3 = max(1, len(T) // max(1, seed_sz3))
    U3 = [T[i] for i in range(0, len(T), stride3)][:seed_sz3]

    if U3:
      ulo3 = min(l for l, r in U3)

      # Distinct window pattern to complement earlier phases
      window_fracs3 = [(0.09, 0.19), (0.32, 0.42), (0.64, 0.74), (0.86, 0.94)]
      blocks3 = []
      for (fa, fb) in window_fracs3:
        win_lo3 = glo3 + int(round(fa * G3))
        base3 = win_lo3 - ulo3
        block = [(l + base3, r + base3) for (l, r) in U3]
        # Reverse every second block to vary internal order
        if int(round(fa * 100)) % 2 == 0:
          block = list(reversed(block))
        blocks3.append(block)

      # Interleave using a nontrivial order to break symmetry
      micro3 = []
      if blocks3:
        maxlen3 = max(len(b) for b in blocks3)
        order3 = [0, 2, 1, 3]
        for i in range(maxlen3):
          for idx in order3:
            blk = blocks3[idx]
            if i < len(blk):
              micro3.append(blk[i])

      # Long-range, pairwise-disjoint connectors to avoid omega spikes
      connectors3 = [
        (glo3 + int(round(0.06 * G3)), glo3 + int(round(0.28 * G3))),
        (glo3 + int(round(0.41 * G3)), glo3 + int(round(0.59 * G3))),
        (glo3 + int(round(0.72 * G3)), glo3 + int(round(0.95 * G3))),
      ]
      for a, b in connectors3:
        if b > a:
          micro3.append((a, b))

      # Capacity guard
      room3 = CAP - len(T)
      if room3 > 0:
        if len(micro3) > room3:
          micro3 = micro3[:room3]
        T.extend(micro3)

  return T
>>>>>>> REPLACE

</DIFF>