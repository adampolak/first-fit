--- a/original.py
+++ b/original.py
@@ -1,49 +1,71 @@
 # EVOLVE-BLOCK-START
 
 def construct_intervals():
   """
   Construct a sequence of intervals of real line,
   in the order in which they are presented to FirstFit,
   so that it maximizes the number of colors used by FirstFit
   divided by the maximum number of intervals that cover a single point
 
   The initial implementation uses the construction from
   Figure 4 in https://arxiv.org/abs/1506.00192
 
   Returns:
     intervals: list of tuples, each tuple (l, r) represents an open interval from l to r
   """
 
+  # cycle through multiple start-pattern templates and interleave blocks
+  start_patterns = [(2, 6, 10, 14), (3, 7, 11, 15), (1, 5, 9, 13), (4, 8, 12, 16)]
   T = [(0, 1)]
-  for _ in range(6):
+  for round_idx in range(6):
     lo = min(l for l, r in T)
     hi = max(r for l, r in T)
-    delta = hi - lo
+    delta = hi - lo if hi > lo else 1
+    # select pattern for this round
+    starts = start_patterns[round_idx % len(start_patterns)]
+    # build and interleave translated blocks
+    blocks = []
+    for s in starts:
+      blocks.append([(delta * s + l - lo, delta * s + r - lo) for l, r in T])
     S = []
-    for start in (2, 6, 10, 14):
-      S += [(delta * start + l - lo, delta * start + r - lo) for l, r in T]
-    S += [
+    maxlen = max(len(b) for b in blocks)
+    for i in range(maxlen):
+      for blk in blocks:
+        if i < len(blk):
+          S.append(blk[i])
+    # original connectors plus extra cross3 for better coupling
+    s0, s1, s2, s3 = starts
+    connectors = [
       (delta * 1, delta * 5),
       (delta * 12, delta * 16),
       (delta * 4, delta * 9),
-      (delta * 8, delta * 13)
+      (delta * 8, delta * 13),
+      (delta * (s0 + 3), delta * (s3 - 2)),
     ]
+    S.extend(connectors)
     T = S
+  # micro-phase: sprinkle sparse long-range caps to boost FF usage late
+  lo = min(l for l, r in T)
+  hi = max(r for l, r in T)
+  span = hi - lo if hi > lo else 1
+  cap_len = max(1, span // 25)
+  T.append((lo + 2 * cap_len, lo + 10 * cap_len))
+  T.append((hi - 10 * cap_len, hi - 2 * cap_len))
   return T
 
   # return [  # Figure 3, OPT=2, FF=4
   #   (2,3),
   #   (6,7),
   #   (10,11),
   #   (14,15),
   #   (1,5),
   #   (12,16),
   #   (4,9),
   #   (8,13),
   # ]
 
 # EVOLVE-BLOCK-END
 
 def run_experiment(**kwargs):
   """Main called by evaluator"""
   return construct_intervals()