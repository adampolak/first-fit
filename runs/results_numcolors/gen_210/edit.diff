--- a/original.py
+++ b/original.py
@@ -1,244 +1,274 @@
 # EVOLVE-BLOCK-START
 
-def _span_delta(T):
-  lo = min(l for l, _ in T)
-  hi = max(r for _, r in T)
-  delta = hi - lo
-  if delta <= 0:
-    delta = 1
-  return lo, hi, delta
-
-def _append_connectors(S, starts, delta):
-  s0, s1, s2, s3 = starts
-  S.append(((s0 - 1) * delta, (s1 - 1) * delta))  # left cap
-  S.append(((s2 + 2) * delta, (s3 + 2) * delta))  # right cap
-  S.append(((s0 + 2) * delta, (s2 - 1) * delta))  # cross 1
-  S.append(((s1 + 2) * delta, (s3 - 1) * delta))  # cross 2
-
-def _apply_round(current_T, starts, do_interleave=False, reverse_order=False):
-  lo, hi, delta = _span_delta(current_T)
-
-  # Build translated blocks from current_T
-  blocks = []
-  for s in starts:
-    base = s * delta - lo
-    block = [(l + base, r + base) for (l, r) in current_T]
-    blocks.append(block)
-
-  # Assemble S with optional interleaving and reverse order to mix colors
-  S = []
-  if do_interleave:
-    maxlen = max(len(b) for b in blocks)
-    order = list(range(4))
-    if reverse_order:
-      order.reverse()
-    for i in range(maxlen):
-      for idx in order:
-        blk = blocks[idx]
-        if i < len(blk):
-          S.append(blk[i])
-  else:
-    if reverse_order:
-      blocks = list(reversed(blocks))
-    for blk in blocks:
-      S.extend(blk)
-
-  # Classic connectors
-  _append_connectors(S, starts, delta)
-  return S
+import math
+from bisect import bisect_left, bisect_right
+
+def _sweep_omega(intervals):
+  """Compute maximum number of intervals covering any point (omega), using sweep-line."""
+  if not intervals:
+    return 0
+  events = []
+  for l, r in intervals:
+    # open intervals (l,r): treat start as +1 at l, end as -1 at r
+    events.append((l, 1))
+    events.append((r, -1))
+  events.sort()
+  cur = 0
+  best = 0
+  for _, delta in events:
+    cur += delta
+    if cur > best:
+      best = cur
+  return best
+
+def _firstfit_colors(intervals):
+  """
+  Simulate FirstFit on given sequence of intervals.
+  Returns list of colors (1-based) corresponding to intervals.
+  """
+  colors = []
+  # maintain for each color, a list of active intervals' indices or endpoints
+  # naive approach: for each new interval check overlaps with all previous intervals.
+  for i, (l, r) in enumerate(intervals):
+    used = set()
+    for j, (lj, rj) in enumerate(intervals[:i]):
+      if lj < r and l < rj:
+        used.add(colors[j])
+    # find smallest positive integer not in used
+    c = 1
+    while c in used:
+      c += 1
+    colors.append(c)
+  return colors
+
+def _assigned_color_if_appended(intervals, colors, candidate):
+  """
+  Given current intervals and their assigned FirstFit colors, compute
+  the color FirstFit would assign to candidate if appended next.
+  This avoids recomputing all colors.
+  """
+  l, r = candidate
+  used = set()
+  for (li, ri), ci in zip(intervals, colors):
+    if li < r and l < ri:
+      used.add(ci)
+  c = 1
+  while c in used:
+    c += 1
+  return c
+
+def _omega_if_appended(intervals, candidate):
+  """Compute omega after appending candidate by a sweep merging two events arrays."""
+  # faster to do a small sweep merging existing events with candidate events
+  events = []
+  for l, r in intervals:
+    events.append((l, 1))
+    events.append((r, -1))
+  events.append((candidate[0], 1))
+  events.append((candidate[1], -1))
+  events.sort()
+  cur = 0
+  best = 0
+  for _, delta in events:
+    cur += delta
+    if cur > best:
+      best = cur
+  return best
+
+def _interesting_endpoints(intervals):
+  """Return a small sorted list of distinct endpoints (deterministic sampling)."""
+  if not intervals:
+    return [0, 1]
+  pts = sorted(set([x for l, r in intervals for x in (l, r)]))
+  # sample endpoints: min, max, mid, quartiles (bounded to small list)
+  n = len(pts)
+  chosen = []
+  idxs = [0, n-1, n//2, n//4, (3*n)//4]
+  for idx in idxs:
+    if 0 <= idx < n:
+      chosen.append(pts[idx])
+  # also include a handful of near-tail points for span candidates
+  chosen.extend(pts[-6:])   # last few
+  chosen.extend(pts[:6])    # first few
+  # unique and sorted
+  chosen = sorted(set(chosen))
+  return chosen
 
 def construct_intervals(seed_count=1, phase2_iters=2, enable_parabolic=False):
   """
-  Construct a sequence of intervals of real line,
-  in the order in which they are presented to FirstFit,
-  so that it maximizes the number of colors used by FirstFit
-  divided by the maximum number of intervals that cover a single point.
-
-  Hybrid: six-round KT spine with rotated starts and parity-based assembly,
-  followed by a near-tail cap injection and thin delta-driven micro rounds.
+  Adaptive, simulated-firstfit greedy construction.
+
+  Inputs:
+    - seed_count (int): ignored for complexity but preserved signature (keeps deterministic behavior).
+    - phase2_iters (int): hint for number of "aggressive" greedy rounds (kept limited).
+    - enable_parabolic (bool): kept for compatibility (unused in this method).
+
+  Output:
+    - list of (l, r) tuples (open intervals), in the order to be presented to FirstFit.
   """
   CAP = 9800
-
-  # Rotated start templates (empirically strong)
-  template_bank = [
-    (2, 6, 10, 14),  # classic KT
-    (1, 5, 9, 13),   # left-shifted
-    (3, 7, 11, 15),  # right-shifted
-    (4, 8, 12, 16),  # stretched-right
-  ]
-
-  # Seed with a single unit interval to avoid early omega inflation
-  T = [(0, 1)]
-
-  # Stage 1: six KT rounds, alternating interleaving with reversed block order on odd rounds
-  for ridx in range(6):
-    starts = template_bank[ridx % len(template_bank)]
-    nxt_size = 4 * len(T) + 4
-    if nxt_size > CAP:
+  MAX_OMEGA = 10  # keep offline optimum <= 10
+
+  intervals = []
+
+  # deterministic small seed to give structure
+  # create a small symmetric anchor spine (deterministic)
+  anchors = [(0, 1), (4, 5), (8, 9), (12, 13)]
+  for a in anchors:
+    if len(intervals) < CAP:
+      intervals.append(a)
+
+  # compute current FF colors
+  colors = _firstfit_colors(intervals)
+
+  # We will run a bounded number of greedy iterations to fill up to CAP.
+  # Each iteration proposes a small deterministic candidate pool and picks the best
+  # candidate (highest assigned color while preserving omega <= MAX_OMEGA).
+  # The candidate pool is constructed from existing endpoints and a palette of lengths.
+  LENS = [1, 2, 3, 5, 8, 13, 21, 34]  # Fibonacci-like sizes to mix granularities
+  # Deterministic 'seed' parameter to make proposals repeatable
+  iter_limit = min(CAP - len(intervals), 8200)  # keep an upper bound on iterations
+  # phase2_iters increases the aggressiveness (more long spans at start)
+  extra_long_factor = 1 + max(0, min(4, int(phase2_iters)))
+
+  # Precompute existing events for faster omega checks occasionally
+  # We'll recompute omega per candidate but we maintain a reasonable candidate pool size.
+  for step in range(iter_limit):
+    room = CAP - len(intervals)
+    if room <= 0:
       break
-    do_interleave = (ridx % 2 == 0)
-    reverse_order = (ridx % 2 == 1)
-    T = _apply_round(T, starts, do_interleave=do_interleave, reverse_order=reverse_order)
-    if len(T) >= CAP:
-      T = T[:CAP]
-      return T
-
-  # If near capacity, return strong baseline
-  if len(T) >= CAP - 16:
-    return T
-
-  # Micro-phase A: inject sparse long caps near the tail to couple many active colors
-  def _insert_near_tail(seq, intervals):
-    out = list(seq)
-    for i, iv in enumerate(intervals):
-      pos = len(out) - (i * 2 + 1)
-      if pos < 0:
-        out.append(iv)
+
+    # current colors
+    colors = _firstfit_colors(intervals)
+
+    # gather interesting endpoints deterministically
+    pts = _interesting_endpoints(intervals)
+
+    candidates = []
+
+    # 1) Short candidates anchored near interesting endpoints
+    for p in pts:
+      for L in LENS[:4]:
+        l = p - L // 2
+        r = l + L
+        if r <= l:
+          r = l + 1
+        candidates.append((l, r))
+
+    # 2) Mid candidates: span from one endpoint to another nearby one
+    m = len(pts)
+    for i in range(0, m, max(1, m // 8)):
+      for j in range(i+1, min(m, i+6)):
+        l = pts[i] - 1
+        r = pts[j] + 1
+        if r > l:
+          candidates.append((l, r))
+
+    # 3) Long candidates: occasional long spans, scaled by extra_long_factor
+    span_lo = min(pts)
+    span_hi = max(pts)
+    span = max(1, span_hi - span_lo)
+    for L in (int(span * 0.08), int(span * 0.15), int(span * 0.25)):
+      if L <= 0:
+        continue
+      # derive a few anchored long placements
+      for shift_frac in (0.02, 0.10, 0.28):
+        l = span_lo + int(round(shift_frac * span)) - (L // 2)
+        r = l + max(1, L) * extra_long_factor
+        candidates.append((l, r))
+
+    # 4) "Comb" candidates: span a few spaced anchors without being extremely long
+    # use last few endpoints to craft varied spans
+    tail = pts[-8:] if len(pts) >= 8 else pts
+    for i in range(len(tail)):
+      for j in range(i+1, min(len(tail), i+5)):
+        l = tail[i] - 1
+        r = tail[j] + 1
+        candidates.append((l, r))
+
+    # make candidate pool deterministic and unique
+    seen = set()
+    uniq_cands = []
+    for c in candidates:
+      # normalize to integers
+      l, r = int(c[0]), int(c[1])
+      if r <= l:
+        r = l + 1
+      key = (l, r)
+      if key in seen:
+        continue
+      seen.add(key)
+      uniq_cands.append(key)
+      if len(uniq_cands) >= 120:  # cap candidate pool size for performance
+        break
+
+    # Evaluate candidates: compute assigned FF color and new omega
+    best_score = (-1, 0, None)  # (assigned_color, -omega, interval)
+    # To limit overhead, only fully evaluate limited candidates (top by heuristic length)
+    # Heuristic: evaluate longer candidates first since they tend to hit many colors
+    uniq_cands.sort(key=lambda iv: (iv[1] - iv[0]), reverse=True)
+
+    # We'll evaluate up to N_EVAL candidates this round
+    N_EVAL = 60
+    for cand in uniq_cands[:N_EVAL]:
+      assigned = _assigned_color_if_appended(intervals, colors, cand)
+      new_omega = _omega_if_appended(intervals, cand)
+      if new_omega > MAX_OMEGA:
+        continue
+      # Score tie-breakers:
+      # prefer candidate that causes larger assigned color,
+      # then prefer smaller new_omega, then shorter interval (less risk),
+      # then lexicographically earlier placement for determinism.
+      score = (assigned, -new_omega, - (cand[1] - cand[0]), -cand[0])
+      if (assigned, -new_omega, - (cand[1] - cand[0])) > (best_score[0], best_score[1], 0):
+        best_score = (assigned, -new_omega, cand)
+
+    # If no candidate respects omega, fallback to inserting a short filler that doesn't change omega
+    chosen = None
+    if best_score[2] is not None:
+      chosen = best_score[2]
+    else:
+      # create a tiny disjoint interval far to the right to avoid overlap growth
+      # place it after current max endpoint + 2
+      if intervals:
+        max_r = max(r for _, r in intervals)
       else:
-        out.insert(pos, iv)
-    return out
-
-  lo, hi, delta = _span_delta(T)
-  def cap_at(a_frac, b_frac):
-    L = lo + max(1, int(round(a_frac * delta)))
-    R = lo + max(1, int(round(b_frac * delta)))
-    if R <= L:
-      R = L + 1
-    return (L, R)
-
-  tail_caps = [
-    cap_at(0.08, 0.60),
-    cap_at(0.25, 0.75),
-    cap_at(0.75, 0.92),
-  ]
-  room = CAP - len(T)
-  if room > 0:
-    T = _insert_near_tail(T, tail_caps[:room])
-
-  if len(T) >= CAP - 16:
-    return T
-
-  # Micro-phase B: delta-driven micro rounds using a thin evenly spaced seed
-  def thin_seed(current_T, max_seed):
-    n = len(current_T)
-    if n == 0 or max_seed <= 0:
-      return []
-    step = max(1, n // max_seed)
-    return current_T[::step][:max_seed]
-
-  def build_micro_delta_round(current_T, budget, iter_id=0, alt=False):
-    if not current_T or budget <= 8:
-      return []
-
-    glo = min(l for l, r in current_T)
-    ghi = max(r for l, r in current_T)
-    G = max(1, ghi - glo)
-
-    # Thin seed (slightly larger for stronger mixing but bounded)
-    seed_sz = max(8, min(40, len(current_T) // 250))
-    stride = max(1, len(current_T) // max(1, seed_sz))
-    U = [current_T[i] for i in range(0, len(current_T), stride)][:seed_sz]
-    if not U:
-      return []
-
-    ulo = min(l for l, r in U)
-
-    # Window families
-    if not alt:
-      shift = (iter_id % 3) * 0.02
-      window_fracs = [
-        (0.12 + shift, 0.22 + shift),
-        (0.35 + shift, 0.45 + shift),
-        (0.58 + shift, 0.68 + shift),
-        (0.80 + shift, 0.90 + shift),
-      ]
-      window_fracs = [
-        (max(0.05, min(0.90, a)), max(0.10, min(0.95, b)))
-        for (a, b) in window_fracs
-      ]
-    else:
-      window_fracs = [(0.05, 0.15), (0.28, 0.38), (0.60, 0.70), (0.82, 0.92)]
-
-    # Build translated micro-blocks aligned to windows
-    blocks = []
-    for (fa, fb) in window_fracs:
-      win_lo = glo + int(round(fa * G))
-      base = win_lo - ulo
-      block = [(l + base, r + base) for (l, r) in U]
-      tag = iter_id if not alt else (iter_id + 1)
-      if ((int(round(fa * 100)) // 5) + tag) % 2 == 1:
-        block = list(reversed(block))
-      blocks.append(block)
-
-    # Interleave micro-blocks with tag-dependent order
-    micro = []
-    maxlen = max(len(b) for b in blocks)
-    order = list(range(len(blocks)))
-    tag = iter_id if not alt else (iter_id + 1)
-    if tag % 2 == 1:
-      order.reverse()
-    for i in range(maxlen):
-      for idx in order:
-        blk = blocks[idx]
-        if i < len(blk):
-          micro.append(blk[i])
-
-    # Connectors at fractional span scale
-    micro_connectors = [
-      (glo + int(round(0.08 * G)), glo + int(round(0.30 * G))),  # left cap
-      (glo + int(round(0.60 * G)), glo + int(round(0.92 * G))),  # right cap
-      (glo + int(round(0.26 * G)), glo + int(round(0.56 * G))),  # cross 1
-      (glo + int(round(0.44 * G)), glo + int(round(0.78 * G))),  # cross 2
-    ]
-    if alt:
-      micro_connectors.append((glo + int(round(0.18 * G)), glo + int(round(0.84 * G))))
-    for a, b in micro_connectors:
-      if b > a:
-        micro.append((a, b))
-
-    if len(micro) > budget:
-      micro = micro[:budget]
-    return micro
-
-  # Execute micro rounds; phase2_iters serves as the requested iterations (capped at 2)
-  steps = min(max(0, int(phase2_iters)), 2)
-  for iter_id in range(steps):
-    room = CAP - len(T)
-    if room <= 8:
+        max_r = 0
+      chosen = (max_r + 2, max_r + 3)
+
+    # Append the chosen interval
+    intervals.append(chosen)
+
+    # Occasionally (every 50 steps) do a small compaction:
+    # move intervals to positive range (translate) to keep numbers tidy
+    if (step + 1) % 50 == 0:
+      # Rebase so smallest left is 0
+      lo = min(l for l, r in intervals)
+      if lo != 0:
+        delta = -lo
+        intervals = [(l + delta, r + delta) for (l, r) in intervals]
+
+    # Stop early if we have reached a fairly high FirstFit color pressure
+    colors = _firstfit_colors(intervals)
+    if max(colors) >= 40 and len(intervals) >= 400:
+      # safety stop: we already forced many colors with bounded omega
       break
-    micro = build_micro_delta_round(T, room, iter_id=iter_id, alt=False)
-    if not micro:
-      break
-    if len(micro) > room:
-      micro = micro[:room]
-    T.extend(micro)
-
-  # Alternate micro family to capture missed interactions
-  room = CAP - len(T)
-  if room > 8:
-    microB = build_micro_delta_round(T, room, iter_id=steps, alt=True)
-    if microB:
-      if len(microB) > room:
-        microB = microB[:room]
-      T.extend(microB)
-
-  # Optional lightweight parabolic caps
-  if enable_parabolic:
-    room = CAP - len(T)
-    if room > 0:
-      lo, hi, delta = _span_delta(T)
-      caps = [
-        (lo + max(1, int(round(0.15 * delta))), lo + max(1, int(round(0.60 * delta)))),
-        (lo + max(1, int(round(0.25 * delta))), lo + max(1, int(round(0.80 * delta)))),
-        (lo + max(1, int(round(0.55 * delta))), lo + max(1, int(round(0.95 * delta)))),
-      ]
-      add = [c for c in caps if c[1] > c[0]][:room]
-      T.extend(add)
-
-  return T
+
+  # Final ensure length within CAP
+  if len(intervals) > CAP:
+    intervals = intervals[:CAP]
+
+  # Final normalization: translate so minimal left endpoint is 0 (clean output)
+  if intervals:
+    lo = min(l for l, r in intervals)
+    if lo < 0:
+      delta = -lo
+      intervals = [(l + delta, r + delta) for (l, r) in intervals]
+
+  return intervals
 
 # EVOLVE-BLOCK-END
 
 def run_experiment(**kwargs):
   """Main called by evaluator"""
   return construct_intervals()