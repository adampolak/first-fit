--- a/original.py
+++ b/original.py
@@ -1,234 +1,179 @@
 # EVOLVE-BLOCK-START
 
 def construct_intervals(rounds=6,
                         rotate_starts=True,
                         reverse_block_parity=True,
                         interleave_blocks=True,
-                        phase2_iters=1):
-  """
-  Deterministic KT-style spine with a rotating-template scaffold and a thin micro-phase.
+                        phase2_iters=2):
+    """
+    Enhanced KT-spine with ghost density, per-round micro-phases,
+    long-range cross connectors, and parity-based interleaving.
+    Returns a list of (l, r) tuples for FirstFit.
+    """
+    CAP = 9800
 
-  Parameters:
-    rounds (int): main expansion depth; near 6 yields ~9556 intervals for a single-seed KT spine.
-    rotate_starts (bool): rotate among strong start templates when True.
-    reverse_block_parity (bool): if True, flips even/odd interleaving parity each round.
-    interleave_blocks (bool): enable interleaving on selected rounds.
-    phase2_iters (int): micro-round iterations (safeguarded to at most two and budget-limited).
-
-  Returns:
-    intervals: list of (l, r) integer tuples, open intervals, in FF presentation order.
-  """
-
-  # Hard capacity guard to keep the total count < 10000
-  CAP = 9800
-
-  # Four strong start-pattern templates (rotated across rounds).
-  spine_starts = (2, 6, 10, 14)
-  template_bank = [
-    (2, 6, 10, 14),  # classic KT
-    (1, 5, 9, 13),   # left-shifted
-    (3, 7, 11, 15),  # right-shifted
-    (4, 8, 12, 16),  # stretched-right
-  ]
-
-  # Seed with one unit interval to allow six KT rounds within CAP.
-  T = [(0, 1)]
-
-  # Predictive size accounting to cap the number of full rounds.
-  # KT growth per round: size -> 4*size + 4
-  def round_next_size(sz):
-    return 4 * sz + 4
-
-  def max_rounds_within_cap(initial_size, max_rounds):
-    sz = initial_size
-    done = 0
-    for _ in range(max(0, int(max_rounds))):
-      nxt = round_next_size(sz)
-      if nxt > CAP:
-        break
-      sz = nxt
-      done += 1
-    return done, sz
-
-  def _span_delta(current_T):
-    lo = min(l for l, r in current_T)
-    hi = max(r for l, r in current_T)
-    delta = hi - lo
-    if delta <= 0:
-      delta = 1
-    return lo, hi, delta
-
-  def _append_connectors(S, starts, delta):
-    # Classic four connectors; preserves strong FF pressure while keeping omega modest.
-    s0, s1, s2, s3 = starts
-    S.append(((s0 - 1) * delta, (s1 - 1) * delta))  # left cap
-    S.append(((s2 + 2) * delta, (s3 + 2) * delta))  # right cap
-    S.append(((s0 + 2) * delta, (s2 - 1) * delta))  # cross 1
-    S.append(((s1 + 2) * delta, (s3 - 1) * delta))  # cross 2
-
-  def apply_round(current_T, starts, do_interleave=False, reverse_order=False):
-    lo, hi, delta = _span_delta(current_T)
-
-    # Build four translated blocks
-    blocks = []
-    for s in starts:
-      base = s * delta - lo
-      block = [(l + base, r + base) for (l, r) in current_T]
-      blocks.append(block)
-
-    # Build S either interleaving or sequential
-    S = []
-    if do_interleave:
-      maxlen = max(len(b) for b in blocks)
-      order = list(range(4))
-      if reverse_order:
-        order.reverse()
-      for i in range(maxlen):
-        for idx in order:
-          blk = blocks[idx]
-          if i < len(blk):
-            S.append(blk[i])
-    else:
-      if reverse_order:
-        blocks = list(reversed(blocks))
-      for blk in blocks:
-        S.extend(blk)
-
-    # Append classic connectors
-    _append_connectors(S, starts, delta)
-    return S
-
-  # Stage 1: KT spine with rotating templates and parity-based interleaving.
-  depth, _ = max_rounds_within_cap(len(T), rounds)
-  for ridx in range(depth):
-    starts = template_bank[ridx % len(template_bank)] if rotate_starts else spine_starts
-    # Even/odd interleaving policy; optionally reverse block order each round.
-    do_inter = bool(interleave_blocks and (ridx % 2 == 0))
-    rev = bool(reverse_block_parity and (ridx % 2 == 1))
-    T = apply_round(T, starts, do_interleave=do_inter, reverse_order=rev)
-
-  # If we are close to capacity, return the strong baseline.
-  if len(T) >= CAP - 8:
-    return T
-
-  # Micro-phase A: insert a tiny tail of long caps near the end to boost FF mixing.
-  def _insert_near_tail(seq, intervals):
-    out = list(seq)
-    for i, iv in enumerate(intervals):
-      pos = len(out) - (i * 2 + 1)
-      if pos < 0:
-        out.append(iv)
-      else:
-        out.insert(pos, iv)
-    return out
-
-  lo, hi, delta = _span_delta(T)
-  # Long caps positioned as fractions of the current span; ensure monotone endpoints.
-  def cap_at(a_frac, b_frac):
-    L = lo + max(1, int(round(a_frac * delta)))
-    R = lo + max(1, int(round(b_frac * delta)))
-    if R <= L:
-      R = L + 1
-    return (L, R)
-  caps = [cap_at(0.08, 0.60), cap_at(0.25, 0.75), cap_at(0.75, 0.92)]
-  # Capacity-guarded insertion
-  room = CAP - len(T)
-  if room > 0:
-    T = _insert_near_tail(T, caps[:room])
-
-  if len(T) >= CAP - 16:
-    return T
-
-  # Stage 2: delta2-driven micro rounds using thin evenly-spaced seeds.
-  def build_micro_delta_round(current_T, budget, iter_id=0):
-    if not current_T or budget <= 8:
-      return []
-
-    glo = min(l for l, r in current_T)
-    ghi = max(r for l, r in current_T)
-    G = max(1, ghi - glo)
-
-    # Thin seed from current_T, evenly spaced.
-    seed_sz = max(8, min(32, len(current_T) // 300))
-    stride = max(1, len(current_T) // max(1, seed_sz))
-    U = [current_T[i] for i in range(0, len(current_T), stride)][:seed_sz]
-    if not U:
-      return []
-
-    ulo = min(l for l, r in U)
-
-    # Slightly shift the window positions across iterations for diversification.
-    shift = (iter_id % 3) * 0.02
-    window_fracs = [
-      (0.12 + shift, 0.22 + shift),
-      (0.35 + shift, 0.45 + shift),
-      (0.58 + shift, 0.68 + shift),
-      (0.80 + shift, 0.90 + shift),
-    ]
-    # Clamp windows inside (0.05, 0.95)
-    window_fracs = [
-      (max(0.05, min(0.90, a)), max(0.10, min(0.95, b)))
-      for (a, b) in window_fracs
+    # Strong four-template bank
+    template_bank = [
+        (2, 6, 10, 14),  # classic
+        (1, 5, 9, 13),   # left-shift
+        (3, 7, 11, 15),  # right-shift
+        (4, 8, 12, 16),  # stretched
     ]
 
-    # Build translated micro-blocks aligned to these windows
-    blocks = []
-    for (fa, fb) in window_fracs:
-      win_lo = glo + int(round(fa * G))
-      base = win_lo - ulo
-      block = [(l + base, r + base) for (l, r) in U]
-      # Alternate internal reversal by block to break symmetry
-      if ((int(round(fa * 100)) // 5) + iter_id) % 2 == 1:
-        block = list(reversed(block))
-      blocks.append(block)
+    # Helpers
+    def _span(T):
+        lo = min(l for l, r in T)
+        hi = max(r for l, r in T)
+        d = hi - lo
+        return lo, hi, d if d > 0 else 1
 
-    # Interleave micro-blocks (forward on even iter, reverse on odd iter)
-    micro = []
-    maxlen = max(len(b) for b in blocks)
-    block_order = list(range(len(blocks)))
-    if iter_id % 2 == 1:
-      block_order.reverse()
-    for i in range(maxlen):
-      for idx in block_order:
-        blk = blocks[idx]
-        if i < len(blk):
-          micro.append(blk[i])
+    def _thin_sample(T, max_sz):
+        n = len(T)
+        if n == 0 or max_sz < 1:
+            return []
+        step = max(1, n // max_sz)
+        return [T[i] for i in range(0, n, step)][:max_sz]
 
-    # Deterministic connectors across windows (fractional-span analog of KT caps)
-    micro_connectors = [
-      (glo + int(round(0.08 * G)), glo + int(round(0.30 * G))),  # left cap
-      (glo + int(round(0.60 * G)), glo + int(round(0.92 * G))),  # right cap
-      (glo + int(round(0.26 * G)), glo + int(round(0.56 * G))),  # cross 1
-      (glo + int(round(0.44 * G)), glo + int(round(0.78 * G))),  # cross 2
-    ]
-    for a, b in micro_connectors:
-      if b > a:
-        micro.append((a, b))
+    def _append_connectors(S, starts, delta):
+        s0, s1, s2, s3 = starts
+        # four classic connectors
+        S.append(((s0-1)*delta, (s1-1)*delta))
+        S.append(((s2+2)*delta, (s3+2)*delta))
+        S.append(((s0+2)*delta, (s2-1)*delta))
+        S.append(((s1+2)*delta, (s3-1)*delta))
 
-    # Trim to available budget
-    if len(micro) > budget:
-      micro = micro[:budget]
-    return micro
+    def _append_cross4(S, starts, delta):
+        s0, _, _, s3 = starts
+        S.append(((s0+4)*delta, (s3+4)*delta))
 
-  # Execute up to two micro-rounds, capacity-guarded
-  steps = min(max(0, int(phase2_iters)), 2)
-  for iter_id in range(steps):
-    room = CAP - len(T)
-    if room <= 8:
-      break
-    micro = build_micro_delta_round(T, room, iter_id=iter_id)
-    if not micro:
-      break
-    # Capacity guard and append
-    avail = CAP - len(T)
-    if len(micro) > avail:
-      micro = micro[:avail]
-    T.extend(micro)
+    def apply_spine_round(T_prev, starts, ridx):
+        lo, hi, delta = _span(T_prev)
+        # main blocks
+        main_blocks = []
+        for s in starts:
+            base = s*delta - lo
+            main_blocks.append([(l+base, r+base) for (l, r) in T_prev])
+        # ghost density blocks (thin coupling)
+        U = _thin_sample(T_prev, max_sz= max(8, len(T_prev)//400))
+        ghost_blocks = []
+        if U:
+            ulo = min(l for l, r in U)
+            for i in range(len(starts)-1):
+                mid = (starts[i] + starts[i+1])//2
+                base = mid*delta - ulo
+                gb = [(l+base, r+base) for (l, r) in U]
+                # alternate reverse for mixing
+                if (ridx + i) % 2:
+                    gb.reverse()
+                ghost_blocks.append(gb)
+        # assemble block sequence
+        seq = []
+        blocks = []
+        # interleave main and ghosts if requested
+        if interleave_blocks:
+            # create interleave list: main[0], ghost[0], main[1], ghost[1], ...
+            for i in range(len(main_blocks)):
+                blocks.append(main_blocks[i])
+                if i < len(ghost_blocks):
+                    blocks.append(ghost_blocks[i])
+        else:
+            # sequential: all main, then all ghosts
+            blocks = main_blocks + ghost_blocks
+        # reverse block order on odd ridx if parity enabled
+        if reverse_block_parity and (ridx % 2 == 1):
+            blocks = list(reversed(blocks))
+        # weave blocks into seq
+        maxlen = max((len(b) for b in blocks), default=0)
+        for i in range(maxlen):
+            for blk in blocks:
+                if i < len(blk):
+                    seq.append(blk[i])
+        # connectors
+        _append_connectors(seq, starts, delta)
+        # occasional long-range connector
+        if ridx % 3 == 2:
+            _append_cross4(seq, starts, delta)
+        return seq
 
-  return T
+    def build_micro(T_prev, window_fracs, add_long_cross=False):
+        lo, hi, D = _span(T_prev)
+        # thin seed
+        U = _thin_sample(T_prev, max_sz=32)
+        if not U:
+            return []
+        ulo = min(l for l, r in U)
+        blocks = []
+        for (a_frac, b_frac) in window_fracs:
+            a = lo + int(a_frac * D)
+            # align seed's left to a
+            base = a - ulo
+            blk = [(l+base, r+base) for (l, r) in U]
+            blocks.append(blk if (len(blocks)%2==0) else list(reversed(blk)))
+        # interleave fully
+        micro = []
+        mlen = max(len(b) for b in blocks)
+        for i in range(mlen):
+            for blk in blocks:
+                if i < len(blk):
+                    micro.append(blk[i])
+        # small connectors
+        con_fracs = [(0.08,0.30),(0.60,0.92),(0.26,0.56),(0.44,0.78)]
+        for (a_frac,b_frac) in con_fracs:
+            A = lo + int(a_frac*D)
+            B = lo + int(b_frac*D)
+            if B > A:
+                micro.append((A,B))
+        if add_long_cross:
+            micro.append((lo + int(0.18*D), lo + int(0.84*D)))
+        return micro
+
+    # --- main construction ---
+    T = [(0,1)]
+    # Stage 1: spine rounds
+    for ridx in range(rounds):
+        # stop if CAP near
+        if len(T) > CAP*0.9:
+            break
+        starts = template_bank[ridx % len(template_bank)] if rotate_starts else template_bank[0]
+        new_block = apply_spine_round(T, starts, ridx)
+        T = new_block
+        # per-round micro-phase (even rounds)
+        if phase2_iters>0 and ridx%2==1 and len(T) < CAP-50:
+            wset = [(0.12,0.22),(0.35,0.45),(0.58,0.68),(0.80,0.90)]
+            micro = build_micro(T, wset, add_long_cross=False)
+            room = CAP - len(T)
+            if micro:
+                T.extend(micro[:room])
+    # Stage 2: final micro-phases
+    # A
+    if len(T) < CAP-100:
+        wA = [(0.10,0.20),(0.30,0.40),(0.55,0.65),(0.75,0.85)]
+        microA = build_micro(T, wA, add_long_cross=False)
+        room = CAP - len(T)
+        if microA:
+            T.extend(microA[:room])
+    # B
+    if len(T) < CAP-100:
+        wB = [(0.05,0.15),(0.28,0.38),(0.60,0.70),(0.82,0.92)]
+        microB = build_micro(T, wB, add_long_cross=True)
+        room = CAP - len(T)
+        if microB:
+            T.extend(microB[:room])
+    # Stage 3: global cross4 connectors
+    if len(T) < CAP-10:
+        lo, hi, D = _span(T)
+        for (fa, fb) in [(0.03,0.37),(0.22,0.66),(0.52,0.94)]:
+            A = lo + int(fa*D)
+            B = lo + int(fb*D)
+            if B > A:
+                T.append((A,B))
+    # final trim
+    if len(T) > CAP:
+        T = T[:CAP]
+    return T
 
 # EVOLVE-BLOCK-END
 
 def run_experiment(**kwargs):
   """Main called by evaluator"""
   return construct_intervals()