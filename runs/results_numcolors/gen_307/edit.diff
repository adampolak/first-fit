--- a/original.py
+++ b/original.py
@@ -1,209 +1,229 @@
 # EVOLVE-BLOCK-START
 
-def construct_intervals(enable_alt_microphase=True):
+def construct_intervals(enable_alt_microphase=True, BASE_SEED=7):
   """
   Construct a sequence of intervals of real line,
   in the order in which they are presented to FirstFit,
   so that it maximizes the number of colors used by FirstFit
   divided by the maximum number of intervals that cover a single point
 
   The initial implementation uses the construction from
   Figure 4 in https://arxiv.org/abs/1506.00192
 
   Returns:
     intervals: list of tuples, each tuple (l, r) represents an open interval from l to r
   """
 
   # Capacity guard to keep total intervals < 10000
   CAP = 9800
 
   # Use the classic fixed start-pattern to preserve strong KT coupling
   starts = (2, 6, 10, 14)
   T = [(0, 1)]
   for round_idx in range(6):
     lo = min(l for l, r in T)
     hi = max(r for l, r in T)
-    delta = hi - lo
+    delta = hi - lo if hi > lo else 1
     # build translated blocks in sequence (no interleaving)
     blocks = []
     for start in starts:
       blocks.append([(delta * start + l - lo, delta * start + r - lo) for l, r in T])
     S = []
-    # Interleave on even-indexed rounds to raise FirstFit pressure; keep sequential on odd rounds
-    if round_idx % 2 == 0:
-      maxlen = max(len(b) for b in blocks)
-      for i in range(maxlen):
-        for blk in blocks:
-          if i < len(blk):
-            S.append(blk[i])
-    else:
-      for blk in blocks:
-        S.extend(blk)
+    # Deterministic: interleave on every round to increase FF pressure
+    maxlen = max(len(b) for b in blocks)
+    # per-round deterministic reversal derived from BASE_SEED to diversify ordering
+    reverse_order = ((round_idx + BASE_SEED) % 2) == 1
+    order_blocks = list(blocks)
+    if reverse_order:
+      order_blocks = list(reversed(order_blocks))
+    for i in range(maxlen):
+      for blk in order_blocks:
+        if i < len(blk):
+          S.append(blk[i])
     # connectors based on the fixed starts
     s0, s1, s2, s3 = starts
     connectors = [
       (delta * (s0 - 1), delta * (s1 - 1)),  # left cap
       (delta * (s2 + 2), delta * (s3 + 2)),  # right cap
       (delta * (s0 + 2), delta * (s2 - 1)),  # cross 1
       (delta * (s1 + 2), delta * (s3 - 1)),  # cross 2
     ]
     for a, b in connectors:
       S.append((a, b))
     T = S
+
+  # After the KT spine, add a few deterministic long-range connectors to couple distant parts
+  if len(T) < CAP - 4:
+    lo_all = min(l for l, r in T)
+    hi_all = max(r for l, r in T)
+    span = max(1, hi_all - lo_all)
+    # choose multipliers to span multiple deltas (but keep endpoints within reasonable range)
+    long_connectors = [
+      (lo_all - span // 8, hi_all + span // 8),             # slightly extended full-span connector
+      (lo_all + span // 10, hi_all - span // 10),           # wide interior connector
+      (lo_all - span // 16, lo_all + span // 4),            # left long connector tying to left tail
+    ]
+    # capacity guard
+    room_l = CAP - len(T)
+    for conn in long_connectors[:room_l]:
+      a, b = conn
+      if b > a:
+        T.append((a, b))
+
   # Stage 2: Two delta2-driven micro extension rounds (thin sampling; four-start translations).
   # Skip if near capacity.
   if len(T) < CAP - 16:
     def thin_seed(current_T, max_seed):
       n = len(current_T)
       if n == 0 or max_seed <= 0:
         return []
       step = max(1, n // max_seed)
       return current_T[::step][:max_seed]
 
     def micro_round(current_T, round_id, budget):
       if budget <= 0 or not current_T:
         return []
       glo = min(l for l, r in current_T)
       ghi = max(r for l, r in current_T)
       G = max(1, ghi - glo)
       # Use half-scale to avoid expanding the global span too aggressively
       delta2 = max(1, G // 2)
 
       # Thin seed: bounded and deterministic size to respect budget
       per_block_target = max(8, min(64, budget // 12))
       U = thin_seed(current_T, per_block_target)
       if not U:
         return []
 
       # Build four translated blocks using the same 4-start template,
       # with deterministic parity-based internal reversal
       blocks = []
       ulo = min(l for l, r in U)
       for s in starts:
         base = s * delta2 - ulo
         block = [(l + base, r + base) for (l, r) in U]
         if ((s // 2) % 2) == (round_id % 2):
           block = list(reversed(block))
         blocks.append(block)
 
       micro = []
       # Parity-based interleaving across blocks
       maxlen = max(len(b) for b in blocks)
       if round_id % 2 == 0:
         for i in range(maxlen):
           for blk in blocks:
             if i < len(blk):
               micro.append(blk[i])
       else:
         for i in range(maxlen):
           for blk in reversed(blocks):
             if i < len(blk):
               micro.append(blk[i])
 
       # Deterministic connectors at delta2 scale, including a longer cross3
       s0, s1, s2, s3 = starts
       connectors = [
         ((s0 - 1) * delta2 + glo, (s1 - 1) * delta2 + glo),  # left cap
         ((s2 + 2) * delta2 + glo, (s3 + 2) * delta2 + glo),  # right cap
         ((s0 + 2) * delta2 + glo, (s2 - 1) * delta2 + glo),  # cross 1
         ((s1 + 2) * delta2 + glo, (s3 - 1) * delta2 + glo),  # cross 2
         ((s0 + 3) * delta2 + glo, (s3 + 3) * delta2 + glo),  # cross3 (long range)
       ]
       micro.extend(connectors)
 
       # Sparse micro caps to press FirstFit locally without raising omega much
       cap1 = (glo + (delta2 // 4), glo + int(1.8 * delta2))
       cap2 = (glo + int(0.9 * delta2), glo + int(2.6 * delta2))
       mid = glo + G // 2
       cap3 = (mid - max(1, delta2 // 8), mid + max(1, delta2 // 8))
       for cap in (cap1, cap2, cap3):
         if cap[1] > cap[0]:
           micro.append(cap)
 
       # Enforce budget
       if len(micro) > budget:
         micro = micro[:budget]
       return micro
 
     remaining = CAP - len(T)
     mr1 = micro_round(T, round_id=0, budget=max(0, remaining // 2))
     if mr1:
       room = CAP - len(T)
       if len(mr1) > room:
         mr1 = mr1[:room]
       T.extend(mr1)
 
     remaining = CAP - len(T)
     mr2 = micro_round(T, round_id=1, budget=max(0, remaining))
     if mr2:
       room = CAP - len(T)
       if len(mr2) > room:
         mr2 = mr2[:room]
       T.extend(mr2)
 
   # Alt micro-phase: four-window thin-seed injection (guarded, optional)
   if enable_alt_microphase and len(T) < CAP - 8:
     glo2 = min(l for l, r in T)
     ghi2 = max(r for l, r in T)
     G2 = max(1, ghi2 - glo2)
 
     # Even thinner seed to avoid omega spikes
     seed_sz2 = max(8, min(24, len(T) // 400))
     stride2 = max(1, len(T) // max(1, seed_sz2))
     U2 = [T[i] for i in range(0, len(T), stride2)][:seed_sz2]
 
     if U2:
       ulo2 = min(l for l, r in U2)
       windows2 = [(0.05, 0.15), (0.28, 0.38), (0.60, 0.70), (0.82, 0.92)]
 
       blocks2 = []
       for (fa, fb) in windows2:
         win_lo2 = glo2 + int(round(fa * G2))
         base2 = win_lo2 - ulo2
         block2 = [(l + base2, r + base2) for (l, r) in U2]
         blocks2.append(block2)
 
       # Distinct interleaving order to diversify coupling across windows
       micro2 = []
       if blocks2:
         maxlen2 = max(len(b) for b in blocks2)
         order2 = [3, 1, 0, 2]
         for i in range(maxlen2):
           for idx in order2:
             blk = blocks2[idx]
             if i < len(blk):
               micro2.append(blk[i])
 
       # Short "pin" connectors to couple windows without inflating omega
       eps = max(1, G2 // 512)
       for pf in (0.09, 0.33, 0.66, 0.87):
         a = glo2 + int(round(pf * G2))
         b = a + eps
         if b > a:
           micro2.append((a, b))
 
       # Capacity guard
       room2 = CAP - len(T)
       if room2 > 0:
         if len(micro2) > room2:
           micro2 = micro2[:room2]
         T.extend(micro2)
 
   return T
 
   # return [  # Figure 3, OPT=2, FF=4
   #   (2,3),
   #   (6,7),
   #   (10,11),
   #   (14,15),
   #   (1,5),
   #   (12,16),
   #   (4,9),
   #   (8,13),
   # ]
 
 # EVOLVE-BLOCK-END
 
 def run_experiment(**kwargs):
   """Main called by evaluator"""
   return construct_intervals()