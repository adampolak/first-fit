<NAME>
two_phase_interleave_connectors
</NAME>

<DESCRIPTION>
I introduce two targeted improvements inspired by Kierstead–Trotter style adversaries and multi-scale coupling to push FirstFit while keeping omega modest and the sequence size controlled:

1) Within each round, build translated copies as explicit blocks, then interleave them round‑robin. This disrupts color recycling and increases cross-block interference without increasing the clique number. I also add standard KT connectors (left cap, right cap, two crosses) based on the first four starts, which are known to couple distant blocks effectively and raise FF.

2) After the main rounds, add a small delta/2 micro-phase: a second-scale set of KT connectors plus two short preload blockers and two mid-span caps. This cross-scale coupling often bumps FF by a few more colors at low cost in interval count and without raising omega above typical limits (kept near 10 in prior best runs).

Bridging intervals between adjacent blocks are retained with slightly adjusted offsets to avoid accidental cliques. Overall this aims to improve the competitive ratio while keeping the interval count in roughly the same range as before, improving the combined score.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
def construct_intervals(rounds=3, seed_lo=0.0, seed_scale=1.0):
  """
  Deterministic, adaptive multi-round wave construction.
  - rounds: number of recursive expansion rounds
  - seed_lo / seed_scale: deterministic knobs for initial placement and scaling
  Returns:
    intervals: list of intervals (l, r) as open intervals
  """
  # Seed with several disjoint unit intervals to promote early overlap coupling
  T = [(seed_lo, seed_lo + 1.0 * seed_scale),
       (seed_lo + 2.0 * seed_scale, seed_lo + 3.0 * seed_scale),
       (seed_lo + 4.0 * seed_scale, seed_lo + 5.0 * seed_scale),
       (seed_lo + 6.0 * seed_scale, seed_lo + 7.0 * seed_scale)]

  # A small bank of four-interval gadgets (templates)
  templates = [
    # Template A: original pattern
    [(1, 5), (12, 16), (4, 9), (8, 13)],
    # Template B: shifted
    [(0.5, 4.5), (11, 15), (3.5, 8.5), (7, 12)],
    # Template C: tighter internal overlaps
    [(1, 4), (6, 9), (3, 7), (9, 13)],
    # Template D: staggered caps
    [(2, 6), (7, 11), (0, 3), (10, 14)]
  ]

  # Deterministic cycle of start-patterns (each is a tuple of starts)
  start_patterns = [
    (2, 6, 10, 14),                 # compact 4-wave
    (2, 4, 6, 8, 10, 12, 14, 16),   # dense 8-wave
    (2, 5, 8, 11, 14, 17, 20),      # staggered 7-wave
  ]

  for round_idx in range(rounds):
    lo = min(l for l, r in T)
    hi = max(r for l, r in T)
    delta = hi - lo
    if delta <= 0:
      delta = 1.0  # safety

    S = []

    # pick deterministic pattern/template for this round
    starts = list(start_patterns[round_idx % len(start_patterns)])
    template = templates[round_idx % len(templates)]

    # Build translated copies with alternating inner order to hamper color reuse
    for idx, start in enumerate(starts):
      base = T if (idx % 2 == 0) else list(reversed(T))
      S += [(delta * start + l - lo, delta * start + r - lo) for l, r in base]

      # light bridging between consecutive blocks to couple colors
      if idx + 1 < len(starts):
        nxt = starts[idx + 1]
        S.append((delta * (start + 0.5), delta * (nxt + 0.5)))

    # Add the chosen template intervals scaled by delta
    S += [(delta * a, delta * b) for (a, b) in template]

    # Add sparse caps to push color usage without large omega
    max_start = max(starts)
    caps_step = max(3, int(max(3, max_start) // 4))
    for j in range(2, max_start, caps_step):
      # small caps around positions to lightly pressure color usage
      S.append((delta * (j - 0.5), delta * (j + 1.0 + 0.5)))

    T = S

  return T
=======
def construct_intervals(rounds=3, seed_lo=0.0, seed_scale=1.0):
  """
  Deterministic, adaptive multi-round wave construction with interleaved blocks,
  Kierstead–Trotter connectors, and a small delta/2 micro-phase.
  - rounds: number of recursive expansion rounds
  - seed_lo / seed_scale: deterministic knobs for initial placement and scaling
  Returns:
    intervals: list of intervals (l, r) as open intervals
  """
  # Seed with several disjoint unit intervals to promote early overlap coupling
  T = [(seed_lo, seed_lo + 1.0 * seed_scale),
       (seed_lo + 2.0 * seed_scale, seed_lo + 3.0 * seed_scale),
       (seed_lo + 4.0 * seed_scale, seed_lo + 5.0 * seed_scale),
       (seed_lo + 6.0 * seed_scale, seed_lo + 7.0 * seed_scale)]

  # A small bank of four-interval gadgets (templates)
  templates = [
    # Template A: original pattern
    [(1, 5), (12, 16), (4, 9), (8, 13)],
    # Template B: shifted
    [(0.5, 4.5), (11, 15), (3.5, 8.5), (7, 12)],
    # Template C: tighter internal overlaps
    [(1, 4), (6, 9), (3, 7), (9, 13)],
    # Template D: staggered caps
    [(2, 6), (7, 11), (0, 3), (10, 14)]
  ]

  # Deterministic cycle of start-patterns (each is a tuple of starts)
  start_patterns = [
    (2, 6, 10, 14),                 # compact 4-wave
    (2, 4, 6, 8, 10, 12, 14, 16),   # dense 8-wave
    (2, 5, 8, 11, 14, 17, 20),      # staggered 7-wave
  ]

  for round_idx in range(rounds):
    lo = min(l for l, r in T)
    hi = max(r for l, r in T)
    delta = hi - lo
    if delta <= 0:
      delta = 1.0  # safety

    # pick deterministic pattern/template for this round
    starts = list(start_patterns[round_idx % len(start_patterns)])
    template = templates[round_idx % len(templates)]

    # Build translated copies as blocks with alternating inner order
    blocks = []
    for idx, start in enumerate(starts):
      src = T if (idx % 2 == 0) else list(reversed(T))
      base = delta * start - lo
      block = [(l + base, r + base) for (l, r) in src]
      blocks.append(block)

    # Interleave blocks round-robin to maximize cross-block interference
    S = []
    maxlen = max(len(b) for b in blocks) if blocks else 0
    order = list(range(len(blocks)))
    if round_idx % 2 == 1:
      order = order[::-1]
    for i in range(maxlen):
      for bidx in order:
        if i < len(blocks[bidx]):
          S.append(blocks[bidx][i])

    # light bridging between consecutive blocks to couple colors
    for i in range(len(starts) - 1):
      s = starts[i]
      nxt = starts[i + 1]
      S.append((delta * (s + 0.45), delta * (nxt + 0.35)))

    # Kierstead–Trotter style connectors (caps and crosses) derived from first four starts
    if len(starts) >= 4:
      s0, s1, s2, s3 = starts[0], starts[1], starts[2], starts[3]
      connectors = [
        (delta * (s0 - 1), delta * (s1 - 1)),  # left cap
        (delta * (s2 + 2), delta * (s3 + 2)),  # right cap
        (delta * (s0 + 2), delta * (s2 - 1)),  # cross 1
        (delta * (s1 + 2), delta * (s3 - 1)),  # cross 2
      ]
      S.extend(connectors)

    # Add the chosen template intervals scaled by delta
    S += [(delta * a, delta * b) for (a, b) in template]

    # Add sparse caps to push color usage without large omega
    max_start = max(starts) if starts else 0
    caps_step = max(3, int(max(3, max_start) // 4)) if max_start > 0 else 3
    for j in range(2, max_start, caps_step):
      S.append((delta * (j - 0.5), delta * (j + 1.5)))

    T = S

  # Two-phase enhancement: a small delta/2 micro-phase with connectors and blockers
  if T:
    lo = min(l for l, r in T)
    hi = max(r for l, r in T)
    delta = max(1.0, hi - lo)
    d2 = max(1.0, delta / 2.0)
    # KT connectors at half scale using a fixed mid-start pattern
    s0, s1, s2, s3 = 3, 7, 11, 15
    micro = [
      (d2 * (s0 - 1), d2 * (s1 - 1)),
      (d2 * (s2 + 2), d2 * (s3 + 2)),
      (d2 * (s0 + 2), d2 * (s2 - 1)),
      (d2 * (s1 + 2), d2 * (s3 - 1)),
      # preload blockers near domain ends
      (lo + 0.06 * d2, lo + 0.12 * d2),
      (hi - 0.12 * d2, hi - 0.06 * d2),
      # mid-span caps to further couple colors across layers
      (2.5 * d2, 6.5 * d2),
      (9.5 * d2, 13.5 * d2),
    ]
    # append micro-phase at the end to force new colors late
    T = T + micro

  return T
>>>>>>> REPLACE
</DIFF>