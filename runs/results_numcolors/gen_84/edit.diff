--- a/original.py
+++ b/original.py
@@ -1,77 +1,124 @@
 # EVOLVE-BLOCK-START
 
 def construct_intervals(rounds=3, seed_lo=0.0, seed_scale=1.0):
   """
-  Deterministic, adaptive multi-round wave construction.
+  Deterministic, adaptive multi-round wave construction with interleaved blocks,
+  Kierstead–Trotter connectors, and a small delta/2 micro-phase.
   - rounds: number of recursive expansion rounds
   - seed_lo / seed_scale: deterministic knobs for initial placement and scaling
   Returns:
     intervals: list of intervals (l, r) as open intervals
   """
   # Seed with several disjoint unit intervals to promote early overlap coupling
   T = [(seed_lo, seed_lo + 1.0 * seed_scale),
        (seed_lo + 2.0 * seed_scale, seed_lo + 3.0 * seed_scale),
        (seed_lo + 4.0 * seed_scale, seed_lo + 5.0 * seed_scale),
        (seed_lo + 6.0 * seed_scale, seed_lo + 7.0 * seed_scale)]
 
   # A small bank of four-interval gadgets (templates)
   templates = [
     # Template A: original pattern
     [(1, 5), (12, 16), (4, 9), (8, 13)],
     # Template B: shifted
     [(0.5, 4.5), (11, 15), (3.5, 8.5), (7, 12)],
     # Template C: tighter internal overlaps
     [(1, 4), (6, 9), (3, 7), (9, 13)],
     # Template D: staggered caps
     [(2, 6), (7, 11), (0, 3), (10, 14)]
   ]
 
   # Deterministic cycle of start-patterns (each is a tuple of starts)
   start_patterns = [
     (2, 6, 10, 14),                 # compact 4-wave
     (2, 4, 6, 8, 10, 12, 14, 16),   # dense 8-wave
     (2, 5, 8, 11, 14, 17, 20),      # staggered 7-wave
   ]
 
   for round_idx in range(rounds):
     lo = min(l for l, r in T)
     hi = max(r for l, r in T)
     delta = hi - lo
     if delta <= 0:
       delta = 1.0  # safety
 
-    S = []
-
     # pick deterministic pattern/template for this round
     starts = list(start_patterns[round_idx % len(start_patterns)])
     template = templates[round_idx % len(templates)]
 
-    # Build translated copies with alternating inner order to hamper color reuse
+    # Build translated copies as blocks with alternating inner order
+    blocks = []
     for idx, start in enumerate(starts):
-      base = T if (idx % 2 == 0) else list(reversed(T))
-      S += [(delta * start + l - lo, delta * start + r - lo) for l, r in base]
+      src = T if (idx % 2 == 0) else list(reversed(T))
+      base = delta * start - lo
+      block = [(l + base, r + base) for (l, r) in src]
+      blocks.append(block)
 
-      # light bridging between consecutive blocks to couple colors
-      if idx + 1 < len(starts):
-        nxt = starts[idx + 1]
-        S.append((delta * (start + 0.5), delta * (nxt + 0.5)))
+    # Interleave blocks round-robin to maximize cross-block interference
+    S = []
+    maxlen = max(len(b) for b in blocks) if blocks else 0
+    order = list(range(len(blocks)))
+    if round_idx % 2 == 1:
+      order = order[::-1]
+    for i in range(maxlen):
+      for bidx in order:
+        if i < len(blocks[bidx]):
+          S.append(blocks[bidx][i])
+
+    # light bridging between consecutive blocks to couple colors
+    for i in range(len(starts) - 1):
+      s = starts[i]
+      nxt = starts[i + 1]
+      S.append((delta * (s + 0.45), delta * (nxt + 0.35)))
+
+    # Kierstead–Trotter style connectors (caps and crosses) derived from first four starts
+    if len(starts) >= 4:
+      s0, s1, s2, s3 = starts[0], starts[1], starts[2], starts[3]
+      connectors = [
+        (delta * (s0 - 1), delta * (s1 - 1)),  # left cap
+        (delta * (s2 + 2), delta * (s3 + 2)),  # right cap
+        (delta * (s0 + 2), delta * (s2 - 1)),  # cross 1
+        (delta * (s1 + 2), delta * (s3 - 1)),  # cross 2
+      ]
+      S.extend(connectors)
 
     # Add the chosen template intervals scaled by delta
     S += [(delta * a, delta * b) for (a, b) in template]
 
     # Add sparse caps to push color usage without large omega
-    max_start = max(starts)
-    caps_step = max(3, int(max(3, max_start) // 4))
+    max_start = max(starts) if starts else 0
+    caps_step = max(3, int(max(3, max_start) // 4)) if max_start > 0 else 3
     for j in range(2, max_start, caps_step):
-      # small caps around positions to lightly pressure color usage
-      S.append((delta * (j - 0.5), delta * (j + 1.0 + 0.5)))
+      S.append((delta * (j - 0.5), delta * (j + 1.5)))
 
     T = S
+
+  # Two-phase enhancement: a small delta/2 micro-phase with connectors and blockers
+  if T:
+    lo = min(l for l, r in T)
+    hi = max(r for l, r in T)
+    delta = max(1.0, hi - lo)
+    d2 = max(1.0, delta / 2.0)
+    # KT connectors at half scale using a fixed mid-start pattern
+    s0, s1, s2, s3 = 3, 7, 11, 15
+    micro = [
+      (d2 * (s0 - 1), d2 * (s1 - 1)),
+      (d2 * (s2 + 2), d2 * (s3 + 2)),
+      (d2 * (s0 + 2), d2 * (s2 - 1)),
+      (d2 * (s1 + 2), d2 * (s3 - 1)),
+      # preload blockers near domain ends
+      (lo + 0.06 * d2, lo + 0.12 * d2),
+      (hi - 0.12 * d2, hi - 0.06 * d2),
+      # mid-span caps to further couple colors across layers
+      (2.5 * d2, 6.5 * d2),
+      (9.5 * d2, 13.5 * d2),
+    ]
+    # append micro-phase at the end to force new colors late
+    T = T + micro
 
   return T
 
 # EVOLVE-BLOCK-END
 
 def run_experiment(**kwargs):
   """Main called by evaluator"""
   return construct_intervals()