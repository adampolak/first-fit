--- a/original.py
+++ b/original.py
@@ -1,347 +1,276 @@
 # EVOLVE-BLOCK-START
 
 def construct_intervals(seed_count=1):
   """
-  Construct a sequence of intervals on the real line, in the order presented to FirstFit,
-  engineered to drive up FirstFit's color usage while keeping the maximum clique (omega) <= ~10.
-
-  Interface compatibility:
-    - Accepts seed_count (unused by evaluator, but supported).
-    - Returns a list of (l, r) integer tuples with r > l (open intervals).
+  Deterministic KT-style spine with parity interleaving, dual micro-phases,
+  and CAP-aware long-range connectors to raise FirstFit while keeping omega ~<= 10.
+
+  Inputs:
+    seed_count (int): retained for interface compatibility; nonnegative.
+  Returns:
+    List[(l, r)] of open intervals with integer endpoints and r > l.
   """
+  # Hard capacity to satisfy evaluator constraint
   CAP = 9800
 
-  # Rotating start templates (Kierstead–Trotter style)
-  template_bank = [
-    (2, 6, 10, 14),  # classic KT
-    (1, 5, 9, 13),   # left-shifted
-    (3, 7, 11, 15),  # right-shifted
-    (4, 8, 12, 16),  # stretched-right
+  # Deterministic base seed (no RNG used; just a constant for future-proofing)
+  BASE_SEED = 1337
+
+  # Start templates (Kierstead–Trotter inspired)
+  template_bank_primary = [
+    (2, 6, 10, 14),  # T1: classic KT
+    (1, 5, 9, 13),   # T2: left-shifted
+    (3, 7, 11, 15),  # T3: right-shifted
+    (4, 8, 12, 16),  # T4: stretched-right
   ]
-
-  # Seed: single unit interval (multi-seed support capped defensively)
+  # Auxiliary templates used selectively to add diversity without densifying too much
+  template_bank_aux = [
+    (2, 4, 8, 12),   # inner-left biased
+    (3, 5, 9, 13),   # gentle left pack
+    (1, 7, 11, 15),  # wide skew
+  ]
+
+  # Seed
   if seed_count <= 1:
     T = [(0, 1)]
   else:
+    # Multiple disjoint seeds; keep small to avoid early omega jump
+    seeds = min(4, max(1, int(seed_count)))
     step = 3
-    seeds = min(4, max(1, int(seed_count)))
     T = [(i * step, i * step + 1) for i in range(seeds)]
 
+  # Helpers
   def _span_delta(current_T):
     lo = min(l for l, r in current_T)
     hi = max(r for l, r in current_T)
     delta = hi - lo
     if delta <= 0:
       delta = 1
     return lo, hi, delta
 
-  def _append_connectors(S, starts, delta):
-    # Four classic connectors that propagate color pressure without large omega jumps
+  def _append_kt_connectors(S, starts, delta):
     s0, s1, s2, s3 = starts
     S.append(((s0 - 1) * delta, (s1 - 1) * delta))  # left cap
     S.append(((s2 + 2) * delta, (s3 + 2) * delta))  # right cap
     S.append(((s0 + 2) * delta, (s2 - 1) * delta))  # cross 1
     S.append(((s1 + 2) * delta, (s3 - 1) * delta))  # cross 2
 
-  def _apply_round(current_T, starts, do_interleave=False, reverse_order=False):
+  def _append_long_range_connectors(S, starts, delta, budget=2):
+    # Deterministic long-range connectors spanning 4–6 delta to enhance cross-scale coupling
+    # Anchored to the extremal starts. Keep small (<= 2) to avoid omega inflation.
+    s0, s1, s2, s3 = starts
+    cands = [
+      ((s0 + 4) * delta, (s3 + 4) * delta),
+      ((s0 + 5) * delta, (s3 + 6) * delta),
+      ((s1 + 4) * delta, (s2 + 5) * delta),
+    ]
+    added = 0
+    for a, b in cands:
+      if b > a:
+        S.append((a, b))
+        added += 1
+        if added >= max(0, int(budget)):
+          break
+
+  def _apply_round(current_T, starts, do_interleave=False, reverse_order=False, add_lr=False):
     lo, hi, delta = _span_delta(current_T)
 
     # Build four translated blocks
     blocks = []
     for s in starts:
       base = s * delta - lo
       block = [(l + base, r + base) for (l, r) in current_T]
       blocks.append(block)
 
-    # Compose S with chosen policy
+    # Assemble S
     S = []
     if do_interleave:
       order = list(range(4))
       if reverse_order:
         order.reverse()
       maxlen = max(len(b) for b in blocks)
       for i in range(maxlen):
         for idx in order:
           blk = blocks[idx]
           if i < len(blk):
             S.append(blk[i])
     else:
       seq_blocks = list(reversed(blocks)) if reverse_order else blocks
       for blk in seq_blocks:
         S.extend(blk)
 
-    _append_connectors(S, starts, delta)
+    # Append classic KT connectors
+    _append_kt_connectors(S, starts, delta)
+
+    # Optional long-range connectors (kept conservative)
+    if add_lr:
+      _append_long_range_connectors(S, starts, delta, budget=2)
+
     return S
 
-  # Stage 1: Six KT-style rounds with parity-based interleaving
-  for ridx in range(6):
-    starts = template_bank[ridx % len(template_bank)]
-    do_interleave = (ridx % 2 == 0)          # even: interleave
-    reverse_order = (ridx % 2 == 1)          # odd: reverse sequential
-    T = _apply_round(T, starts, do_interleave=do_interleave, reverse_order=reverse_order)
+  # Predictive size accounting: KT growth per round size -> 4*size + 4
+  def _can_advance_round(sz):
+    return (4 * sz + 4) <= CAP
+
+  # Stage 1: spine assembly with deterministic parity interleaving
+  round_idx = 0
+  while _can_advance_round(len(T)) and round_idx < 7:
+    # Primary templates rotate every round; every third round uses an auxiliary template deterministically
+    if round_idx % 3 == 2:
+      starts = template_bank_aux[(BASE_SEED + round_idx) % len(template_bank_aux)]
+    else:
+      starts = template_bank_primary[(BASE_SEED + round_idx) % len(template_bank_primary)]
+
+    # Parity policy: interleave on even rounds; reverse order on odd rounds
+    do_interleave = (round_idx % 2 == 0)
+    reverse_order = (round_idx % 2 == 1)
+
+    # Add long-range connectors only on rounds 2 and 5 (0-based), conservative gating
+    add_lr = (round_idx in (2, 5))
+
+    T = _apply_round(T, starts, do_interleave=do_interleave, reverse_order=reverse_order, add_lr=add_lr)
     if len(T) >= CAP:
-      return T[:CAP]
-
-  # Micro-phase A: a few long caps near the global span to mix late colors
-  if len(T) < CAP - 8:
-    lo, hi, delta = _span_delta(T)
-    def cap_at(a_frac, b_frac):
-      L = lo + max(1, int(round(a_frac * delta)))
-      R = lo + max(1, int(round(b_frac * delta)))
-      if R <= L:
-        R = L + 1
-      return (L, R)
-    caps = [cap_at(0.08, 0.60), cap_at(0.25, 0.75), cap_at(0.75, 0.92)]
-    room = CAP - len(T)
-    if room > 0:
-      caps = caps[:room]
-      # Insert near the tail to avoid disrupting early structure
-      for i, iv in enumerate(caps):
-        pos = len(T) - (i * 2 + 1)
-        if pos < 0:
-          T.append(iv)
-        else:
-          T.insert(pos, iv)
-
-  if len(T) >= CAP - 16:
-    return T[:CAP]
-
-  # Helper: thin evenly-spaced seed from T
+      T = T[:CAP]
+      break
+    round_idx += 1
+
+  # Early return if near capacity
+  if len(T) >= CAP - 8:
+    # Normalize to integer open intervals
+    return _normalize_intervals(T, CAP)
+
+  # Micro-phase A: fractional-window thin round (primary windows)
   def _thin_seed(current_T, max_seed):
     n = len(current_T)
-    if n == 0 or max_seed <= 0:
+    if n <= 0 or max_seed <= 0:
       return []
     step = max(1, n // max_seed)
     return current_T[::step][:max_seed]
 
-  # Stage 2: delta2-driven micro rounds using thin evenly-spaced seeds
-  def _build_micro_delta_round(current_T, budget, iter_id=0, alt=False):
+  def _build_micro(current_T, budget, windows, seed_cap, alt_tag=0, add_lr=False):
     if not current_T or budget <= 8:
       return []
 
     glo = min(l for l, r in current_T)
     ghi = max(r for l, r in current_T)
     G = max(1, ghi - glo)
 
-    # Thin seed (slightly larger for alt to strengthen mixing)
-    base_seed = max(8, min(32, len(current_T) // 300))
-    seed_sz = base_seed if not alt else max(8, min(40, len(current_T) // 250))
+    # Thin seed
+    seed_sz = max(8, min(seed_cap, max(8, len(current_T) // 280)))
     U = _thin_seed(current_T, seed_sz)
     if not U:
       return []
-
     ulo = min(l for l, r in U)
 
-    # Windows with small shifts on primary; distinct family on alt
-    if not alt:
-      shift = (iter_id % 3) * 0.02
-      window_fracs = [
-        (0.12 + shift, 0.22 + shift),
-        (0.35 + shift, 0.45 + shift),
-        (0.58 + shift, 0.68 + shift),
-        (0.80 + shift, 0.90 + shift),
-      ]
-      window_fracs = [(max(0.05, min(0.90, a)), max(0.10, min(0.95, b))) for (a, b) in window_fracs]
-    else:
-      window_fracs = [(0.05, 0.15), (0.28, 0.38), (0.60, 0.70), (0.82, 0.92)]
-
+    # Blocks translated into windows
     blocks = []
-    for (fa, fb) in window_fracs:
+    for (fa, fb) in windows:
+      fa = max(0.05, min(0.90, fa))
+      fb = max(0.10, min(0.95, fb))
       win_lo = glo + int(round(fa * G))
       base = win_lo - ulo
       block = [(l + base, r + base) for (l, r) in U]
-      tag = iter_id if not alt else (iter_id + 1)
-      # Parity-breaking reversal to reduce symmetry
-      if ((int(round(fa * 100)) // 5) + tag) % 2 == 1:
+      # Parity-breaking reversal
+      tag = alt_tag + int(round(fa * 100)) // 5
+      if tag % 2 == 1:
         block = list(reversed(block))
       blocks.append(block)
 
-    # Interleave policy depends on tag parity
+    # Interleave micro-blocks; reverse block order for odd alt_tag
     micro = []
-    tag = iter_id if not alt else (iter_id + 1)
     order = list(range(len(blocks)))
-    if tag % 2 == 1:
+    if (alt_tag % 2) == 1:
       order.reverse()
     maxlen = max(len(b) for b in blocks)
     for i in range(maxlen):
       for idx in order:
         blk = blocks[idx]
         if i < len(blk):
           micro.append(blk[i])
 
-    # Fractional-span connectors (KT analog) + long-range cross on alt
+    # Add fractional connectors (KT analog)
     micro_connectors = [
       (glo + int(round(0.08 * G)), glo + int(round(0.30 * G))),
       (glo + int(round(0.60 * G)), glo + int(round(0.92 * G))),
       (glo + int(round(0.26 * G)), glo + int(round(0.56 * G))),
       (glo + int(round(0.44 * G)), glo + int(round(0.78 * G))),
     ]
-    if alt:
-      micro_connectors.append((glo + int(round(0.18 * G)), glo + int(round(0.84 * G))))
     for a, b in micro_connectors:
       if b > a:
         micro.append((a, b))
 
+    # Optional long-range connector at the micro scale
+    if add_lr:
+      lr = (glo + int(round(0.18 * G)), glo + int(round(0.84 * G)))
+      if lr[1] > lr[0]:
+        micro.append(lr)
+
+    # Trim by budget
     if len(micro) > budget:
       micro = micro[:budget]
     return micro
 
-  # Execute two primary micro rounds, then one alt round (capacity-guarded)
-  for iter_id in range(2):
-    room = CAP - len(T)
-    if room <= 8:
-      break
-    micro = _build_micro_delta_round(T, room, iter_id=iter_id, alt=False)
-    if not micro:
-      break
-    if len(micro) > room:
-      micro = micro[:room]
-    T.extend(micro)
-
+  # Windows for two deterministic micro-phases
+  window_fracs_A = [(0.12, 0.22), (0.35, 0.45), (0.58, 0.68), (0.80, 0.90)]
+  window_fracs_B = [(0.06, 0.14), (0.28, 0.38), (0.54, 0.64), (0.78, 0.88)]
+
+  # Execute Micro A then Micro B, each once, capacity-guarded
   room = CAP - len(T)
   if room > 8:
-    micro_alt = _build_micro_delta_round(T, room, iter_id=2, alt=True)
-    if micro_alt:
-      avail = CAP - len(T)
-      if len(micro_alt) > avail:
-        micro_alt = micro_alt[:avail]
-      T.extend(micro_alt)
-
-  # Stage 3: pin-shrinking micro-phase (controls omega via short intervals)
-  if len(T) < CAP - 8:
-    glo2 = min(l for l, r in T)
-    ghi2 = max(r for l, r in T)
-    G2 = max(1, ghi2 - glo2)
-    seed_sz2 = max(8, min(24, len(T) // 400))
-    U2 = _thin_seed(T, seed_sz2)
-    if U2:
-      ulo2 = min(l for l, r in U2)
-      eps = max(1, G2 // 512)
-      windows2 = [(0.05, 0.15), (0.28, 0.38), (0.60, 0.70), (0.82, 0.92)]
-      blocks2 = []
-      for (fa, fb) in windows2:
-        win_lo2 = glo2 + int(round(fa * G2))
-        base2 = win_lo2 - ulo2
-        block = []
-        for idx, (l, r) in enumerate(U2):
-          mid = (l + r) // 2
-          L = mid + base2 - (eps // 2) + (idx % 3)
-          R = L + eps
-          if R > L:
-            block.append((L, R))
-        blocks2.append(block)
-
-      micro2 = []
-      if blocks2:
-        maxlen2 = max(len(b) for b in blocks2)
-        order2 = [3, 1, 0, 2]
-        for i in range(maxlen2):
-          for idx in order2:
-            blk = blocks2[idx]
-            if i < len(blk):
-              micro2.append(blk[i])
-
-      # Two short cap-pins to tie windows without inflating omega
-      caps2 = [
-        (glo2 + int(round(0.09 * G2)), glo2 + int(round(0.09 * G2)) + eps),
-        (glo2 + int(round(0.64 * G2)), glo2 + int(round(0.64 * G2)) + eps),
-      ]
-      for a, b in caps2:
-        if b > a:
-          micro2.append((a, b))
-
-      room2 = CAP - len(T)
-      if room2 > 0:
-        if len(micro2) > room2:
-          micro2 = micro2[:room2]
-        T.extend(micro2)
-
-  # Stage 4 (new): tower-and-cap micro-phase
-  # Build staggered short towers across five separated windows, then add a few long caps
-  # that each overlap one level from every tower. At any point, only a local tower pin
-  # is active with the cap, mitigating omega growth.
-  if len(T) < CAP - 12:
-    glo3 = min(l for l, r in T)
-    ghi3 = max(r for l, r in T)
-    G3 = max(1, ghi3 - glo3)
-
-    # Thin seed for pin positioning (moderate size)
-    U3 = _thin_seed(T, max(12, min(36, len(T) // 300)))
-    if U3:
-      ulo3 = min(l for l, r in U3)
-      eps3 = max(1, G3 // 768)  # very short pins
-
-      # Five windows for five towers; each builds 3 staggered pin levels
-      towers = [(0.10, 0.18), (0.28, 0.36), (0.46, 0.54), (0.64, 0.72), (0.82, 0.90)]
-      levels = 3
-      tower_blocks = []
-      for t_idx, (fa, fb) in enumerate(towers):
-        win_lo3 = glo3 + int(round(fa * G3))
-        base3 = win_lo3 - ulo3
-        block = []
-        for idx, (l, r) in enumerate(U3):
-          mid = (l + r) // 2
-          # three levels staggered slightly to avoid co-location
-          for lv in range(levels):
-            jitter = (idx + lv + t_idx) % 4
-            L = mid + base3 - (eps3 // 2) + jitter + lv  # increasing shift by level
-            R = L + eps3
-            if R > L:
-              block.append((L, R))
-        tower_blocks.append(block)
-
-      # Interleave towers round-robin to distribute local density
-      tower_phase = []
-      if tower_blocks:
-        maxlen3 = max(len(b) for b in tower_blocks)
-        order3 = [0, 2, 4, 1, 3]
-        for i in range(maxlen3):
-          for idx in order3:
-            blk = tower_blocks[idx]
-            if i < len(blk):
-              tower_phase.append(blk[i])
-
-      # Add a few long caps that span across the tower windows but avoid edges
-      caps3 = [
-        (glo3 + int(round(0.15 * G3)), glo3 + int(round(0.45 * G3))),
-        (glo3 + int(round(0.38 * G3)), glo3 + int(round(0.70 * G3))),
-        (glo3 + int(round(0.60 * G3)), glo3 + int(round(0.88 * G3))),
-      ]
-      for a, b in caps3:
-        if b > a:
-          tower_phase.append((a, b))
-
-      room3 = CAP - len(T)
-      if room3 > 0 and tower_phase:
-        if len(tower_phase) > room3:
-          tower_phase = tower_phase[:room3]
-        T.extend(tower_phase)
-
-  # Final capacity guard
-  if len(T) > CAP:
-    T = T[:CAP]
-
-  # Normalize and ensure integer endpoints with r > l
+    microA = _build_micro(T, room, window_fracs_A, seed_cap=36, alt_tag=(BASE_SEED % 2), add_lr=False)
+    if microA:
+      if len(microA) > room:
+        microA = microA[:room]
+      T.extend(microA)
+
+  room = CAP - len(T)
+  if room > 8:
+    microB = _build_micro(T, room, window_fracs_B, seed_cap=40, alt_tag=((BASE_SEED + 1) % 4), add_lr=True)
+    if microB:
+      if len(microB) > room:
+        microB = microB[:room]
+      T.extend(microB)
+
+  # Post-micro long-range connectors across the global span (very few, CAP-aware)
+  if len(T) < CAP - 4:
+    lo, hi, delta = _span_delta(T)
+    # Deterministic cross-scale caps; 2 pieces, conservative
+    post_caps = [
+      (lo + max(1, int(round(0.15 * delta))), lo + max(1, int(round(0.60 * delta)))),
+      (lo + max(1, int(round(0.40 * delta))), lo + max(1, int(round(0.85 * delta)))),
+    ]
+    add = []
+    for a, b in post_caps:
+      if b > a:
+        add.append((a, b))
+    room = CAP - len(T)
+    add = add[:room]
+    T.extend(add)
+
+  # Final capacity guard and normalization
+  return _normalize_intervals(T, CAP)
+
+
+# Utility: normalize to integer open intervals and cap length
+def _normalize_intervals(T, CAP):
   if not T:
     return []
   min_l = min(l for l, r in T)
   if min_l < 0:
     T = [(l - min_l, r - min_l) for (l, r) in T]
-
   intervals = []
   for (l, r) in T:
     li = int(l)
     ri = int(r)
     if ri <= li:
       ri = li + 1
     intervals.append((li, ri))
-
   if len(intervals) > CAP:
     intervals = intervals[:CAP]
   return intervals
 
 # EVOLVE-BLOCK-END
 
 def run_experiment(**kwargs):
   """Main called by evaluator"""
   return construct_intervals()