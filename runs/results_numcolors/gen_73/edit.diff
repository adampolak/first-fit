--- a/original.py
+++ b/original.py
@@ -1,232 +1,134 @@
 # EVOLVE-BLOCK-START
 
 from typing import List, Tuple
 
-# Basic helpers
-def max_overlap(intervals: List[Tuple[float, float]]) -> int:
-    """Compute maximum number of intervals covering a point (open intervals).
-    Treat intervals as [l, r) for event counting determinism."""
-    events = []
-    for l, r in intervals:
-        # ensure well-formed
-        if r <= l:
-            r = l + 1e-6
-        events.append((l, 1))
-        events.append((r, -1))
-    events.sort()
-    cur = 0
-    mx = 0
-    for t, delta in events:
-        cur += delta
-        if cur > mx:
-            mx = cur
-    return mx
+def construct_intervals(max_intervals: int = 9800) -> List[Tuple[float, float]]:
+    """
+    Multi‐scale rotating‐template expansion for adversarial interval coloring.
+    A deterministic recursive construction inspired by Kierstead–Trotter and
+    augmented with multi‐interval seeds, rotating start patterns, and a small
+    fine‐scale micro‐phase to boost FirstFit usage while keeping omega ≤ 10.
+    """
+    # 1) PARAMETERS
+    TARGET_OMEGA = 10
+    DEPTH = 5                      # main rounds
+    MICRO_PHASE_DEPTH = 2          # fine‐scale rounds at end
+    SEED_BLOCKS = [                # multi‐interval seed (disjoint)
+        (0.0, 1.0), (2.0, 3.0),
+        (4.0, 5.0), (6.0, 7.0)
+    ]
+    # rotating start‐patterns (4‐block templates)
+    START_BANK = [
+        (2, 6, 10, 14),
+        (1, 5, 9, 13),
+        (3, 7, 11, 15),
+        (2, 4, 8, 12),
+        (2, 5, 8, 11),    # extra variant
+        (3, 6, 9, 12),    # extra variant
+    ]
+    # Four‐interval gadget templates
+    GADGETS = [
+        [(1,5),(12,16),(4,9),(8,13)],
+        [(0.5,4.5),(11,15),(3.5,8.5),(7,12)],
+        [(1,4),(6,9),(3,7),(9,13)],
+        [(2,6),(7,11),(0,3),(10,14)],
+    ]
 
-def simulate_firstfit(intervals: List[Tuple[float, float]]) -> List[int]:
-    """Simulate FirstFit coloring on given interval sequence (ordered).
-    Returns list of assigned colors (1-based)."""
-    n = len(intervals)
-    colors = [0] * n
-    # For each interval i, compute set of colors used by intervals j < i that overlap it
-    # naive O(n^2) approach; acceptable for n ~ few thousands
-    for i in range(n):
-        l_i, r_i = intervals[i]
-        used = set()
-        for j in range(i):
-            l_j, r_j = intervals[j]
-            # intervals are open; consider overlap if they share interior points
-            if not (r_j <= l_i or r_i <= l_j):
-                used.add(colors[j])
-        # find smallest positive integer not in used
-        c = 1
-        while c in used:
-            c += 1
-        colors[i] = c
-    return colors
+    # 2) HELPER: span & delta
+    def span_Delta(T: List[Tuple[float,float]]):
+        lo = min(l for l,r in T)
+        hi = max(r for l,r in T)
+        return lo, hi, max(hi-lo, 1.0)
 
-def competitive_ratio_stats(intervals: List[Tuple[float, float]]):
-    """Return (FF_colors, OPT_clique) for current sequence."""
-    colors = simulate_firstfit(intervals)
-    ff = max(colors) if colors else 0
-    opt = max_overlap(intervals)
-    return ff, opt
+    # 3) MAIN EXPANSION
+    T = list(SEED_BLOCKS)
+    for rd in range(DEPTH):
+        lo, hi, delta = span_Delta(T)
+        S: List[Tuple[float,float]] = []
+        # choose 4‐start pattern, rotating through bank
+        starts = START_BANK[rd % len(START_BANK)]
+        # optionally inject longer 6‐wave every other round
+        if rd % 2 == 1:
+            starts = START_BANK[(rd+2) % len(START_BANK)] + (START_BANK[(rd+3)%len(START_BANK)][0],)
+            starts = starts[:4]
 
-def canonicalize_interval(iv: Tuple[float, float]) -> Tuple[float, float]:
-    l, r = iv
-    if r <= l:
-        r = l + 1e-6
-    return (float(l), float(r))
+        # block cloning with alternating reversal
+        for bi, s in enumerate(starts):
+            base = T if ((rd+bi)%2==0) else list(reversed(T))
+            off = delta*s - lo
+            for (l,r) in base:
+                S.append((l+off, r+off))
+            # short bridge to next block
+            if bi+1 < len(starts):
+                n = starts[bi+1]
+                b_lo = delta*(s+0.3)
+                b_hi = b_lo + delta*0.2
+                S.append((b_lo,b_hi))
 
-def generate_candidates(existing: List[Tuple[float, float]],
-                        grid_step=5.0,
-                        lengths=(1.0, 2.0, 4.0),
-                        max_candidates=120):
-    """Deterministic candidate generation anchored to interesting positions.
-    - endpoints of existing intervals
-    - coarse grid
-    Returns a list of candidate intervals (l, r) to test, deterministic order."""
-    points = set()
-    # include endpoints
-    for l, r in existing:
-        points.add(l)
-        points.add(r)
-        # midpoints to aim inside existing ranges
-        points.add((l + r) / 2.0)
-    # add grid points spanning the current domain
-    if existing:
-        min_l = min(l for l, r in existing)
-        max_r = max(r for l, r in existing)
-    else:
-        min_l, max_r = 0.0, grid_step * 10.0
-    # extend a bit to allow growth
-    min_l -= grid_step * 2
-    max_r += grid_step * 2
-    # add grid positions
-    k = int((max_r - min_l) / grid_step) + 1
-    for i in range(k + 1):
-        points.add(min_l + i * grid_step)
-    pts_sorted = sorted(points)
-    candidates = []
-    # deterministic scanning: try placing intervals centered at these points with given lengths
-    for center in pts_sorted:
-        for L in lengths:
-            l = center - 0.5 * L
-            r = center + 0.5 * L
-            iv = canonicalize_interval((l, r))
-            candidates.append(iv)
-            if len(candidates) >= max_candidates:
-                return candidates
-    return candidates
+        # place one 4‐interval gadget from bank
+        gadget = GADGETS[rd % len(GADGETS)]
+        for (a,b) in gadget:
+            S.append((delta*a, delta*b))
 
-def add_interval_greedy(seed: List[Tuple[float, float]],
-                        budget_total: int,
-                        target_opt: int = 10,
-                        max_steps: int = 2000):
-    """Adaptive greedy adversary:
-    At each step propose candidates and pick the one that maximizes FF/OPT (ratio),
-    subject to the global OPT <= target_opt. Stop when budget reached or no improving candidate.
-    """
-    intervals = list(seed)
-    best_ff, best_opt = competitive_ratio_stats(intervals)
-    best_ratio = (best_ff / best_opt) if best_opt > 0 else float(best_ff)
-    steps = 0
+        # micro‐gadget inside middle block
+        mid = starts[len(starts)//2]
+        micro = GADGETS[(rd+1)%len(GADGETS)]
+        for (a,b) in micro:
+            S.append((delta*(mid + 0.1*a), delta*(mid + 0.1*b)))
 
-    # To encourage progression, prefer candidates that increase FF or ratio.
-    while len(intervals) < budget_total and steps < max_steps:
-        steps += 1
-        # generate candidate pool deterministically
-        cand_pool = generate_candidates(intervals,
-                                        grid_step=max(1.0, max(1.0, (max((r for _, r in intervals), default=10.0) - min((l for l, _ in intervals), default=0.0)) / 40.0)),
-                                        lengths=(0.8, 1.5, 3.0, 6.0),
-                                        max_candidates=200)
-        # Evaluate candidates
-        best_local = None  # tuple (new_ratio, ff, opt, candidate)
-        # deterministic iteration order already from pool
-        for cand in cand_pool:
-            # skip duplicates or trivially overlapping exactly same as existing
-            if cand in intervals:
-                continue
-            trial = intervals + [cand]
-            opt_trial = max_overlap(trial)
-            if opt_trial > target_opt:
-                continue  # violates final OPT constraint
-            ff_trial = max(simulate_firstfit(trial)) if trial else 0
-            # compute ratio; if opt_trial==0 treat carefully
-            ratio = (ff_trial / opt_trial) if opt_trial > 0 else float(ff_trial)
-            # We prefer larger ratio; tie-break deterministically by smaller candidate center then smaller length
-            cand_center = (cand[0] + cand[1]) / 2.0
-            cand_len = cand[1] - cand[0]
-            key = (ratio, ff_trial, -opt_trial, -cand_len, -cand_center)
-            # store best_local in terms of ratio, break ties deterministically
-            if best_local is None or key > best_local[0]:
-                best_local = (key, ratio, ff_trial, opt_trial, cand)
-        # if no valid candidate found, break
-        if best_local is None:
-            break
-        # if best_local does not improve ratio significantly, we still might accept if it increases FF
-        chosen = best_local[4]
-        chosen_ratio = best_local[1]
-        chosen_ff = best_local[2]
-        chosen_opt = best_local[3]
+        # tiny caps to nudge FF upward
+        max_s = max(starts)
+        for j in range(2):
+            c_lo = delta*(max_s + 0.2 + j*0.5)
+            c_hi = c_lo + delta*0.05 + 0.1
+            S.append((c_lo,c_hi))
 
-        # acceptance criteria:
-        # accept if ratio improves at least slightly, or ff increases and opt doesn't increase
-        improve = False
-        if chosen_ratio > best_ratio + 1e-9:
-            improve = True
-        elif chosen_ff > best_ff and chosen_opt <= best_opt:
-            improve = True
-
-        # also accept some neutral moves early to seed structure (if intervals very small)
-        if not improve and len(intervals) < max(30, budget_total // 20):
-            improve = True
-
-        if not improve:
-            # no beneficial move found, stop
+        T = S
+        if len(T) > max_intervals//2:
             break
 
-        # commit chosen
-        intervals.append(chosen)
-        best_ff = chosen_ff
-        best_opt = chosen_opt
-        best_ratio = chosen_ratio
+    # 4) MICRO‐PHASE FINE‐SCALE
+    for mp in range(MICRO_PHASE_DEPTH):
+        lo, hi, delta = span_Delta(T)
+        delta2 = max(1.0, delta/4.0)
+        S = []
+        # fine 3‐wave patterns
+        fine_patterns = [(1,4,7),(2,5,8)]
+        starts2 = fine_patterns[mp % len(fine_patterns)]
+        for i,s in enumerate(starts2):
+            base = T if (i%2==0) else list(reversed(T))
+            off = delta2*s - lo
+            scale = delta2/delta
+            for (l,r) in base:
+                S.append(((l-lo)*scale+off, (r-lo)*scale+off))
+            # tiny fine bridge
+            if i+1 < len(starts2):
+                b_lo = delta2*(s+0.2)
+                b_hi = b_lo + delta2*0.1
+                S.append((b_lo,b_hi))
+        # one fine cap coupling ends
+        S.append((delta2*(starts2[0]+0.3), delta2*(starts2[-1]-0.3)))
+        T = S
+        if len(T) > max_intervals:
+            break
 
-    return intervals
-
-def construct_intervals(rounds=1, seed_lo=0.0, seed_scale=1.0, budget=2000):
-    """
-    Construct adversarial sequence by greedy, simulation-driven search.
-    - rounds, seed params preserved for API compatibility (not heavily used here).
-    - budget: max number of intervals to produce (keeps under global limits).
-    Returns list of (l, r) intervals (open).
-    """
-    # seed: a small structured beginning that encourages color fragmentation:
-    # create a few short overlapping cliques staggered in time.
-    seed = []
-    base = seed_lo
-    # create 6 small cliques of size 3..6 (but keep global OPT <= 10)
-    clique_sizes = [3, 4, 5, 3, 5, 4]
-    offset = 0.0
-    for k in clique_sizes:
-        # all k intervals overlap at center offset + 0.5
-        center = offset + 0.5
-        span = 1.0 + 0.2 * k
-        for i in range(k):
-            # slightly jitter endpoints deterministically
-            shift = (i * 0.12)
-            l = center - span / 2.0 + shift
-            r = center + span / 2.0 + shift
-            seed.append(canonicalize_interval((l, r)))
-        offset += span * 0.9 + 0.5
-
-    # ensure seed respects OPT <= 10
-    if max_overlap(seed) > 10:
-        # fallback: trim until OK (deterministic trimming)
-        while max_overlap(seed) > 10 and seed:
-            seed.pop()
-
-    # run adaptive greedy extension
-    intervals = add_interval_greedy(seed, budget_total=budget, target_opt=10, max_steps=2500)
-
-    # final normalization: shift to non-negative and round coordinates to modest precision
-    if not intervals:
+    # 5) TRUNCATE & NORMALIZE
+    if not T:
         return []
-    min_l = min(l for l, r in intervals)
+    # shift to non‐negative
+    min_l = min(l for l,r in T)
     if min_l < 0:
-        intervals = [(l - min_l, r - min_l) for l, r in intervals]
-
-    # final defensive rounding to make intervals look nicer
-    final = []
-    for l, r in intervals:
-        # ensure at least tiny positive length
-        if r <= l + 1e-9:
+        T = [(l-min_l, r-min_l) for (l,r) in T]
+    # round & enforce length ≥ ε
+    final: List[Tuple[float,float]] = []
+    for (l,r) in T[:max_intervals]:
+        if r <= l+1e-6:
             r = l + 1e-3
-        # round to 6 decimals
-        final.append((round(float(l), 6), round(float(r), 6)))
+        final.append((round(l,6), round(r,6)))
     return final
 
 # EVOLVE-BLOCK-END
 
 def run_experiment(**kwargs):
   """Main called by evaluator"""
   return construct_intervals()