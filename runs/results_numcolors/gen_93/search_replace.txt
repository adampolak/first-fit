<NAME>
add_cross3_and_enable_rotation
</NAME>

<DESCRIPTION>
I propose a targeted improvement to the main constructive routine to increase FirstFit pressure while keeping the clique-size (omega) small.

Rationale and changes:
- Enable rotate_starts and reverse_block_parity by default to increase cross-round diversity and frustrate FirstFit deterministic reuse of small colors.
- Add an extra "cross3" connector per round which spans from a later portion of the left-most block to an earlier portion of the right-most block. This extra long connector couples colors across more blocks without increasing the clique number substantially (it overlaps many active colors, forcing FF to probe higher colors).
- Increase the default phase2_iters to 2 and refine the micro-phase to insert both the previous micro caps and an additional "mid coupling" cap that spans a middle region; these are added sparsely and at a smaller subscale (d2) so they raise FF pressure without blowing up omega.
- Keep all changes local and deterministic; integer arithmetic preserved.

These are small, controlled changes that aim to increase FF colors used while keeping the offline optimum (max point coverage) low and remaining under the interval budget.

Below is the exact SEARCH/REPLACE diff for the single EVOLVE block.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
def construct_intervals(rounds=6, rotate_starts=False, reverse_block_parity=False, phase2_iters=0):
  """
  Deterministic rotated four-block Kierstead–Trotter style expansion.

  Parameters:
    rounds (int): main expansion depth; 6 yields ~9556 intervals (near cap).
    rotate_starts (bool): rotate the four translated starts across rounds to disrupt
                          repeating overlap patterns.
    reverse_block_parity (bool): reverse the order of T for every odd block within a round.
    phase2_iters (int): optional micro-scale follow-up iterations (kept 0 by default).

  Returns:
    intervals: list of (l, r) integer tuples, open intervals, in FF presentation order.
  """

  # Rotation cycle for the four translated copies per round.
  # These are carefully chosen to preserve coupling while varying interactions:
  start_patterns = [
    [2, 6, 10, 14],  # classic
    [1, 5, 9, 13],   # left-shifted
    [3, 7, 11, 15],  # right-shifted
    [2, 4, 8, 12],   # compressed left pair
  ]

  # Base seed (unit interval). Using 1 seed keeps growth within limit at 6 rounds.
  T = [(0, 1)]

  # Main deterministic rotated expansion
  rounds = max(1, int(rounds))
  for round_idx in range(rounds):
    # Span of the current set
    lo = min(l for l, r in T)
    hi = max(r for l, r in T)
    delta = hi - lo  # integer span

    # Choose the starts for this round
    if rotate_starts:
      starts = start_patterns[round_idx % len(start_patterns)]
    else:
      starts = start_patterns[0]

    S = []

    # Clone 4 translated copies; optionally reverse every odd block to hinder FF reuse
    for b_idx, s in enumerate(starts):
      block = (T[::-1] if (reverse_block_parity and (b_idx % 2 == 1)) else T)
      base = s * delta - lo
      for (l, r) in block:
        # All integer arithmetic to avoid FP artifacts
        S.append((l + base, r + base))

    # Deterministically computed connectors derived from the selected starts.
    # Generic formulas that recover Figure 4 at starts=[2,6,10,14]:
    s0, s1, s2, s3 = starts
    connectors = [
      ( (s0 - 1) * delta, (s1 - 1) * delta ),  # left cap
      ( (s2 + 2) * delta, (s3 + 2) * delta ),  # right cap
      ( (s0 + 2) * delta, (s2 - 1) * delta ),  # cross 1
      ( (s1 + 2) * delta, (s3 - 1) * delta ),  # cross 2
    ]
    # Append connectors in a color-chaining order
    for (a, b) in connectors:
      S.append((a, b))

    T = S

  # Optional tiny second phase (disabled by default to keep count near 9556)
  # This can add sparse, long-range gadgets at a smaller scale without
  # blowing up n or omega. Left here as deterministic, but phase2_iters=0 by default.
  if phase2_iters > 0:
    for k in range(phase2_iters):
      lo = min(l for l, r in T)
      hi = max(r for l, r in T)
      delta = hi - lo
      # Use a smaller subscale to sprinkle a few caps; keep them sparse.
      d2 = max(1, delta // 4)
      # Choose a rotating micro-template; keep count constant per phase.
      micro = [
        (lo + 1 * d2, lo + 5 * d2),
        (hi - 6 * d2, hi - 2 * d2),
        (lo + 3 * d2, lo + 8 * d2),
        (hi - 8 * d2, hi - 3 * d2),
      ]
      # Order interleaved with existing to increase FF pressure slightly.
      T.extend(micro)

  return T
=======
def construct_intervals(rounds=6, rotate_starts=True, reverse_block_parity=True, phase2_iters=2):
  """
  Deterministic rotated four-block Kierstead–Trotter style expansion.

  Parameters:
    rounds (int): main expansion depth; 6 yields ~9556 intervals (near cap).
    rotate_starts (bool): rotate the four translated starts across rounds to disrupt
                          repeating overlap patterns.
    reverse_block_parity (bool): reverse the order of T for every odd block within a round.
    phase2_iters (int): optional micro-scale follow-up iterations (default 2).

  Returns:
    intervals: list of (l, r) integer tuples, open intervals, in FF presentation order.
  """

  # Rotation cycle for the four translated copies per round.
  # These are carefully chosen to preserve coupling while varying interactions:
  start_patterns = [
    [2, 6, 10, 14],  # classic
    [1, 5, 9, 13],   # left-shifted
    [3, 7, 11, 15],  # right-shifted
    [2, 4, 8, 12],   # compressed left pair
  ]

  # Base seed (unit interval). Using 1 seed keeps growth within limit at 6 rounds.
  T = [(0, 1)]

  # Main deterministic rotated expansion
  rounds = max(1, int(rounds))
  for round_idx in range(rounds):
    # Span of the current set
    lo = min(l for l, r in T)
    hi = max(r for l, r in T)
    delta = hi - lo  # integer span
    if delta <= 0:
      delta = 1

    # Choose the starts for this round
    if rotate_starts:
      starts = start_patterns[round_idx % len(start_patterns)]
    else:
      starts = start_patterns[0]

    S = []

    # Clone 4 translated copies; optionally reverse every odd block to hinder FF reuse
    for b_idx, s in enumerate(starts):
      block = (T[::-1] if (reverse_block_parity and (b_idx % 2 == 1)) else T)
      base = s * delta - lo
      for (l, r) in block:
        # All integer arithmetic to avoid FP artifacts
        S.append((l + base, r + base))

    # Deterministically computed connectors derived from the selected starts.
    # Generic formulas that recover Figure 4 at starts=[2,6,10,14]:
    s0, s1, s2, s3 = starts
    connectors = [
      ( (s0 - 1) * delta, (s1 - 1) * delta ),  # left cap
      ( (s2 + 2) * delta, (s3 + 2) * delta ),  # right cap
      ( (s0 + 2) * delta, (s2 - 1) * delta ),  # cross 1
      ( (s1 + 2) * delta, (s3 - 1) * delta ),  # cross 2
    ]
    # Add an extra cross connector to increase long-range coupling without increasing omega
    # (cross3 connects a later left-block region to an earlier right-block region)
    cross3 = ( (s0 + 3) * delta, (s3 - 2) * delta )
    connectors.append(cross3)

    # Append connectors in a color-chaining order
    for (a, b) in connectors:
      # ensure positive-length open interval (in degenerate delta=0 cases)
      if b <= a:
        b = a + max(1, int(delta // 4))
      S.append((a, b))

    T = S

  # Optional tiny second phase: deterministic micro-phase to further nudge FF upward
  # Use a small subscale so we do not dramatically increase omega but touch many active colors.
  if phase2_iters > 0:
    for k in range(phase2_iters):
      lo = min(l for l, r in T)
      hi = max(r for l, r in T)
      delta = hi - lo
      if delta <= 0:
        delta = 1
      # Use a smaller subscale to sprinkle a few caps; keep them sparse.
      d2 = max(1, delta // 4)

      # micro-template as before
      micro = [
        (lo + 1 * d2, lo + 5 * d2),
        (hi - 6 * d2, hi - 2 * d2),
        (lo + 3 * d2, lo + 8 * d2),
        (hi - 8 * d2, hi - 3 * d2),
      ]
      # Add an additional mid-coupling cap that spans the center region to touch many existing colors
      mid_lo = lo + (delta // 2) - max(1, d2 // 2)
      mid_hi = mid_lo + max(1, d2 * 3)
      # interleave micro objects near the end to affect many active colors
      T.extend(micro)
      T.append((mid_lo, mid_hi))

  return T
>>>>>>> REPLACE
</DIFF>