--- a/original.py
+++ b/original.py
@@ -1,141 +1,203 @@
 # EVOLVE-BLOCK-START
 
 def construct_intervals(max_intervals=9800,
                         depth=6,
                         rotate_starts=True,
                         reverse_block_parity=False,
                         interleave_blocks=False,
                         micro_phase=False):
   """
   Efficient, deterministic KT-style interval spine with optional micro-phase.
   Returns a list of (l, r) tuples representing open intervals in the order
   intended for input to FirstFit.
 
   Maintains compatibility with the original signature and output format.
   """
 
   # Cap on total intervals to respect the provided budget
   CAP = int(max_intervals)
 
   # Four-block start patterns (classic KT spine plus three alternates)
   start_patterns = [
     (2, 6, 10, 14),  # A
     (1, 5, 9, 13),   # B
     (3, 7, 11, 15),  # C
     (2, 4, 8, 12),   # D
   ]
 
   # Seed with a single small interval to maximize round count within CAP
   T = [(0, 1)]
 
   # Helper: round growth estimate to cap depth adaptively
   def round_next_size(sz):
     # Each round adds 4 copies plus 4 connectors: 4*sz + 4
     return 4 * sz + 4
 
   # Compute how many rounds can be safely performed within CAP
   depth = max(0, int(depth))
   size = len(T)
   allowed = 0
   for _ in range(depth):
     nxt = round_next_size(size)
     if nxt > CAP:
       break
     size = nxt
     allowed += 1
   depth = allowed
 
   # Build one KT-round given the current spine starts
   def apply_round(current_T, starts, do_interleave):
     # Span and delta
     lo = min(l for l, r in current_T)
     hi = max(r for l, r in current_T)
     delta = hi - lo
     if delta <= 0:
       delta = 1
 
+    # Optionally use a small multiplier to tighten translations when rotating templates.
+    # This tends to increase cross-block overlap and FirstFit pressure.
+    K = 2 if rotate_starts else 1
+
     # Translate current_T by each start; optionally reverse parity per block
     blocks = []
     for idx, s in enumerate(starts):
-      base = s * delta - lo
+      base = s * delta * K - lo
       if reverse_block_parity and (idx % 2 == 1):
         # reverse source T for this block to break symmetry
         src = current_T[::-1]
       else:
         src = current_T
       block = [(l + base, r + base) for (l, r) in src]
       blocks.append(block)
 
     # Merge blocks: interleave if requested, otherwise concatenate
     S = []
     if do_interleave:
       maxlen = max((len(b) for b in blocks), default=0)
       for i in range(maxlen):
         for blk in blocks:
           if i < len(blk):
             S.append(blk[i])
     else:
       for blk in blocks:
         S.extend(blk)
 
-    # Classic connectors derived from the first four starts
+    # Classic connectors derived from the first four starts plus a long-range cross4
     s0, s1, s2, s3 = starts[:4]
     connectors = [
       ((s0 - 1) * delta, (s1 - 1) * delta),  # left cap
       ((s2 + 2) * delta, (s3 + 2) * delta),  # right cap
       ((s0 + 2) * delta, (s2 - 1) * delta),  # cross 1
       ((s1 + 2) * delta, (s3 - 1) * delta),  # cross 2
+      ((s0 + 4) * delta, (s3 + 4) * delta),  # cross4: extra long-range coupling
     ]
     S.extend(connectors)
     return S
 
   # Main KT rounds with optional rotation and interleaving
   for round_idx in range(depth):
     if not T:
       break
     starts = start_patterns[round_idx % len(start_patterns)] if rotate_starts else start_patterns[0]
     T = apply_round(T, starts, do_interleave=bool(interleave_blocks))
     if len(T) > CAP:
       T = T[:CAP]
       break
 
-  # Optional micro-phase: small, sparse long caps added near the end
-  if micro_phase and T and len(T) + 2 <= CAP:
-    lo = min(l for l, r in T)
-    hi = max(r for l, r in T)
-    span = max(1, hi - lo)
-    d2 = max(1, span // 3)
-
-    micro_caps = [
-      (lo + 1 * d2, lo + 5 * d2),
-      (hi - 6 * d2, hi - 2 * d2),
-    ]
-    # Append near end to influence late FF without dense cliques
-    T.extend(micro_caps)
+  # Optional micro-phase: two-part delta2 micro extension + sparse caps.
+  # This is a guarded, thin-seed micro construction intended to increase FF
+  # without substantially raising the clique number.
+  if micro_phase and T and len(T) < CAP - 4:
+    # Part A: thin-seed delta2 micro-blocks with connectors
+    glo = min(l for l, r in T)
+    ghi = max(r for l, r in T)
+    G = max(1, int(ghi - glo))
+    delta2 = max(1, G // 4)
+
+    # Thin seed selection (evenly spaced sample of T)
+    def thin_seed(current_T, max_seed):
+      n = len(current_T)
+      if n == 0 or max_seed <= 0:
+        return []
+      step = max(1, n // max_seed)
+      return current_T[::step][:max_seed]
+
+    # limit seed size to keep micro small
+    seed_sz = min(64, max(8, len(T) // 150))
+    U = thin_seed(T, seed_sz)
+    if U:
+      ulo = min(l for l, r in U)
+      starts = start_patterns[0]  # use a stable template at micro scale
+      blocks = []
+      for s in starts:
+        base = s * delta2 - ulo
+        blk = [(l + base, r + base) for (l, r) in U]
+        blocks.append(blk)
+
+      # Interleave micro-blocks tightly to pressure FF
+      microA = []
+      maxlen = max(len(b) for b in blocks)
+      for i in range(maxlen):
+        for blk in blocks:
+          if i < len(blk):
+            microA.append(blk[i])
+
+      # Delta2-scale connectors including a cross3 and cross4 analogue
+      s0, s1, s2, s3 = starts[:4]
+      connectors = [
+        ((s0 - 1) * delta2 + glo, (s1 - 1) * delta2 + glo),
+        ((s2 + 2) * delta2 + glo, (s3 + 2) * delta2 + glo),
+        ((s0 + 2) * delta2 + glo, (s2 - 1) * delta2 + glo),
+        ((s1 + 2) * delta2 + glo, (s3 - 1) * delta2 + glo),
+        ((s0 + 3) * delta2 + glo, (s3 + 3) * delta2 + glo),  # cross3
+        ((s0 + 4) * delta2 + glo, (s3 + 4) * delta2 + glo),  # cross4 micro analogue
+      ]
+      microA.extend(connectors)
+
+      # Part B: a pair of sparse long caps to hit late FF choices
+      cap1 = (glo + max(1, delta2 // 3), glo + max(1, 5 * delta2))
+      cap2 = (ghi - max(1, 6 * delta2), ghi - max(1, 2 * delta2))
+
+      # Build final micro list and respect remaining capacity
+      micro = microA + [cap1, cap2]
+      # Ensure all micro intervals are valid (r>l) and numeric
+      micro_clean = []
+      for (a, b) in micro:
+        ai = int(round(a))
+        bi = int(round(b))
+        if bi <= ai:
+          bi = ai + 1
+        micro_clean.append((ai, bi))
+
+      room = CAP - len(T)
+      if room > 0:
+        if len(micro_clean) > room:
+          micro_clean = micro_clean[:room]
+        T.extend(micro_clean)
 
   # Normalize to non-negative integers, ensure valid intervals
   if not T:
       return []
 
   min_l = min(l for l, r in T)
   if min_l < 0:
     T = [(l - min_l, r - min_l) for (l, r) in T]
 
   intervals = []
   for (l, r) in T:
-    li = int(l)
-    ri = int(r)
+    li = int(round(l))
+    ri = int(round(r))
     if ri <= li:
       ri = li + 1
     intervals.append((li, ri))
 
   if len(intervals) > CAP:
     intervals = intervals[:CAP]
 
   return intervals
 
 # EVOLVE-BLOCK-END
 
 def run_experiment(**kwargs):
   """Main called by evaluator"""
   return construct_intervals()