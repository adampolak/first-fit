--- a/original.py
+++ b/original.py
@@ -1,86 +1,170 @@
 # EVOLVE-BLOCK-START
 
 def construct_intervals(seed_count=1):
   """
-  Construct a sequence of intervals of real line,
-  in the order in which they are presented to FirstFit,
-  so that it maximizes the number of colors used by FirstFit
-  divided by the maximum number of intervals that cover a single point
-
-  The initial implementation uses the construction from
-  Figure 4 in https://arxiv.org/abs/1506.00192
-
+  Construct a sequence of intervals on the real line, in the order presented to FirstFit,
+  to maximize FF colors divided by the clique number.
   Returns:
-    intervals: list of tuples, each tuple (l, r) represents an open interval from l to r
+    intervals: list of (l, r) tuples (open intervals).
   """
 
-  # Use the classic fixed start-pattern to preserve strong KT coupling
-  starts = (2, 6, 10, 14)
-  # Seed with multiple disjoint unit intervals if requested (new capability)
-  if seed_count <= 1:
-    T = [(0, 1)]
-  else:
-    step = 3
-    T = [(i * step, i * step + 1) for i in range(seed_count)]
-  for round_idx in range(6):
-    lo = min(l for l, r in T)
-    hi = max(r for l, r in T)
+  # Capacity guard to keep total intervals < 10000
+  CAP = 9800
+
+  # Stage 1: Deterministic KT-style spine (no interleaving), 6 rounds, classic connectors.
+  spine_starts = (2, 6, 10, 14)
+
+  # Seed: keep a single unit interval; multi-seed tends to inflate omega too early.
+  T = [(0, 1)] if seed_count <= 1 else [(0, 1)]
+
+  def apply_spine_round(current_T, starts):
+    # Compute span and delta
+    lo = min(l for l, r in current_T)
+    hi = max(r for l, r in current_T)
     delta = hi - lo
-    # build translated blocks in sequence (no interleaving)
+    if delta <= 0:
+      delta = 1
+
+    # Four translated blocks sequentially (no interleaving)
+    S = []
+    for s in starts:
+      base = s * delta - lo
+      S.extend((l + base, r + base) for (l, r) in current_T)
+
+    # Classic connectors (Figure 4 style)
+    s0, s1, s2, s3 = starts
+    connectors = [
+      ((s0 - 1) * delta, (s1 - 1) * delta),  # left cap
+      ((s2 + 2) * delta, (s3 + 2) * delta),  # right cap
+      ((s0 + 2) * delta, (s2 - 1) * delta),  # cross 1
+      ((s1 + 2) * delta, (s3 - 1) * delta),  # cross 2
+    ]
+    S.extend(connectors)
+    return S
+
+  # Perform exactly six spine rounds unless capacity would be exceeded (it won't for this growth).
+  for _ in range(6):
+    # Predict next size: sz -> 4*sz + 4
+    nxt_size = 4 * len(T) + 4
+    if nxt_size > CAP:
+      break
+    T = apply_spine_round(T, spine_starts)
+
+  # If we are already near the cap, return the strong baseline.
+  if len(T) >= CAP - 16:
+    return T
+
+  # Stage 2: Two delta2-driven micro extension rounds (thin sampling; four-start translations).
+  # Goals:
+  #  - Raise FF pressure via cross-scale coupling and interleaving parity,
+  #  - Keep omega in check by using thin seeds and sparse caps/connectors,
+  #  - Respect strict capacity guard.
+
+  def thin_seed(current_T, max_seed):
+    """Take a thin, evenly spaced sample of current_T of size <= max_seed."""
+    n = len(current_T)
+    if n == 0 or max_seed <= 0:
+      return []
+    step = max(1, n // max_seed)
+    U = current_T[::step][:max_seed]
+    return U
+
+  def micro_round(current_T, round_id, budget):
+    if budget <= 0 or not current_T:
+      return []
+
+    glo = min(l for l, r in current_T)
+    ghi = max(r for l, r in current_T)
+    G = max(1, ghi - glo)
+
+    # Use delta2 at half-scale to avoid expanding the global span too aggressively.
+    delta2 = max(1, G // 2)
+
+    # Thin seed: bounded and deterministic size to respect budget
+    # Keep micro blocks small: target at most ~ (budget//6) per block (four blocks + ~8 extras).
+    per_block_target = max(8, min(64, budget // 12))
+    U = thin_seed(current_T, per_block_target)
+
+    if not U:
+      return []
+
+    # Build four translated blocks using the same 4-start template,
+    # with deterministic parity-based interleaving policy:
+    # - Rounds with round_id % 2 == 0: forward interleave
+    # - Rounds with round_id % 2 == 1: reverse interleave
+    starts = spine_starts
     blocks = []
-    for start in starts:
-      blocks.append([(delta * start + l - lo, delta * start + r - lo) for l, r in T])
-    S = []
-    # interleave blocks on even rounds, sequential on odd rounds
-    if round_idx % 2 == 0:
+    ulo = min(l for l, r in U)
+    for s in starts:
+      base = s * delta2 - ulo
+      block = [(l + base, r + base) for (l, r) in U]
+      # Add a tiny deterministic internal reversal to break symmetry every other block
+      if ((s // 2) % 2) == (round_id % 2):
+        block = list(reversed(block))
+      blocks.append(block)
+
+    micro = []
+    if round_id % 2 == 0:
+      # Forward interleave
       maxlen = max(len(b) for b in blocks)
       for i in range(maxlen):
         for blk in blocks:
           if i < len(blk):
-            S.append(blk[i])
+            micro.append(blk[i])
     else:
-      for blk in blocks:
-        S.extend(blk)
-    # connectors based on the fixed starts
+      # Reverse interleave (swap block order)
+      maxlen = max(len(b) for b in blocks)
+      for i in range(maxlen):
+        for blk in reversed(blocks):
+          if i < len(blk):
+            micro.append(blk[i])
+
+    # Deterministic connectors at delta2 scale, including a cross3 extension
     s0, s1, s2, s3 = starts
     connectors = [
-      (delta * (s0 - 1), delta * (s1 - 1)),  # left cap
-      (delta * (s2 + 2), delta * (s3 + 2)),  # right cap
-      (delta * (s0 + 2), delta * (s2 - 1)),  # cross 1
-      (delta * (s1 + 2), delta * (s3 - 1)),  # cross 2
+      ((s0 - 1) * delta2 + glo, (s1 - 1) * delta2 + glo),  # left cap (localized)
+      ((s2 + 2) * delta2 + glo, (s3 + 2) * delta2 + glo),  # right cap
+      ((s0 + 2) * delta2 + glo, (s2 - 1) * delta2 + glo),  # cross 1
+      ((s1 + 2) * delta2 + glo, (s3 - 1) * delta2 + glo),  # cross 2
+      ((s0 + 3) * delta2 + glo, (s3 + 3) * delta2 + glo),  # cross3 (longer range)
     ]
-    for a, b in connectors:
-      S.append((a, b))
-    T = S
-  # Micro-phase: add three long-range caps to boost late FirstFit color usage while controlling omega
-  lo = min(l for l, r in T)
-  hi = max(r for l, r in T)
-  delta = hi - lo if hi > lo else 1
-  def cap_at(a_frac, b_frac):
-    l0 = lo + max(1, int(round(a_frac * delta)))
-    r0 = lo + max(1, int(round(b_frac * delta)))
-    return (l0, r0)
-  capA = cap_at(0.08, 0.60)
-  capB = cap_at(0.25, 0.75)
-  capC = cap_at(0.75, 0.92)
-  for cap in (capA, capB, capC):
-    if cap[1] > cap[0]:
-      T.append(cap)
+    micro.extend(connectors)
+
+    # Sparse micro caps: add three long but safe caps at half-scale
+    cap1 = (glo + (delta2 // 4), glo + int(1.8 * delta2))
+    cap2 = (glo + int(0.9 * delta2), glo + int(2.6 * delta2))
+    mid = glo + G // 2
+    cap3 = (mid - max(1, delta2 // 8), mid + max(1, delta2 // 8))
+    for cap in (cap1, cap2, cap3):
+      if cap[1] > cap[0]:
+        micro.append(cap)
+
+    # Enforce budget
+    if len(micro) > budget:
+      micro = micro[:budget]
+    return micro
+
+  # Execute two micro rounds with strong guards
+  remaining = CAP - len(T)
+  mr1 = micro_round(T, round_id=0, budget=max(0, remaining // 2))
+  if mr1:
+    room = CAP - len(T)
+    if len(mr1) > room:
+      mr1 = mr1[:room]
+    T.extend(mr1)
+
+  remaining = CAP - len(T)
+  mr2 = micro_round(T, round_id=1, budget=max(0, remaining))
+  if mr2:
+    room = CAP - len(T)
+    if len(mr2) > room:
+      mr2 = mr2[:room]
+    T.extend(mr2)
+
   return T
-
-  # return [  # Figure 3, OPT=2, FF=4
-  #   (2,3),
-  #   (6,7),
-  #   (10,11),
-  #   (14,15),
-  #   (1,5),
-  #   (12,16),
-  #   (4,9),
-  #   (8,13),
-  # ]
 
 # EVOLVE-BLOCK-END
 
 def run_experiment(**kwargs):
   """Main called by evaluator"""
   return construct_intervals()