--- a/original.py
+++ b/original.py
@@ -1,49 +1,50 @@
 # EVOLVE-BLOCK-START
 
-def construct_intervals():
+def construct_intervals(depth=4, branching=5):
   """
-  Construct a sequence of intervals of real line,
-  in the order in which they are presented to FirstFit,
-  so that it maximizes the number of colors used by FirstFit
-  divided by the maximum number of intervals that cover a single point
+  Parameterized recursive construction inspired by Kierstead-Trotter / Figure 4.
 
-  The initial implementation uses the construction from
-  Figure 4 in https://arxiv.org/abs/1506.00192
+  Parameters:
+    depth (int): recursion depth (default 4). Keep moderate to limit intervals.
+    branching (int): number of scaled copies per level (default 5).
 
   Returns:
-    intervals: list of tuples, each tuple (l, r) represents an open interval from l to r
+    list of (l, r) integer tuples representing open intervals in presentation order.
   """
+  if depth <= 0:
+    return [(0, 1)]
 
   T = [(0, 1)]
-  for _ in range(6):
+  for _ in range(depth):
     lo = min(l for l, r in T)
     hi = max(r for l, r in T)
-    delta = hi - lo
+    span = hi - lo
     S = []
-    for start in (2, 6, 10, 14):
-      S += [(delta * start + l - lo, delta * start + r - lo) for l, r in T]
-    S += [
-      (delta * 1, delta * 5),
-      (delta * 12, delta * 16),
-      (delta * 4, delta * 9),
-      (delta * 8, delta * 13)
-    ]
+    # starts: 2,6,10,... (spaced by 4) for branching copies
+    starts = [2 + 4 * i for i in range(branching)]
+    for s in starts:
+      base = s * span - lo
+      for (l, r) in T:
+        S.append((int(l + base), int(r + base)))
+    # adjacent connectors between blocks to propagate FF colors
+    for i in range(len(starts) - 1):
+      a = (1 + 4 * i) * span
+      b = (5 + 4 * i) * span
+      S.append((int(a), int(b)))
+    # a couple of cross connectors (keeps clique small but couples blocks)
+    if branching >= 3:
+      a = (4 * 0 + 4) * span
+      b = (4 * 2 + 9) * span
+      S.append((int(a), int(b)))
+    if branching >= 4:
+      a = (4 * 1 + 8) * span
+      b = (4 * 3 + 13) * span
+      S.append((int(a), int(b)))
     T = S
   return T
-
-  # return [  # Figure 3, OPT=2, FF=4
-  #   (2,3),
-  #   (6,7),
-  #   (10,11),
-  #   (14,15),
-  #   (1,5),
-  #   (12,16),
-  #   (4,9),
-  #   (8,13),
-  # ]
 
 # EVOLVE-BLOCK-END
 
 def run_experiment(**kwargs):
   """Main called by evaluator"""
   return construct_intervals()