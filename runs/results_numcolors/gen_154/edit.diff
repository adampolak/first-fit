--- a/original.py
+++ b/original.py
@@ -1,170 +1,166 @@
 # EVOLVE-BLOCK-START
 
 def construct_intervals(seed_count=1):
-  """
-  Construct a sequence of intervals on the real line, in the order presented to FirstFit,
-  to maximize FF colors divided by the clique number.
-  Returns:
-    intervals: list of (l, r) tuples (open intervals).
-  """
+    """
+    Enhanced multi-scale spine + three-round micro-phase.
+    Returns a list of (l,r) integer intervals for FirstFit.
+    """
+    MAX_CAP = 9800
+    # Four 4-start templates
+    spine_templates = [
+        (2, 6, 10, 14),
+        (1, 5, 9, 13),
+        (3, 7, 11, 15),
+        (4, 8, 12, 16),
+    ]
+    # Seed
+    T = [(0.0, 1.0)]
+    # Stage 1: 5 spine rounds
+    for ridx in range(5):
+        lo = min(l for l, r in T)
+        hi = max(r for l, r in T)
+        delta = hi - lo if hi > lo else 1.0
+        starts = spine_templates[ridx % len(spine_templates)]
+        K = 1 + (ridx % 2)  # alternate densification
+        # build 4 blocks
+        blocks = []
+        for s in starts:
+            base = (s * K) * delta - lo
+            blocks.append([(l + base, r + base) for (l, r) in T])
+        # parity interleaving: even rounds interleave, odd sequential
+        S = []
+        if ridx % 2 == 0:
+            maxlen = max(len(b) for b in blocks)
+            for i in range(maxlen):
+                for blk in blocks:
+                    if i < len(blk):
+                        S.append(blk[i])
+        else:
+            for blk in blocks:
+                S.extend(blk)
+        # classic 4 connectors
+        s0, s1, s2, s3 = starts
+        for a, b in [
+            ((s0 - 1) * K * delta, (s1 - 1) * K * delta),
+            ((s2 + 2) * K * delta, (s3 + 2) * K * delta),
+            ((s0 + 2) * K * delta, (s2 - 1) * K * delta),
+            ((s1 + 2) * K * delta, (s3 - 1) * K * delta),
+        ]:
+            S.append((a, b))
+        T = S
+        if len(T) >= MAX_CAP - 16:
+            break
 
-  # Capacity guard tuned to return after six spine rounds (skipping micro-phase) and < 10000
-  CAP = 9560
+    # If spine already near cap, convert and return
+    if len(T) >= MAX_CAP - 100:
+        # simple int conversion
+        out = []
+        for (l, r) in T:
+            li = int(round(l))
+            ri = int(round(r))
+            if ri <= li: ri = li + 1
+            out.append((li, ri))
+            if len(out) >= 10000:
+                break
+        return out
 
-  # Stage 1: Deterministic KT-style spine (no interleaving), 6 rounds, classic connectors.
-  spine_starts = (2, 6, 10, 14)
+    # Stage 2: three micro rounds
+    def thin_seed(U, m):
+        if not U or m <= 0:
+            return []
+        step = max(1, len(U) // m)
+        return U[::step][:m]
 
-  # Seed: keep a single unit interval; multi-seed tends to inflate omega too early.
-  T = [(0, 1)] if seed_count <= 1 else [(0, 1)]
+    def micro_round(curr, rid, budget):
+        if budget <= 0 or not curr:
+            return []
+        glo = min(l for l, r in curr)
+        ghi = max(r for l, r in curr)
+        G = max(1.0, ghi - glo)
+        delta2 = G / 2.0
+        # sample
+        per = max(8, min(96, budget // 8))
+        U = thin_seed(curr, per)
+        if not U:
+            return []
+        # template & density
+        starts = spine_templates[rid % len(spine_templates)]
+        K2 = 1 + (rid % 2)
+        blocks = []
+        # preload blockers params
+        pb = 2
+        bl = 0.05 * G
+        bg = 0.03 * G
+        for idx, s in enumerate(starts):
+            base = (s * K2) * delta2 - min(l for l, r in U)
+            block = []
+            # small preload blockers
+            for b in range(pb):
+                st = base + (0.1 + b * (bl + bg))
+                block.append((glo + st, glo + st + bl))
+            # clone (with optional reversal)
+            seq = reversed(U) if (idx % 2 == rid % 2) else U
+            for (l, r) in seq:
+                block.append((l + base, r + base))
+            blocks.append(block)
+        # interleave or sequential
+        M = []
+        if rid % 2 == 0:
+            maxlen = max(len(b) for b in blocks)
+            for i in range(maxlen):
+                for blk in blocks:
+                    if i < len(blk):
+                        M.append(blk[i])
+        else:
+            maxlen = max(len(b) for b in blocks)
+            for i in range(maxlen):
+                for blk in reversed(blocks):
+                    if i < len(blk):
+                        M.append(blk[i])
+        # micro-bridges
+        for i in range(len(starts) - 1):
+            M.append((glo + (starts[i] + 0.6) * delta2,
+                      glo + (starts[i + 1] - 0.6) * delta2))
+        # connectors cross1..cross4 + cross3
+        s0, s1, s2, s3 = starts
+        for a, b in [
+            ((s0 - 1) * K2 * delta2 + glo, (s1 - 1) * K2 * delta2 + glo),
+            ((s2 + 2) * K2 * delta2 + glo, (s3 + 2) * K2 * delta2 + glo),
+            ((s0 + 2) * K2 * delta2 + glo, (s2 - 1) * K2 * delta2 + glo),
+            ((s1 + 2) * K2 * delta2 + glo, (s3 - 1) * K2 * delta2 + glo),
+            ((s0 + 3) * K2 * delta2 + glo, (s3 + 3) * K2 * delta2 + glo),
+            ((s1 + 4) * K2 * delta2 + glo, (s2 + 4) * K2 * delta2 + glo),
+        ]:
+            M.append((a, b))
+        return M[:budget]
 
-  def apply_spine_round(current_T, starts):
-    # Compute span and delta
-    lo = min(l for l, r in current_T)
-    hi = max(r for l, r in current_T)
-    delta = hi - lo
-    if delta <= 0:
-      delta = 1
+    remaining = MAX_CAP - len(T)
+    for rid in range(3):
+        bud = remaining // (3 - rid)
+        mr = micro_round(T, rid, bud)
+        room = MAX_CAP - len(T)
+        if mr:
+            T.extend(mr[:room])
+        remaining = MAX_CAP - len(T)
 
-    # Four translated blocks sequentially (no interleaving)
-    S = []
-    for s in starts:
-      base = s * delta - lo
-      S.extend((l + base, r + base) for (l, r) in current_T)
-
-    # Classic connectors (Figure 4 style)
-    s0, s1, s2, s3 = starts
-    connectors = [
-      ((s0 - 1) * delta, (s1 - 1) * delta),  # left cap
-      ((s2 + 2) * delta, (s3 + 2) * delta),  # right cap
-      ((s0 + 2) * delta, (s2 - 1) * delta),  # cross 1
-      ((s1 + 2) * delta, (s3 - 1) * delta),  # cross 2
-    ]
-    S.extend(connectors)
-    return S
-
-  # Perform exactly six spine rounds unless capacity would be exceeded (it won't for this growth).
-  for _ in range(6):
-    # Predict next size: sz -> 4*sz + 4
-    nxt_size = 4 * len(T) + 4
-    if nxt_size > CAP:
-      break
-    T = apply_spine_round(T, spine_starts)
-
-  # If we are already near the cap, return the strong baseline.
-  if len(T) >= CAP - 16:
-    return T
-
-  # Stage 2: Two delta2-driven micro extension rounds (thin sampling; four-start translations).
-  # Goals:
-  #  - Raise FF pressure via cross-scale coupling and interleaving parity,
-  #  - Keep omega in check by using thin seeds and sparse caps/connectors,
-  #  - Respect strict capacity guard.
-
-  def thin_seed(current_T, max_seed):
-    """Take a thin, evenly spaced sample of current_T of size <= max_seed."""
-    n = len(current_T)
-    if n == 0 or max_seed <= 0:
-      return []
-    step = max(1, n // max_seed)
-    U = current_T[::step][:max_seed]
-    return U
-
-  def micro_round(current_T, round_id, budget):
-    if budget <= 0 or not current_T:
-      return []
-
-    glo = min(l for l, r in current_T)
-    ghi = max(r for l, r in current_T)
-    G = max(1, ghi - glo)
-
-    # Use delta2 at half-scale to avoid expanding the global span too aggressively.
-    delta2 = max(1, G // 2)
-
-    # Thin seed: bounded and deterministic size to respect budget
-    # Keep micro blocks small: target at most ~ (budget//6) per block (four blocks + ~8 extras).
-    per_block_target = max(8, min(64, budget // 12))
-    U = thin_seed(current_T, per_block_target)
-
-    if not U:
-      return []
-
-    # Build four translated blocks using the same 4-start template,
-    # with deterministic parity-based interleaving policy:
-    # - Rounds with round_id % 2 == 0: forward interleave
-    # - Rounds with round_id % 2 == 1: reverse interleave
-    starts = spine_starts
-    blocks = []
-    ulo = min(l for l, r in U)
-    for s in starts:
-      base = s * delta2 - ulo
-      block = [(l + base, r + base) for (l, r) in U]
-      # Add a tiny deterministic internal reversal to break symmetry every other block
-      if ((s // 2) % 2) == (round_id % 2):
-        block = list(reversed(block))
-      blocks.append(block)
-
-    micro = []
-    if round_id % 2 == 0:
-      # Forward interleave
-      maxlen = max(len(b) for b in blocks)
-      for i in range(maxlen):
-        for blk in blocks:
-          if i < len(blk):
-            micro.append(blk[i])
-    else:
-      # Reverse interleave (swap block order)
-      maxlen = max(len(b) for b in blocks)
-      for i in range(maxlen):
-        for blk in reversed(blocks):
-          if i < len(blk):
-            micro.append(blk[i])
-
-    # Deterministic connectors at delta2 scale, including a cross3 extension
-    s0, s1, s2, s3 = starts
-    connectors = [
-      ((s0 - 1) * delta2 + glo, (s1 - 1) * delta2 + glo),  # left cap (localized)
-      ((s2 + 2) * delta2 + glo, (s3 + 2) * delta2 + glo),  # right cap
-      ((s0 + 2) * delta2 + glo, (s2 - 1) * delta2 + glo),  # cross 1
-      ((s1 + 2) * delta2 + glo, (s3 - 1) * delta2 + glo),  # cross 2
-      ((s0 + 3) * delta2 + glo, (s3 + 3) * delta2 + glo),  # cross3 (longer range)
-    ]
-    micro.extend(connectors)
-
-    # Sparse micro caps: add three long but safe caps at half-scale
-    cap1 = (glo + (delta2 // 4), glo + int(1.8 * delta2))
-    cap2 = (glo + int(0.9 * delta2), glo + int(2.6 * delta2))
-    mid = glo + G // 2
-    cap3 = (mid - max(1, delta2 // 8), mid + max(1, delta2 // 8))
-    for cap in (cap1, cap2, cap3):
-      if cap[1] > cap[0]:
-        micro.append(cap)
-
-    # Enforce budget
-    if len(micro) > budget:
-      micro = micro[:budget]
-    return micro
-
-  # Execute two micro rounds with strong guards
-  remaining = CAP - len(T)
-  mr1 = micro_round(T, round_id=0, budget=max(0, remaining // 2))
-  if mr1:
-    room = CAP - len(T)
-    if len(mr1) > room:
-      mr1 = mr1[:room]
-    T.extend(mr1)
-
-  remaining = CAP - len(T)
-  mr2 = micro_round(T, round_id=1, budget=max(0, remaining))
-  if mr2:
-    room = CAP - len(T)
-    if len(mr2) > room:
-      mr2 = mr2[:room]
-    T.extend(mr2)
-
-  return T
+    # Final conversion to integer intervals
+    if not T:
+        return []
+    minl = min(l for l, r in T)
+    sf = 1000.0
+    out = []
+    for (l, r) in T:
+        li = int(round((l - minl) * sf))
+        ri = int(round((r - minl) * sf))
+        if ri <= li:
+            ri = li + 1
+        out.append((li, ri))
+        if len(out) >= 10000:
+            break
+    return out
 
 # EVOLVE-BLOCK-END
 
 def run_experiment(**kwargs):
   """Main called by evaluator"""
   return construct_intervals()