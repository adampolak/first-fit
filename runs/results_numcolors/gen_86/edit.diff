--- a/original.py
+++ b/original.py
@@ -1,147 +1,158 @@
 # EVOLVE-BLOCK-START
+
+def _normalize_to_int_intervals(intervals):
+    """Convert to non-negative integer endpoints with minimal adjustments."""
+    if not intervals:
+        return []
+    min_l = min(l for l, _ in intervals)
+    if min_l < 0:
+        intervals = [(l - min_l, r - min_l) for l, r in intervals]
+    # Ensure strictly positive span per interval
+    normalized = []
+    for (l, r) in intervals:
+        li = int(l)
+        ri = int(r)
+        if ri <= li:
+            ri = li + 1
+        normalized.append((li, ri))
+    return normalized
+
+def _append_micro_phase(T, lo, hi, delta, max_extra):
+    """Append a small micro-phase at the end to sprinkle long caps, bounded by max_extra."""
+    if max_extra <= 0:
+        return T
+    d2 = max(1, delta // 4)
+    micro = [
+        (lo + 1 * d2, lo + 5 * d2),
+        (hi - 6 * d2, hi - 2 * d2),
+        (lo + 3 * d2, lo + 8 * d2),
+        (hi - 8 * d2, hi - 3 * d2),
+    ]
+    # insert near end to touch many active colors
+    for i, interval in enumerate(micro):
+        pos = len(T) - (i * 2 + 1)
+        if pos < 0:
+            T.append(interval)
+        else:
+            T.insert(pos, interval)
+    return T
+
+def _make_blocks(T, starts, delta, lo, reverse_parity):
+    """Construct four translated blocks (with optional reversal)"""
+    blocks = []
+    for b_idx, s in enumerate(starts):
+        block_src = T[::-1] if (reverse_parity and (b_idx % 2 == 1)) else T
+        base = s * delta - lo
+        block = [(l + base, r + base) for (l, r) in block_src]
+        blocks.append(block)
+    return blocks
+
+def _interleave_blocks(blocks, round_idx, interleave=True):
+    """Return an interleaved sequence of intervals from blocks; round-dependent order."""
+    if not interleave:
+        # flatten in block order
+        S = []
+        for blk in blocks:
+            S.extend(blk)
+        return S
+
+    maxlen = max((len(b) for b in blocks), default=0)
+    order = list(range(len(blocks)))
+    if round_idx % 2 == 1:
+        order = order[::-1]
+    # a subtle rotation to avoid stable overlap patterns
+    krot = round_idx % len(order)
+    order = order[krot:] + order[:krot]
+
+    S = []
+    for i in range(maxlen):
+        for idx in order:
+            blk = blocks[idx]
+            if i < len(blk):
+                S.append(blk[i])
+    return S
 
 def construct_intervals(depth=3):
     """
-    Hybrid rotated-interleaved Kierstead-Trotter inspired construction.
+    Fractal KT-inspired construction with modular toggles.
 
-    - Rotated four-block start patterns to vary overlap geometry across rounds.
-    - Optional reversal of every other block to mix color usage.
-    - Interleaving of intervals from different blocks so FirstFit sees
-      many overlapping active colors and is forced to create new colors.
-    - Connector "caps" that couple blocks without creating a large clique.
-    - Micro-phase sprinkling of a few long sparse caps at the end to further
-      stress FirstFit.
-    - Integer arithmetic and adaptive depth limit to keep total intervals < 10000.
-
-    Parameters:
-      depth (int): nominal recursion depth (default 3). If depth is too large,
-                   it will be reduced to keep the total number of intervals
-                   below a safety cap.
-
-    Returns: list of (l, r) integer tuples (open intervals) in presentation order.
+    Returns: list of (l, r) integer tuples representing open intervals.
     """
-    depth = max(0, int(depth))
-    # Safety cap: keep total intervals under this (a little under 10000).
-    MAX_INTERVALS = 9800
-
-    # Strategies / toggles (picked deterministically to combine the best parts)
-    rotate_starts = True
+    # Global controls (deterministic toggles)
+    rotate_starts   = True
     reverse_block_parity = True
     interleave_blocks = True
     micro_phase = True
 
-    # A small cycle of start patterns (recover classical Figure 4 pattern
-    # but rotate it across rounds to break periodicity).
+    # Start patterns (deterministic cycle)
     start_patterns = [
-        [2, 6, 10, 14],  # classic
+        [2, 6, 10, 14],  # classic four-block layout
         [1, 5, 9, 13],   # left-shifted
         [3, 7, 11, 15],  # right-shifted
         [2, 4, 8, 12],   # compressed variant
     ]
 
-    # Base seed
+    # Seed: a single unit interval; small to allow deeper rounds under cap
     T = [(0, 1)]
 
-    # Reduce the effective depth if the naive growth would exceed MAX_INTERVALS.
-    # We approximate growth as size_{k+1} = 4*size_k + 4 (4 copies plus 4 connectors).
+    MAX_INTERVALS = 9800  # safety cap
+
+    # Compute a safe depth given the MAX_INTERVALS budget
+    depth = max(0, int(depth))
     allowed = 0
-    size = 1
+    size = 1  # current number of intervals notionally
     while allowed < depth:
-        next_size = size * 4 + 4
+        next_size = size * 4 + 4  # 4 copies + 4 connectors (rough bound)
         if next_size > MAX_INTERVALS:
             break
         size = next_size
         allowed += 1
     depth = allowed
 
     for round_idx in range(depth):
-        lo = min(l for l, r in T)
-        hi = max(r for l, r in T)
+        lo = min(l for l, _ in T)
+        hi = max(r for _, r in T)
         delta = hi - lo
         if delta <= 0:
             delta = 1
 
-        # Choose start pattern for this round
         starts = start_patterns[round_idx % len(start_patterns)] if rotate_starts else start_patterns[0]
 
-        # Build the four translated blocks (possibly reversing every other block).
-        blocks = []
-        for b_idx, s in enumerate(starts):
-            block_src = T[::-1] if (reverse_block_parity and (b_idx % 2 == 1)) else T
-            # Shift so that the leftmost point of this copy becomes s*delta.
-            shift = s * delta - lo
-            block = [(l + shift, r + shift) for (l, r) in block_src]
-            blocks.append(block)
+        blocks = _make_blocks(T, starts, delta, lo, reverse_block_parity)
 
-        # Interleave the blocks (round-robin) to present intervals from
-        # different blocks in alternating order; this increases FirstFit pressure.
-        S = []
-        if interleave_blocks:
-            maxlen = max(len(b) for b in blocks)
-            order = list(range(len(blocks)))
-            # alternate the block visitation order every other round
-            if round_idx % 2 == 1:
-                order = order[::-1]
-            for i in range(maxlen):
-                for idx in order:
-                    blk = blocks[idx]
-                    if i < len(blk):
-                        S.append(blk[i])
-        else:
-            for blk in blocks:
-                S.extend(blk)
+        S = _interleave_blocks(blocks, round_idx, interleave=interleave_blocks)
 
-        # Deterministic connector/cap formulas derived from chosen starts.
-        # These link blocks without creating a large clique but propagate colors.
-        s0, s1, s2, s3 = starts
+        # Deterministic four-connectors (caps) derived from the first four starts
+        s0, s1, s2, s3 = starts[0], starts[1], starts[2], starts[3]
         connectors = [
-            ((s0 - 1) * delta, (s1 - 1) * delta),
-            ((s2 + 2) * delta, (s3 + 2) * delta),
-            ((s0 + 2) * delta, (s2 - 1) * delta),
-            ((s1 + 2) * delta, (s3 - 1) * delta),
+            ((s0 - 1) * delta, (s1 - 1) * delta),  # left cap
+            ((s2 + 2) * delta, (s3 + 2) * delta),  # right cap
+            ((s0 + 2) * delta, (s2 - 1) * delta),  # cross 1
+            ((s1 + 2) * delta, (s3 - 1) * delta),  # cross 2
         ]
         S.extend(connectors)
 
         T = S
 
-    # Optional tiny second phase: sprinkle a few sparse long-range caps to
-    # further stress FirstFit without blowing up the clique number or count.
+    # Optional micro-phase sprinkled at end
     if micro_phase and len(T) + 8 <= MAX_INTERVALS:
-        lo = min(l for l, r in T)
-        hi = max(r for l, r in T)
+        lo = min(l for l, _ in T)
+        hi = max(r for _, r in T)
         delta = max(1, hi - lo)
-        d2 = max(1, delta // 4)
-        micro = [
-            (lo + 1 * d2, lo + 5 * d2),
-            (hi - 6 * d2, hi - 2 * d2),
-            (lo + 3 * d2, lo + 8 * d2),
-            (hi - 8 * d2, hi - 3 * d2),
-        ]
-        # Insert micro gadgets interleaved near the end to maximize pressure.
-        # We insert them in alternating order to touch many active colors.
-        for i, interval in enumerate(micro):
-            insert_pos = len(T) - (i * 2 + 1)
-            if insert_pos < 0:
-                T.append(interval)
-            else:
-                T.insert(insert_pos, interval)
+        T = _append_micro_phase(T, lo, hi, delta, max_extra=8)
 
-    # Normalize coordinates to be non-negative integers (keeps presentation tidy).
-    min_l = min(l for l, r in T)
-    if min_l < 0:
-        T = [(l - min_l, r - min_l) for l, r in T]
+    # Normalize and convert to integers
+    intervals = _normalize_to_int_intervals(T)
 
-    # Ensure integer endpoints
-    intervals = [(int(l), int(r)) for l, r in T]
     return intervals
 
 
 def run_experiment(**kwargs):
     """Main called by evaluator"""
     return construct_intervals(**kwargs)
 
 # EVOLVE-BLOCK-END
 
 def run_experiment(**kwargs):
   """Main called by evaluator"""
   return construct_intervals()