--- a/original.py
+++ b/original.py
@@ -1,58 +1,82 @@
 # EVOLVE-BLOCK-START
 
 def construct_intervals():
-  """
-  Construct a sequence of intervals of real line,
-  in the order in which they are presented to FirstFit,
-  so that it maximizes the number of colors used by FirstFit
-  divided by the maximum number of intervals that cover a single point
+    """
+    Hybrid recursive interval generator combining Kierstead–Trotter blow-up
+    with arrival-order heuristics for FirstFit pressure.
+    Returns list of integer (l, r) intervals.
+    """
+    depth = 4             # recursion depth
+    branching = 4         # number of scaled copies per level
+    preload = 2           # number of small blockers per block
+    caps_per_round = 3    # number of sparse caps each round
 
-  The initial implementation uses the construction from
-  Figure 4 in https://arxiv.org/abs/1506.00192
+    # base pattern
+    T = [(0, 1)]
+    for round_idx in range(depth):
+        lo = min(l for l, r in T)
+        hi = max(r for l, r in T)
+        span = hi - lo
 
-  Returns:
-    intervals: list of tuples, each tuple (l, r) represents an open interval from l to r
-  """
+        S = []
+        # block start offsets as in Figure 4
+        starts = [2 + 4 * i for i in range(branching)]
 
-  # parameterize recursion depth and branching factor for stronger blow-up
-  depth = 4
-  branching = 7
-  T = [(0, 1)]
-  for _ in range(depth):
-    lo = min(l for l, r in T)
-    hi = max(r for l, r in T)
-    delta = hi - lo
-    S = []
-    # insert scaled copies at offsets [2,6,10,...] based on branching
-    starts = [2 + 4 * i for i in range(branching)]
-    for start in starts:
-      S += [(delta * start + l - lo, delta * start + r - lo) for l, r in T]
-    # adjacent connectors to propagate FirstFit colors between neighbors
-    for i in range(branching - 1):
-      a = delta * (1 + 4 * i)
-      b = delta * (5 + 4 * i)
-      S.append((a, b))
-    # cross connectors to couple non‐adjacent blocks without raising clique
-    for i in range(branching - 2):
-      a = delta * (4 + 4 * i)
-      b = delta * (9 + 4 * i)
-      S.append((a, b))
-    T = S
-  return T
+        for idx, start in enumerate(starts):
+            base = start * span - lo
 
-  # return [  # Figure 3, OPT=2, FF=4
-  #   (2,3),
-  #   (6,7),
-  #   (10,11),
-  #   (14,15),
-  #   (1,5),
-  #   (12,16),
-  #   (4,9),
-  #   (8,13),
-  # ]
+            # preload blockers: small intervals to occupy low colors
+            small_len = span * 0.1
+            for j in range(preload):
+                l0 = (start + 0.1 + j * 0.15) * span - lo
+                S.append((int(l0), int(l0 + small_len)))
+
+            # clone or reversed‐clone of previous round
+            if idx % 2 == 1:
+                for (l, r) in reversed(T):
+                    S.append((int(l + base), int(r + base)))
+            else:
+                for (l, r) in T:
+                    S.append((int(l + base), int(r + base)))
+
+            # short bridge to next block
+            if idx + 1 < len(starts):
+                next_start = starts[idx + 1]
+                l1 = (start + 0.5) * span - lo
+                r1 = (next_start + 0.3) * span - lo
+                S.append((int(l1), int(r1)))
+
+        # adjacent connectors (propagate FF usage between neighbors)
+        for i in range(branching - 1):
+            a = (1 + 4 * i) * span
+            b = (5 + 4 * i) * span
+            S.append((int(a), int(b)))
+
+        # the four global connectors from Figure 4
+        S.append((int(1 * span),  int(5 * span)))
+        S.append((int(12 * span), int(16 * span)))
+        S.append((int(4 * span),  int(9 * span)))
+        S.append((int(8 * span),  int(13 * span)))
+
+        # sparse caps to raise FF colors without enlarging clique
+        for c in range(1, caps_per_round + 1):
+            j = 6 * c
+            l2 = (j - 1.5) * span
+            r2 = (j + 1.5) * span
+            S.append((int(l2), int(r2)))
+
+        # two long sentries in the first round only
+        if round_idx == 0:
+            S.append((0,                int(3 * span)))
+            S.append((int(10 * span),   int(14 * span)))
+
+        # prepare for next round
+        T = S
+
+    return T
 
 # EVOLVE-BLOCK-END
 
 def run_experiment(**kwargs):
   """Main called by evaluator"""
   return construct_intervals()