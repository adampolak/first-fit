<NAME>
always_interleave_plus_inner_cross
</NAME>

<DESCRIPTION>
We strengthen FirstFit pressure with three minimal, deterministic tweaks:

1) Always interleave KT blocks each round (rather than only on even rounds). This increases continual color mixing along the spine without increasing omega too much due to connector discipline.

2) Add two inner cross connectors per round: ((s0+1)*delta, (s3−2)*delta) and ((s1+1)*delta, (s2−2)*delta). These cross three blocks while avoiding extreme endpoints, coupling colors across non-adjacent blocks (“towers”) and improving FF utilization.

3) Make the micro-phase seed slightly denser and improve mixing: increase seed density (len/280 up to 36), reorder micro blocks to [0,2,1,3] to couple nonadjacent windows first, and add one long micro connector (0.34, 0.86). This implements cross-scale connectors and four-window micro-phase ideas while staying under CAP.

These changes are small, reproducible, and CAP-safe, aimed at nudging the competitive ratio above the current plateau.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # Classic four connectors
    s0, s1, s2, s3 = starts
    S.append(((s0 - 1) * delta, (s1 - 1) * delta))  # left cap
    S.append(((s2 + 2) * delta, (s3 + 2) * delta))  # right cap
    S.append(((s0 + 2) * delta, (s2 - 1) * delta))  # cross 1
    S.append(((s1 + 2) * delta, (s3 - 1) * delta))  # cross 2
    return S
=======
    # Classic four connectors + two inner cross connectors to strengthen color coupling
    s0, s1, s2, s3 = starts
    S.append(((s0 - 1) * delta, (s1 - 1) * delta))  # left cap
    S.append(((s2 + 2) * delta, (s3 + 2) * delta))  # right cap
    S.append(((s0 + 2) * delta, (s2 - 1) * delta))  # cross 1
    S.append(((s1 + 2) * delta, (s3 - 1) * delta))  # cross 2
    # Inner cross connectors (span across three blocks, avoid extreme endpoints)
    S.append(((s0 + 1) * delta, (s3 - 2) * delta))
    S.append(((s1 + 1) * delta, (s2 - 2) * delta))
    return S
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    # Interleave on even rounds, reverse block order on odd rounds
    do_inter = (ridx % 2 == 0)
    rev = (ridx % 2 == 1)
    T = _apply_round(T, starts, do_interleave=do_inter, reverse_order=rev)
=======
    # Interleave on every round to maximize color mixing; reverse order on odd rounds
    do_inter = True
    rev = (ridx % 2 == 1)
    T = _apply_round(T, starts, do_interleave=do_inter, reverse_order=rev)
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    # Thin, evenly spaced seed
    seed_sz = max(8, min(32, len(current_T) // 300))
    stride = max(1, len(current_T) // max(1, seed_sz))
    U = [current_T[i] for i in range(0, len(current_T), stride)][:seed_sz]
    if not U:
      return []
=======
    # Thin, evenly spaced seed (slightly denser to enhance mixing)
    seed_sz = max(8, min(36, len(current_T) // 280))
    stride = max(1, len(current_T) // max(1, seed_sz))
    U = [current_T[i] for i in range(0, len(current_T), stride)][:seed_sz]
    if not U:
      return []
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    # Build translated micro-blocks aligned to these windows
    blocks = []
    for (fa, fb) in window_fracs:
      win_lo = glo + int(round(fa * G))
      base = win_lo - ulo
      block = [(l + base, r + base) for (l, r) in U]
      blocks.append(block)

    # Interleave micro-blocks to maximize FF mixing
    micro = []
    maxlen = max(len(b) for b in blocks)
    for i in range(maxlen):
      for blk in blocks:
        if i < len(blk):
          micro.append(blk[i])

    # Fractional-span connectors at the micro scale
    micro_connectors = [
      (glo + int(round(0.08 * G)), glo + int(round(0.30 * G))),  # left cap
      (glo + int(round(0.60 * G)), glo + int(round(0.92 * G))),  # right cap
      (glo + int(round(0.26 * G)), glo + int(round(0.56 * G))),  # cross 1
      (glo + int(round(0.44 * G)), glo + int(round(0.78 * G))),  # cross 2
    ]
    for a, b in micro_connectors:
      if b > a:
        micro.append((a, b))
=======
    # Build translated micro-blocks aligned to these windows
    blocks = []
    for (fa, fb) in window_fracs:
      win_lo = glo + int(round(fa * G))
      base = win_lo - ulo
      block = [(l + base, r + base) for (l, r) in U]
      blocks.append(block)

    # Reorder blocks to [0,2,1,3] to couple non-adjacent windows
    if len(blocks) == 4:
      blocks_ordered = [blocks[0], blocks[2], blocks[1], blocks[3]]
    else:
      blocks_ordered = blocks

    # Interleave micro-blocks to maximize FF mixing
    micro = []
    maxlen = max(len(b) for b in blocks_ordered)
    for i in range(maxlen):
      for blk in blocks_ordered:
        if i < len(blk):
          micro.append(blk[i])

    # Fractional-span connectors at the micro scale
    micro_connectors = [
      (glo + int(round(0.08 * G)), glo + int(round(0.30 * G))),  # left cap
      (glo + int(round(0.60 * G)), glo + int(round(0.92 * G))),  # right cap
      (glo + int(round(0.26 * G)), glo + int(round(0.56 * G))),  # cross 1
      (glo + int(round(0.44 * G)), glo + int(round(0.78 * G))),  # cross 2
      (glo + int(round(0.34 * G)), glo + int(round(0.86 * G))),  # long cross
    ]
    for a, b in micro_connectors:
      if b > a:
        micro.append((a, b))
>>>>>>> REPLACE
</DIFF>