--- a/original.py
+++ b/original.py
@@ -1,174 +1,183 @@
 # EVOLVE-BLOCK-START
 
-def _rounds_allowed_under_cap(max_intervals, base_size=1, per_round_copies=4, per_round_connectors=4, target_rounds=6):
+def _rounds_allowed_under_cap(max_intervals, base_size=1, copies=4, connectors=4, target=6):
     """
-    Compute how many rounds of the recurrence:
-       size_{k+1} = per_round_copies * size_k + per_round_connectors
-    fit under max_intervals, up to target_rounds.
-    Returns (rounds_used, final_size).
+    Determine how many rounds of the recurrence size_{k+1}=copies*size_k+connectors
+    can fit under max_intervals, up to `target` rounds.
     """
     size = base_size
     rounds = 0
-    while rounds < target_rounds:
-        next_size = per_round_copies * size + per_round_connectors
-        if next_size > max_intervals:
+    while rounds < target:
+        nxt = size * copies + connectors
+        if nxt > max_intervals:
             break
-        size = next_size
+        size = nxt
         rounds += 1
-    return rounds, size
+    return rounds
 
-def _build_translated_blocks(T, delta, lo, starts):
+def _build_blocks(T, delta, lo, starts, reverse_block_parity):
     """
-    Build translated blocks sequentially (no interleaving).
-    This ordering is known to increase FirstFit pressure.
-    Each block is a translated copy of T offset by base = s*delta - lo.
-    Returns a list of blocks (each block is a list of (l,r)).
+    Build translated copies of T at offsets given by `starts`.
+    Reverse every other block if reverse_block_parity=True.
     """
     blocks = []
-    for s in starts:
-        base = s * delta - lo
-        blocks.append([(l + base, r + base) for (l, r) in T])
+    for idx, s in enumerate(starts):
+        src = T[::-1] if (reverse_block_parity and (idx % 2 == 1)) else T
+        shift = s * delta - lo
+        blocks.append([(l + shift, r + shift) for (l, r) in src])
     return blocks
 
-def _append_connectors(S, delta, starts):
+def _interleave_blocks(blocks, interleave, round_idx):
     """
-    Add the four classic connectors that couple colors across blocks without
-    blowing up the clique number. Keeps exactly 4 connectors to fit budgets.
+    If interleave=False, flatten blocks in order.
+    Otherwise, round-robin across blocks, rotating visitation order each round.
+    """
+    if not interleave:
+        S = []
+        for blk in blocks:
+            S.extend(blk)
+        return S
+
+    maxlen = max((len(b) for b in blocks), default=0)
+    order = list(range(len(blocks)))
+    # reverse order on odd rounds
+    if round_idx % 2 == 1:
+        order.reverse()
+    # cyclic rotate the order to further break patterns
+    k = round_idx % len(order)
+    order = order[k:] + order[:k]
+
+    S = []
+    for i in range(maxlen):
+        for idx in order:
+            blk = blocks[idx]
+            if i < len(blk):
+                S.append(blk[i])
+    return S
+
+def _add_connectors(S, starts, delta):
+    """
+    Add the classic four Kierstead–Trotter connectors (caps) derived
+    from the first four values of `starts`.
     """
     s0, s1, s2, s3 = starts[:4]
     connectors = [
-        ((s0 - 1) * delta, (s1 - 1) * delta),  # left cap
-        ((s2 + 2) * delta, (s3 + 2) * delta),  # right cap
-        ((s0 + 2) * delta, (s2 - 1) * delta),  # cross 1
-        ((s1 + 2) * delta, (s3 - 1) * delta),  # cross 2
+        ((s0 - 1) * delta, (s1 - 1) * delta),
+        ((s2 + 2) * delta, (s3 + 2) * delta),
+        ((s0 + 2) * delta, (s2 - 1) * delta),
+        ((s1 + 2) * delta, (s3 - 1) * delta),
     ]
     S.extend(connectors)
 
-def _normalize_to_int_intervals(intervals, cap=None):
+def _append_micro_phase(T, delta, max_extra=8):
     """
-    Normalize a list of intervals to non-negative integer endpoints with
-    positive length. Optionally truncate to cap elements.
+    Append a small micro-phase of sparse long-range caps near the end.
     """
-    if not intervals:
+    if max_extra <= 0:
+        return
+    lo = min(l for l, _ in T)
+    hi = max(r for _, r in T)
+    d2 = max(1, delta // 4)
+    micro = [
+        (lo + 1*d2, lo + 5*d2),
+        (hi - 6*d2, hi - 2*d2),
+        (lo + 3*d2, lo + 8*d2),
+        (hi - 8*d2, hi - 3*d2),
+    ]
+    for i, iv in enumerate(micro):
+        pos = len(T) - (i*2 + 1)
+        if pos < 0:
+            T.append(iv)
+        else:
+            T.insert(pos, iv)
+
+def construct_intervals(max_intervals=9800,
+                        depth=6,
+                        rotate_starts=True,
+                        reverse_block_parity=True,
+                        interleave_blocks=True,
+                        micro_phase=True):
+    """
+    Crossover Kierstead–Trotter expansion:
+      - Adaptive depth under max_intervals.
+      - Rotating start patterns to diversify geometry.
+      - Optional block-halving reversal, interleaving, in-round gadget, and end micro-phase.
+    Returns a list of integer-open intervals [(l,r),...].
+    """
+    # A small cycle of four-start patterns to rotate each round
+    start_patterns = [
+        [2, 6, 10, 14],
+        [1, 5, 9, 13],
+        [3, 7, 11, 15],
+        [2, 4, 8, 12],
+    ]
+
+    # seed with a single unit interval to keep initial omega=1
+    T = [(0.0, 1.0)]
+
+    # figure out how many full rounds we can afford
+    rounds = _rounds_allowed_under_cap(max_intervals, base_size=1,
+                                       copies=4, connectors=4,
+                                       target=depth)
+
+    for r in range(rounds):
+        lo = min(l for l, _ in T)
+        hi = max(r for _, r in T)
+        delta = hi - lo if hi > lo else 1.0
+
+        # pick start pattern this round
+        starts = start_patterns[r % len(start_patterns)] if rotate_starts else start_patterns[0]
+
+        # build the four translated blocks
+        blocks = _build_blocks(T, delta, lo, starts, reverse_block_parity)
+
+        # interleave or concatenate
+        S = _interleave_blocks(blocks, interleave_blocks, r)
+
+        # connectors
+        _add_connectors(S, starts, delta)
+
+        # inject a small in-round gadget on the last expansion to boost FF early
+        if micro_phase and r == rounds - 1:
+            # three fraction-based caps
+            for a_frac, b_frac in [(0.08, 0.60), (0.25, 0.75), (0.75, 0.92)]:
+                l0 = lo + a_frac * delta
+                r0 = lo + b_frac * delta
+                if r0 > l0:
+                    S.append((l0, r0))
+
+        T = S
+
+    # final micro-phase sprinkling
+    if micro_phase and len(T) + 8 <= max_intervals:
+        # reuse last delta
+        lo = min(l for l, _ in T)
+        hi = max(r for _, r in T)
+        delta = max(1.0, hi - lo)
+        _append_micro_phase(T, delta, max_extra=8)
+
+    # normalize to nonnegative integer endpoints
+    if not T:
         return []
-    min_l = min(l for (l, _) in intervals)
+    min_l = min(l for l, _ in T)
     if min_l < 0:
-        intervals = [(l - min_l, r - min_l) for (l, r) in intervals]
+        T = [(l - min_l, r - min_l) for l, r in T]
+
     out = []
-    for (l, r) in intervals:
+    for (l, r) in T:
         li = int(round(l))
         ri = int(round(r))
         if ri <= li:
             ri = li + 1
         out.append((li, ri))
-    if cap is not None and len(out) > cap:
-        out = out[:cap]
+
+    # truncate to budget
+    if len(out) > max_intervals:
+        out = out[:max_intervals]
     return out
-
-def _append_micro_phase(T, lo, hi, delta, max_extra=8):
-    """Append a small micro-phase at the end to sprinkle long caps, bounded by max_extra."""
-    if max_extra <= 0:
-        return T
-    d2 = max(1, delta // 4)
-    micro = [
-        (lo + 1 * d2, lo + 5 * d2),
-        (hi - 6 * d2, hi - 2 * d2),
-        (lo + 3 * d2, lo + 8 * d2),
-        (hi - 8 * d2, hi - 3 * d2),
-    ]
-    for i, interval in enumerate(micro):
-        pos = len(T) - (i * 2 + 1)
-        if pos < 0:
-            T.append(interval)
-        else:
-            T.insert(pos, interval)
-    return T
-
-def construct_intervals(max_intervals=9800,
-                        depth=6,
-                        rotate_starts=True,
-                        reverse_block_parity=True,
-                        interleave_blocks=False,
-                        micro_phase=True):
-    """
-    Classic four-start, six-round recursive construction with 4 connectors per round,
-    augmented by a cross-over friendly modular structure.
-
-    Returns:
-      intervals: list[(l, r)] of open intervals with integer endpoints, in arrival order.
-    """
-    # Deterministic four-pattern cycle (ascending starts)
-    start_patterns = [
-        (2, 6, 10, 14),  # classic 4-wave
-        (1, 5, 9, 13),   # left-shifted
-        (3, 7, 11, 15),  # right-shifted
-        (2, 4, 8, 12),   # compressed variant
-    ]
-
-    # Seed with a single unit interval; keeps omega small and enables many rounds
-    T = [(0, 1)]
-
-    # Compute allowed depth given budget
-    target_rounds = max(0, int(depth))
-    rounds_allowed, _ = _rounds_allowed_under_cap(
-        max_intervals=max_intervals,
-        base_size=1,
-        per_round_copies=4,
-        per_round_connectors=4,
-        target_rounds=target_rounds
-    )
-    if rounds_allowed <= 0:
-        return [(0, 1)]
-
-    # Main expansion
-    for round_idx in range(rounds_allowed):
-        lo = min(l for l, _ in T)
-        hi = max(r for _, r in T)
-        delta = hi - lo
-        if delta <= 0:
-            delta = 1
-
-        starts = start_patterns[round_idx % len(start_patterns)] if rotate_starts else start_patterns[0]
-
-        # Build four translated blocks in sequential order (no interleaving by default)
-        blocks = _build_translated_blocks(T, delta, lo, starts)
-
-        # Interleave blocks if requested
-        S = []
-        if interleave_blocks:
-            maxlen = max((len(b) for b in blocks), default=0)
-            order = list(range(len(blocks)))
-            if round_idx % 2 == 1:
-                order = order[::-1]
-            krot = round_idx % len(order)
-            order = order[krot:] + order[:krot]
-            for i in range(maxlen):
-                for idx in order:
-                    blk = blocks[idx]
-                    if i < len(blk):
-                        S.append(blk[i])
-        else:
-            for blk in blocks:
-                S.extend(blk)
-
-        # Deterministic connectors (caps) derived from the first four starts
-        _append_connectors(S, delta, starts)
-
-        T = S
-
-    # Optional micro-phase sprinkled at end
-    if micro_phase and len(T) + 8 <= max_intervals:
-        lo = min(l for l, _ in T)
-        hi = max(r for _, r in T)
-        delta = max(1, hi - lo)
-        T = _append_micro_phase(T, lo, hi, delta, max_extra=8)
-
-    # Normalize and cap
-    intervals = _normalize_to_int_intervals(T, cap=max_intervals)
-    return intervals
 
 # EVOLVE-BLOCK-END
 
 def run_experiment(**kwargs):
   """Main called by evaluator"""
   return construct_intervals()