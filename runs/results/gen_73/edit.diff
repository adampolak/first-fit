--- a/original.py
+++ b/original.py
@@ -1,406 +1,353 @@
 # EVOLVE-BLOCK-START
 
 from math import gcd
 
 # ------------------------------
-# Overlap and sweep utilities
-# ------------------------------
-
-def overlaps(a, b):
-    """Open-interval overlap test: return True iff intervals overlap."""
-    (l1, r1), (l2, r2) = a, b
-    return max(l1, l2) < min(r1, r2)
+# Basic geometry / utilities
+# ------------------------------
+
+def normalize_to_grid(intervals):
+    """
+    Map endpoints to a compact even-integer grid while preserving order.
+    Returns list of integer-intervals (l,r).
+    """
+    if not intervals:
+        return []
+    pts = sorted({x for seg in intervals for x in seg})
+    mapping = {}
+    cur = 0
+    for p in pts:
+        mapping[p] = cur
+        cur += 2
+    return [(mapping[l], mapping[r]) for (l, r) in intervals]
 
 def clique_number(intervals):
     """
-    Compute omega (maximum number of intervals covering a single point) using sweep.
-    Open intervals: endpoints do not contribute; handle right(-1) before left(+1) at ties.
+    Sweep-line for open intervals (right endpoint processed before left on ties).
+    intervals assumed integer but works for floats as well.
     """
     events = []
     for (l, r) in intervals:
         if l >= r:
             continue
         events.append((l, +1))
         events.append((r, -1))
     if not events:
         return 0
     events.sort(key=lambda e: (e[0], 0 if e[1] == -1 else 1))
-    cur = 0
-    best = 0
-    for _, t in events:
-        cur += t
+    cur = best = 0
+    for _, delta in events:
+        cur += delta
         if cur > best:
             best = cur
     return best
 
-# ------------------------------
-# FirstFit simulation
-# ------------------------------
-
 def firstfit_colors(intervals):
     """
-    Simulate FirstFit coloring on the given arrival order.
-    Return total number of colors used.
-    """
-    colors = []  # list of color classes; each is a list of intervals in arrival order
-    for iv in intervals:
+    Efficient FirstFit simulation: for each color remember rightmost endpoint.
+    Place interval in first color whose last_end <= l (open intervals).
+    """
+    last_end = []
+    for (l, r) in intervals:
         placed = False
-        for c in colors:
-            conflict = False
-            for u in c:
-                if overlaps(u, iv):
-                    conflict = True
-                    break
-            if not conflict:
-                c.append(iv)
+        for i in range(len(last_end)):
+            if l >= last_end[i]:
+                last_end[i] = r
                 placed = True
                 break
         if not placed:
-            colors.append([iv])
-    return len(colors)
-
-# ------------------------------
-# Pattern builder (4-copy + 4-blockers)
-# ------------------------------
-
-def make_copies(T, offsets, delta, lo, center, translation):
-    """
-    Create translated copies of T according to offsets and translation rule.
-    translation in {'left', 'center'}.
-    """
-    S = []
-    for start in offsets:
-        if translation == 'left':
-            offset = delta * start - lo
-        else:
-            offset = delta * start - center
-        for (l, r) in T:
-            S.append((l + offset, r + offset))
-    return S
-
-def add_blockers(S, blockers, delta, anchor, center):
-    """
-    Add blockers scaled by delta. Anchor may be 'left' (absolute) or 'center' (center-shifted).
-    """
-    for (a, b) in blockers:
-        if anchor == 'left':
-            S.append((delta * a, delta * b))
-        else:
-            S.append((delta * a - center, delta * b - center))
-    return S
-
-def build_pattern(k, base_seed, offsets, blockers, translation, blocker_anchor,
-                  schedule='after', interleave='block', reverse_alt=False):
-    """
-    Recursively expand the base_seed k times using the multi-copy + blockers scheme.
-    New controls:
-      - schedule: 'after' (copies then blockers), 'before' (blockers then copies),
-                  'split' (first half copies, blockers, second half copies)
-      - interleave: 'block' (emit full copies contiguously), 'zip' (round-robin)
-      - reverse_alt: if True, every other copy is presented in reversed order
-    """
-    T = list(base_seed)
-    for _ in range(k):
+            last_end.append(r)
+    return len(last_end)
+
+# ------------------------------
+# Pattern builder (4-copy + blockers)
+# ------------------------------
+
+def build_recursive(base_seed, k, offsets, blockers, translation='left', schedule='after', interleave='block'):
+    """
+    Recursive expansion. Parameters:
+      - base_seed: list of (l,r) floats
+      - k: recursion depth
+      - offsets: tuple/list of numeric offsets (e.g., (2,6,10,14))
+      - blockers: list/tuple of (a,b) pairs describing scaled blocker positions
+      - translation: 'left' or 'center' (how we anchor copies)
+      - schedule: 'after' (copies then blockers) or 'split' (half copies, blockers, rest)
+      - interleave: 'block' (emit copies contiguously) or 'zip' (round-robin)
+    """
+    T = [tuple(s) for s in base_seed]
+    for level in range(k):
         lo = min(l for l, r in T)
         hi = max(r for l, r in T)
         delta = hi - lo
         center = (lo + hi) / 2.0
 
-        # Build per-copy lists
+        # Build each translated copy list
         copy_lists = []
         for idx, start in enumerate(offsets):
             if translation == 'left':
                 off = delta * start - lo
             else:
                 off = delta * start - center
-            seq = T if not (reverse_alt and (idx % 2 == 1)) else list(reversed(T))
-            copy_lists.append([(l + off, r + off) for (l, r) in seq])
+            copy_lists.append([(l + off, r + off) for (l, r) in T])
 
         # Interleave copies
         if interleave == 'zip' and copy_lists:
-            m = len(copy_lists[0])
+            # round robin by position within a copy
+            m = max(len(lst) for lst in copy_lists)
             S_copies = []
             for j in range(m):
                 for lst in copy_lists:
-                    S_copies.append(lst[j])
+                    if j < len(lst):
+                        S_copies.append(lst[j])
         else:
-            # default: block copies contiguously
             S_copies = []
             for lst in copy_lists:
                 S_copies.extend(lst)
 
-        # Build blockers for this level
+        # Build blockers scaled by delta, anchored
         S_blockers = []
         for (a, b) in blockers:
-            if blocker_anchor == 'left':
+            if translation == 'left':
                 S_blockers.append((delta * a, delta * b))
             else:
                 S_blockers.append((delta * a - center, delta * b - center))
 
         # Compose according to schedule
-        if schedule == 'before':
-            S = S_blockers + S_copies
-        elif schedule == 'split' and copy_lists:
+        if schedule == 'split' and copy_lists:
             h = max(1, len(copy_lists) // 2)
-            first_half = []
+            first = []
             for i in range(h):
-                first_half.extend(copy_lists[i])
-            second_half = []
+                first.extend(copy_lists[i])
+            second = []
             for i in range(h, len(copy_lists)):
-                second_half.extend(copy_lists[i])
-            S = first_half + S_blockers + second_half
+                second.extend(copy_lists[i])
+            S = first + S_blockers + second
         else:
-            S = S_copies + S_blockers
+            # default 'after' or 'before' with fallback: copies then blockers
+            if schedule == 'before':
+                S = S_blockers + S_copies
+            else:
+                S = S_copies + S_blockers
 
         T = S
     return T
 
 # ------------------------------
-# Normalization and evaluation
-# ------------------------------
-
-def normalize_intervals(intervals):
-    """
-    Normalize to small integer coordinates:
-    - scale by 2 to eliminate .5 if produced by center shifts
-    - translate so min coordinate is >= 0
-    - divide by global gcd to shrink
-    """
-    if not intervals:
-        return intervals
-    scaled = []
-    for (l, r) in intervals:
-        L = int(round(l * 2))
-        R = int(round(r * 2))
-        scaled.append((L, R))
-    min_coord = min(min(l, r) for l, r in scaled)
-    shifted = [(l - min_coord, r - min_coord) for (l, r) in scaled]
-    vals = []
-    for (l, r) in shifted:
-        vals.append(abs(l))
-        vals.append(abs(r))
-    g = 0
-    for v in vals:
-        g = gcd(g, v)
-    if g > 1:
-        shrunk = [(l // g, r // g) for (l, r) in shifted]
-    else:
-        shrunk = shifted
-    return shrunk
-
-def evaluate(intervals):
-    """
-    Compute FF colors and omega, with a small penalty for ridiculously large outputs.
-    Return (score, omega, num_colors, n, intervals_normalized)
-    """
-    Tn = normalize_intervals(intervals)
+# Pruning / shrinking
+# ------------------------------
+
+def shrink_strict(intervals, target_cols, target_omega, max_passes=3):
+    """
+    Remove intervals (greedily) while preserving exact (cols, omega).
+    Prefer removing longer intervals first (likely redundant blockers).
+    """
+    cur = list(intervals)
+    passes = 0
+    while passes < max_passes:
+        removed = False
+        # order by descending length then index
+        order = sorted(range(len(cur)), key=lambda i: (-(cur[i][1] - cur[i][0]), i))
+        for idx in order:
+            cand = cur[:idx] + cur[idx+1:]
+            Tn = normalize_to_grid(cand)
+            if not Tn:
+                continue
+            om = clique_number(Tn)
+            if om != target_omega:
+                continue
+            cols = firstfit_colors(Tn)
+            if cols == target_cols:
+                cur = cand
+                removed = True
+                break
+        if not removed:
+            break
+        passes += 1
+    return cur
+
+def prune_relaxed(intervals, min_ratio, max_omega, max_passes=4):
+    """
+    Greedy, relaxed pruning: remove intervals while keeping ratio >= min_ratio
+    and omega <= max_omega. Prefer removing short intervals first to shrink footprint.
+    """
+    cur = list(intervals)
+    passes = 0
+    while passes < max_passes:
+        removed = False
+        # prefer short intervals first (they are often redundant)
+        order = sorted(range(len(cur)), key=lambda i: ((cur[i][1] - cur[i][0]), i))
+        for idx in order:
+            cand = cur[:idx] + cur[idx+1:]
+            Tn = normalize_to_grid(cand)
+            if not Tn:
+                continue
+            om = clique_number(Tn)
+            if om == 0 or om > max_omega:
+                continue
+            cols = firstfit_colors(Tn)
+            ratio = cols / om
+            if ratio + 1e-12 >= min_ratio and om <= max_omega:
+                cur = cand
+                removed = True
+                break
+        if not removed:
+            break
+        passes += 1
+    return cur
+
+def final_shrinker(intervals, target_ratio, target_omega):
+    """
+    Final single-interval removal shrinker. Remove any single interval that
+    keeps ratio >= target_ratio and omega == target_omega. Repeat to fixpoint.
+    Deterministic order: try intervals that produce smallest loss first.
+    """
+    cur = list(intervals)
+    while True:
+        removed = False
+        n = len(cur)
+        # compute per-interval impact score (quick heuristic): short intervals first
+        order = sorted(range(n), key=lambda i: ((cur[i][1] - cur[i][0]), i))
+        for idx in order:
+            cand = cur[:idx] + cur[idx+1:]
+            Tn = normalize_to_grid(cand)
+            if not Tn:
+                continue
+            om = clique_number(Tn)
+            if om != target_omega:
+                continue
+            cols = firstfit_colors(Tn)
+            if om > 0 and cols / om + 1e-12 >= target_ratio:
+                cur = cand
+                removed = True
+                break
+        if not removed:
+            break
+    return cur
+
+# ------------------------------
+# Search controller
+# ------------------------------
+
+def evaluate_candidate(raw_intervals):
+    """
+    Normalize and compute (ratio, omega, cols, n, normalized_intervals).
+    Returns tuple for comparing candidates.
+    """
+    Tn = normalize_to_grid(raw_intervals)
     n = len(Tn)
     if n == 0:
-        return (-1.0, 0, 0, n, Tn)
+        return (-1.0, 0, 0, 0, [])
     om = clique_number(Tn)
     if om == 0:
         return (-1.0, 0, 0, n, Tn)
     cols = firstfit_colors(Tn)
     ratio = cols / om
-    score = ratio - 1e-6 * (n / 10000.0)
-    return (score, om, cols, n, Tn)
-
-# ------------------------------
-# Pruning: strict then relaxed
-# ------------------------------
-
-def prune_strict(intervals, target_cols, target_omega):
-    """
-    Strict pruning: remove any interval whose removal keeps both FirstFit colors and omega unchanged.
-    Deterministic order: try longer intervals first to remove redundant long blockers if any.
-    """
-    cur = list(intervals)
-    def length(iv): return iv[1] - iv[0]
-    order = sorted(range(len(cur)), key=lambda i: (-length(cur[i]), i))
-    changed = True
-    while changed:
-        changed = False
-        for idx in list(order):
-            if idx >= len(cur):
-                continue
-            cand = cur[:idx] + cur[idx+1:]
-            Tn = normalize_intervals(cand)
-            om = clique_number(Tn)
-            cols = firstfit_colors(Tn)
-            if om == target_omega and cols == target_cols:
-                cur = cand
-                order = sorted(range(len(cur)), key=lambda i: (-length(cur[i]), i))
-                changed = True
-                break
-    return cur
-
-def prune_relaxed(intervals, min_ratio, max_omega):
-    """
-    Relaxed pruning: remove intervals if the ratio remains >= min_ratio and omega <= max_omega.
-    Prefer to remove longer intervals first; greedily iterate to fixpoint.
-    """
-    cur = list(intervals)
-    def length(iv): return iv[1] - iv[0]
-    order = sorted(range(len(cur)), key=lambda i: (-length(cur[i]), i))
-    changed = True
-    while changed:
-        changed = False
-        for idx in list(order):
-            if idx >= len(cur):
-                continue
-            cand = cur[:idx] + cur[idx+1:]
-            Tn = normalize_intervals(cand)
-            om = clique_number(Tn)
-            if om == 0 or om > max_omega:
-                continue
-            cols = firstfit_colors(Tn)
-            ratio = cols / om
-            if ratio + 1e-12 >= min_ratio and om <= max_omega:
-                cur = cand
-                order = sorted(range(len(cur)), key=lambda i: (-length(cur[i]), i))
-                changed = True
-                break
-    return cur
-
-# ------------------------------
-# Orchestrator
-# ------------------------------
+    # small penalty for larger n to break ties slightly
+    score = ratio - 1e-8 * (n / 1000.0)
+    return (score, ratio, om, cols, n, Tn)
 
 def construct_intervals():
     """
-    Build a sequence of open intervals that aims to maximize FirstFit/OPT.
-    We sweep several recommended blueprints and pick the best validated candidate.
-    Then run a conservative two-phase pruning to reduce interval count without hurting the ratio.
-    """
-    # search space inspired by the provided recommendations
-    offsets_set = [
-        (2, 6, 10, 14),        # baseline
-        (1, 5, 9, 13),         # shift left
-        (3, 7, 11, 15),        # shift right
-        (0, 4, 8, 12),         # anchored at 0
-        (1.5, 5.5, 9.5, 13.5), # half-step stagger
-        (2, 6, 9, 14),         # slight skew
-        (2, 7, 11, 14),        # shifted second copy
+    Focused search over promising blueprints, then deterministic two-phase pruning
+    and final shrinker. Return normalized integer intervals.
+    """
+    # Base seeds
+    base_seeds = [
+        [(0.0, 1.0)],
     ]
+
+    # Offsets sets to test (centered around canonical baseline)
+    offsets_choices = [
+        (2, 6, 10, 14),   # baseline
+        (1, 5, 9, 13),    # shift left
+        (3, 7, 11, 15),   # shift right
+        (0, 4, 8, 12),    # anchored at 0
+    ]
+
+    # Blocker templates: A (baseline), B, C (new)
     blockers_templates = [
-        # Template A: baseline
-        ((1, 5), (12, 16), (4, 9), (8, 13)),
-        # Template B: early/late shorter
-        ((0, 4), (6, 10), (8, 12), (14, 18)),
-        # Template C: tighter middle coupling
-        ((2, 6), (4, 8), (10, 14), (12, 16)),
-        # Template D: asymmetric nudges
-        ((1, 5), (12, 16), (3, 7), (9, 13)),
-        # Template E: lengthened extremes
-        ((1, 6), (11, 16), (4, 8), (10, 14)),
-        # Template F: six-blocker couplers (adds two caps)
-        ((1, 5), (12, 16), (4, 9), (8, 13), (2, 14), (6, 10)),
+        ((1, 5), (12, 16), (4, 9), (8, 13)),            # A baseline
+        ((0.5, 4.5), (11.5, 15.5), (3.5, 8.5), (7.5, 12.5)),  # B shifted/shorter extremes
+        ((1, 6), (10, 15), (4, 9), (8, 13)),            # C longer caps
     ]
-    translations = ['left', 'center']  # how copies are positioned
-    blocker_anchors = ['left', 'center']  # how blockers are positioned
-    depths = [3, 4, 5]  # sweep as recommended
-    schedules = ['after', 'before', 'split']
+
+    translations = ['left', 'center']
+    schedules = ['after', 'split']   # avoid 'before' (less promising)
     interleaves = ['block', 'zip']
-    reverse_flags = [False, True]
-    base_seeds = [
-        [(0.0, 1.0)],                      # single seed (classic)
-        [(0.0, 1.0), (2.0, 3.0)],          # two disjoint seeds variant
-    ]
-    extra_copies_opts = [0, 1, 2]  # allow up to two extra translated copies on first level
-
-    best = None  # (score, om, cols, n, intervals_norm, raw_intervals)
-    # Enumerate combinations with a guard on worst-case explosion
+    depths = [3, 4, 5]  # explore around proved sweet spots
+
+    best = None  # (score, ratio, om, cols, n, normalized_intervals, raw_intervals)
+
+    # Size guard to avoid explosion: approx copies^(k)
     for base in base_seeds:
         for k in depths:
-            for offsets in offsets_set:
+            for offsets in offsets_choices:
                 for blockers in blockers_templates:
                     for translation in translations:
-                        for anchor in blocker_anchors:
-                            for extra in extra_copies_opts:
-                                offs = list(offsets)
-                                if extra >= 1:
-                                    last = offs[-1] if offs else 0
-                                    offs.append(last + 4)
-                                if extra == 2:
-                                    last2 = offs[-2] if len(offs) >= 2 else (offs[-1] if offs else 0)
-                                    offs.append(last2 + 8)
-                                offs = tuple(offs)
-
-                                # crude size guard adjusted for arbitrary number of copies per level
-                                approx = (len(offs) ** k) * (len(base) + len(blockers))
-                                if approx > 3500:
+                        for schedule in schedules:
+                            for interleave in interleaves:
+                                # approximate size
+                                approx_copies = len(offsets) ** k
+                                approx = approx_copies * (len(base) + len(blockers))
+                                if approx > 5000:
                                     continue
-
-                                for schedule in schedules:
-                                    for interleave in interleaves:
-                                        for rev in reverse_flags:
-                                            T = build_pattern(
-                                                k=k,
-                                                base_seed=base,
-                                                offsets=offs,
-                                                blockers=blockers,
-                                                translation=translation,
-                                                blocker_anchor=anchor,
-                                                schedule=schedule,
-                                                interleave=interleave,
-                                                reverse_alt=rev,
-                                            )
-                                            score, om, cols, n, Tn = evaluate(T)
-                                            cand = (score, om, cols, n, Tn, T)
-                                            if best is None:
-                                                best = cand
-                                            else:
-                                                if cand[0] > best[0] + 1e-9:
-                                                    best = cand
-                                                elif abs(cand[0] - best[0]) <= 1e-9:
-                                                    if cand[3] < best[3]:
-                                                        best = cand
-                                                    elif cand[3] == best[3] and cand[2] > best[2]:
-                                                        best = cand
-
-    # Fallback to baseline if search didn't produce anything
+                                raw = build_recursive(base, k, offsets, blockers,
+                                                      translation=translation,
+                                                      schedule=schedule,
+                                                      interleave=interleave)
+                                score, ratio, om, cols, n, Tn = evaluate_candidate(raw)
+                                if om == 0:
+                                    continue
+                                cand = (score, ratio, om, cols, n, Tn, raw)
+                                if best is None:
+                                    best = cand
+                                else:
+                                    # prefer higher score; tiebreak by fewer intervals then higher cols
+                                    if cand[0] > best[0] + 1e-12:
+                                        best = cand
+                                    elif abs(cand[0] - best[0]) <= 1e-12:
+                                        if cand[4] < best[4]:
+                                            best = cand
+                                        elif cand[4] == best[4] and cand[3] > best[3]:
+                                            best = cand
+
+    # fallback baseline
     if best is None:
-        k = 4
-        T = [(0.0, 1.0)]
-        for _ in range(k):
-            lo = min(l for l, r in T)
-            hi = max(r for l, r in T)
-            delta = hi - lo
-            S = []
-            for start in (2, 6, 10, 14):
-                offset = delta * start - lo
-                for (l, r) in T:
-                    S.append((l + offset, r + offset))
-            S += [
-                (delta * 1,  delta * 5),
-                (delta * 12, delta * 16),
-                (delta * 4,  delta * 9),
-                (delta * 8,  delta * 13),
-            ]
-            T = S
-        return normalize_intervals(T)
-
-    # Apply two-phase pruning to the raw best intervals
-    raw_best = best[5]
-    _, best_om, best_cols, _, _, _ = best
-    # Phase 1: strict pruning (keep alg and omega identical)
-    phase1 = prune_strict(raw_best, best_cols, best_om)
-    # Phase 2: relaxed pruning (keep ratio and omega cap)
-    target_ratio = best_cols / best_om if best_om > 0 else 0.0
-    phase2 = prune_relaxed(phase1, target_ratio, best_om)
-
-    final = normalize_intervals(phase2)
-    if not final:
-        return best[4]
-    # Final safety: if ratio dropped (shouldn't), revert to best normalized
-    om = clique_number(final)
-    cols = firstfit_colors(final)
-    if om == 0 or cols / om + 1e-12 < target_ratio or om > best_om:
-        return best[4]
-    return final
+        # use canonical k=4 baseline
+        raw = build_recursive([(0.0, 1.0)], 4, (2, 6, 10, 14),
+                              ((1,5),(12,16),(4,9),(8,13)), translation='left', schedule='after', interleave='block')
+        return normalize_to_grid(raw)
+
+    # Extract best candidate
+    _, best_ratio, best_om, best_cols, _, best_norm, best_raw = best
+
+    # Phase 1: strict pruning (preserve exact cols and omega)
+    phase1 = shrink_strict(best_raw, best_cols, best_om, max_passes=4)
+
+    # Phase 2: relaxed pruning (preserve ratio >= best_ratio and omega <= best_om)
+    phase2 = prune_relaxed(phase1, best_ratio, best_om, max_passes=6)
+
+    # Final shrinker: remove any single interval keeping ratio and omega identical to cap
+    phase3 = final_shrinker(phase2, best_ratio, best_om)
+
+    final_norm = normalize_to_grid(phase3)
+    if not final_norm:
+        # if something went wrong, return the best normalized found earlier
+        return best_norm
+
+    # safety check: ensure ratio preserved (within tiny epsilon) and omega not increased
+    om_final = clique_number(final_norm)
+    if om_final == 0:
+        return best_norm
+    cols_final = firstfit_colors(final_norm)
+    ratio_final = cols_final / om_final
+    if om_final <= best_om and ratio_final + 1e-11 >= best_ratio - 1e-11:
+        return final_norm
+    # otherwise fallback
+    return best_norm
 
 # EVOLVE-BLOCK-END
 
 def run_experiment(**kwargs):
   """Main called by evaluator"""
   return construct_intervals()