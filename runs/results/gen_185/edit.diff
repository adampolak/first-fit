--- a/original.py
+++ b/original.py
@@ -1,200 +1,324 @@
 # EVOLVE-BLOCK-START
 
 def construct_intervals(iterations=4):
   """
   Construct a sequence of intervals to maximize FirstFit/omega.
   Modular, fast variant with a small, fixed set of template patterns.
 
   Returns:
     List of tuples (l, r) on a compact integer grid.
   """
 
   # Lightweight helpers (pure-Python, no external deps)
 
   def _normalize_grid(intervals):
     """Map unique endpoints to increasing even integers starting at 0."""
     if not intervals:
       return []
     endpoints = sorted({x for seg in intervals for x in seg})
     coord = {}
     cur = 0
     for e in endpoints:
       coord[e] = cur
       cur += 2  # keep even gaps
     return [(coord[l], coord[r]) for (l, r) in intervals]
 
   def _firstfit_colors(intervals):
     """
-    Simulated FirstFit with a simple per-color end-tracking rule.
-    We keep for each color the rightmost end of its last interval and allow
-    reuse if the new interval starts after that end.
-    Returns number of colors used.
-    """
-    last_end = []  # per-color last end
-    for (l, r) in intervals:
+    Strict FirstFit for open intervals:
+    assign each arriving interval to the first color class whose intervals
+    do not overlap it; otherwise open a new color.
+    """
+    def _overlap(a, b):
+      (l1, r1), (l2, r2) = a, b
+      return max(l1, l2) < min(r1, r2)
+
+    colors = []
+    for iv in intervals:
       placed = False
-      for i, end in enumerate(last_end):
-        if l >= end:
-          last_end[i] = r
+      for c in colors:
+        conflict = False
+        for u in c:
+          if _overlap(u, iv):
+            conflict = True
+            break
+        if not conflict:
+          c.append(iv)
           placed = True
           break
       if not placed:
-        last_end.append(r)
-    return len(last_end)
+        colors.append([iv])
+    return len(colors)
 
   def _clique_number(intervals):
     """
     Exact clique number via sweep-line on open intervals.
     Treat (l, r) as open; count active intervals between endpoints.
     """
-    # Build events: (position, delta); open at l, close at r
     ev = []
     for (l, r) in intervals:
       if l < r:
-        ev.append((l, 1))
+        ev.append((l, +1))
         ev.append((r, -1))
-    # sort by position; for ties, end (-1) before start (+1) to model open intervals
-    ev.sort(key=lambda x: (x[0], x[1]))
+    # sort: at ties process closures (-1) before openings (+1)
+    ev.sort(key=lambda x: (x[0], 0 if x[1] == -1 else 1))
     cur = 0
     best = 0
     for _, d in ev:
       cur += d
       if cur > best:
         best = cur
     return best
 
   def _make_candidate_template(k, offsets=(2,6,10,14), extra_first=False, translation='left', schedule='after'):
     """
     Construct a k-level recursive pattern with four copies per level plus the four blockers.
     translation: 'left' (baseline) or 'center' (center-based shifting).
     schedule: how to lay out (simplified to 'after','before','split' variants).
     extra_first: optionally add a 5th copy on level 0 to increase geometry.
     """
     T = [(0.0, 1.0)]
     for lvl in range(k):
       lo = min(l for l, r in T)
       hi = max(r for l, r in T)
       delta = hi - lo
       center = (lo + hi) / 2.0
 
       offs = list(offsets)
       if extra_first and lvl == 0:
         offs.append(18)
 
       def _offset_for(start):
         if translation == 'left':
           return delta * start - lo
         else:  # center translation
           return delta * start - center
 
       # build copies
       copy_seq = []
       for s in offs:
         off = _offset_for(s)
         for (l, r) in T:
           copy_seq.append((l + off, r + off))
 
       blockers = [
         (delta * 1,  delta * 5),
         (delta * 12, delta * 16),
         (delta * 4,  delta * 9),
         (delta * 8,  delta * 13),
       ]
 
       if schedule == 'after':
         T = copy_seq + blockers
       elif schedule == 'before':
         T = blockers + copy_seq
       else:  # 'split'
         h = max(1, len(offs) // 2)
         first = offs[:h]
         second = offs[h:]
         first_seq = []
         for s in first:
           off = _offset_for(s)
           for (l, r) in T:
             first_seq.append((l + off, r + off))
         second_seq = []
         for s in second:
           off = _offset_for(s)
           for (l, r) in T:
             second_seq.append((l + off, r + off))
         T = first_seq + blockers + second_seq
 
     return T
 
-  # Candidate configuration space (compact and deterministic)
+  # Coverage utilities (for augmentation)
+  def _coverage_cells(intervals):
+    """
+    Decompose the line into open cells (a,b) where coverage is constant.
+    Returns list of (a,b,m) with m the number of covering intervals on (a,b).
+    """
+    ev = []
+    for (l, r) in intervals:
+      if l < r:
+        ev.append((l, +1))
+        ev.append((r, -1))
+    if not ev:
+      return []
+    ev.sort(key=lambda x: (x[0], 0 if x[1] == -1 else 1))
+    xs = sorted({x for x, _ in ev})
+    # sweep to get coverage right after each endpoint
+    cur = 0
+    idx = 0
+    cells = []
+    # accumulate deltas at each coordinate in order
+    for i in range(len(xs)-1):
+      x = xs[i]
+      y = xs[i+1]
+      while idx < len(ev) and ev[idx][0] == x:
+        cur += ev[idx][1]
+        idx += 1
+      if x < y:
+        cells.append((x, y, cur))
+    return cells
+
+  def _augment_corridor(intervals):
+    """
+    Try to add one or two 'wave' intervals inside a long run where coverage <= omega-1.
+    Accept only if omega stays unchanged and FirstFit colors strictly increase.
+    """
+    if not intervals:
+      return intervals
+    omega = _clique_number(intervals)
+    if omega <= 0:
+      return intervals
+    cells = _coverage_cells(intervals)
+    # find longest run with coverage <= omega-1
+    best_L = None
+    best_R = None
+    acc_L = None
+    acc_R = None
+    acc_ok = False
+    longest = -1.0
+    prev_r = None
+    for (a, b, m) in cells:
+      if m <= omega - 1:
+        if acc_L is None:
+          acc_L, acc_R = a, b
+        else:
+          # contiguous?
+          if prev_r is not None and abs(a - prev_r) < 1e-12:
+            acc_R = b
+          else:
+            # gap; finalize previous
+            if acc_L is not None and acc_R - acc_L > longest:
+              best_L, best_R = acc_L, acc_R
+              longest = acc_R - acc_L
+            acc_L, acc_R = a, b
+      else:
+        if acc_L is not None and acc_R - acc_L > longest:
+          best_L, best_R = acc_L, acc_R
+          longest = acc_R - acc_L
+        acc_L = acc_R = None
+      prev_r = b
+    if acc_L is not None and acc_R - acc_L > longest:
+      best_L, best_R = acc_L, acc_R
+      longest = acc_R - acc_L
+
+    if best_L is None or best_R - best_L <= 0:
+      return intervals
+
+    # define tiny core around the middle
+    L, R = best_L, best_R
+    span = R - L
+    eps = max(1.0, span / 200.0)
+    mid = (L + R) / 2.0
+    core_lo = mid - eps
+    core_hi = mid + eps
+    # candidate wings
+    left_wave = (L + eps, core_hi)
+    right_wave = (core_lo, R - eps)
+
+    base_cols = _firstfit_colors(intervals)
+    base_omega = omega
+
+    # try adding left then right
+    T1 = intervals + [left_wave]
+    if _clique_number(T1) == base_omega and _firstfit_colors(T1) > base_cols:
+      # try to add the second as well
+      T2 = T1 + [right_wave]
+      if _clique_number(T2) == base_omega and _firstfit_colors(T2) > _firstfit_colors(T1):
+        return T2
+      return T1
+
+    # try adding right then left
+    T1 = intervals + [right_wave]
+    if _clique_number(T1) == base_omega and _firstfit_colors(T1) > base_cols:
+      T2 = T1 + [left_wave]
+      if _clique_number(T2) == base_omega and _firstfit_colors(T2) > _firstfit_colors(T1):
+        return T2
+      return T1
+
+    return intervals
   depths = [max(2, iterations - 1), iterations]
   translations = ['left', 'center']
   offset_sets = [
     (2, 6, 10, 14),  # baseline
     (1, 5, 9, 13),   # shifted
     (3, 7, 11, 15),  # alternate
   ]
   schedules = ['after', 'before', 'split']
   extras = [False, True]
 
   best_T = None
   best_ratio = -1.0
   best_n = None
   best_cols = 0
   best_om = 0
 
   # Exhaust a small, fixed set of combinations (keeps runtime small)
   for k in depths:
     for sch in schedules:
       for ex in extras:
         for trans in translations:
           for offs in offset_sets:
             T = _make_candidate_template(k, offsets=offs, extra_first=ex, translation=trans, schedule=sch)
             om = _clique_number(T)
             if om == 0:
               continue
             cols = _firstfit_colors(T)
             ratio = cols / om
 
             n = len(T)
             better = False
             if ratio > best_ratio + 1e-12:
               better = True
             elif abs(ratio - best_ratio) <= 1e-12:
               if best_n is None or n < best_n:
                 better = True
               elif n == best_n and cols > best_cols:
                 better = True
 
             if better:
               best_ratio = ratio
               best_T = T
               best_n = n
               best_cols = cols
               best_om = om
 
   # Fallback: canonical canonical-4-iteration pattern if search failed
   if best_T is None:
     best_T = []
     T = [(0.0, 1.0)]
     for _ in range(4):
       lo = min(l for l, r in T)
       hi = max(r for l, r in T)
       delta = hi - lo
       S = []
       for start in (2, 6, 10, 14):
         S += [(delta * start + l - lo, delta * start + r - lo) for (l, r) in T]
       S += [
         (delta * 1, delta * 5),
         (delta * 12, delta * 16),
         (delta * 4, delta * 9),
         (delta * 8, delta * 13)
       ]
       T = S
     best_T = T
 
+  # Attempt corridor-waves augmentation on the best template
+  aug_T = _augment_corridor(best_T)
+  # Prefer augmented if it improves ratio without increasing omega
+  base_cols = _firstfit_colors(best_T)
+  base_om = _clique_number(best_T)
+  aug_cols = _firstfit_colors(aug_T)
+  aug_om = _clique_number(aug_T)
+  if aug_om == base_om and aug_cols > base_cols:
+    best_T = aug_T
+
   # Normalize and return
   return _normalize_grid(best_T)
 
 # EVOLVE-BLOCK-END
 
 def run_experiment(**kwargs):
   """Main called by evaluator"""
   return construct_intervals()