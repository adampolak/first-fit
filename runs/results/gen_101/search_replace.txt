<NAME>
deeper_search_interleave_cycled_offsets
</NAME>

<DESCRIPTION>
I extend the adversarial search space to include:
- Depth 5 (the 4-copy construction yields 2388 intervals at depth 5, manageable), by relaxing the guard.
- New schedule “interleave” that alternates copies and blockers to increase color coupling.
- Alternating offset patterns across levels by allowing starts to be a cycle (tuple of tuples).
- Separate anchor choices for copies and blockers (translation for copies; blocker_anchor for blockers).
- More offset sets and blocker templates inspired by the recommendations (Templates B/C/D), and slightly skewed offset sets.

These changes are targeted to push FirstFit to use additional colors without increasing the clique number, and to give the search more structural diversity around the best-known constructions. The code remains deterministic and compact.

</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
def _build_candidate(depth, starts, blockers, schedule='after', extra_first=False, translation='left'):
    """
    Build a depth-level recursive pattern using four scaled copies per level and four long connectors.
    - starts: tuple of offsets (multipliers) for the copies
    - blockers: list of 4 pairs (a,b) as multipliers of delta
    - schedule: 'after' | 'before' | 'split' controls the order within a level
    - extra_first: adds a 5th copy (start=18) at the first level to enhance coupling
    - translation: 'left' | 'center' anchor for positioning copies/blockers
    """
    T = [(0.0, 1.0)]
    for i in range(depth):
        lo = min(l for l, r in T)
        hi = max(r for l, r in T)
        delta = hi - lo
        center = (lo + hi) / 2.0

        offs = tuple(starts)
        if extra_first and i == 0 and 18 not in offs:
            offs = offs + (18,)

        def make_copies(from_T, offsets):
            S = []
            for start in offsets:
                if translation == 'left':
                    offset = delta * start - lo
                else:
                    offset = delta * start - center
                for (l, r) in from_T:
                    S.append((l + offset, r + offset))
            return S

        # scale blockers
        if translation == 'left':
            blk = [(delta * a, delta * b) for (a, b) in blockers]
        else:
            blk = [(delta * a - center, delta * b - center) for (a, b) in blockers]

        if schedule == 'after':
            S = make_copies(T, offs) + blk
        elif schedule == 'before':
            S = list(blk) + make_copies(T, offs)
        else:  # split
            h = len(offs) // 2
            S = make_copies(T, offs[:h]) + list(blk) + make_copies(T, offs[h:])

        T = S
    return T
=======
def _build_candidate(depth, starts, blockers, schedule='after', extra_first=False, translation='left', blocker_anchor='left'):
    """
    Build a depth-level recursive pattern using four scaled copies per level and four long connectors.
    - starts: tuple of offsets (multipliers) for the copies, or a cycle (tuple of tuples) alternated per level
    - blockers: list of 4 pairs (a,b) as multipliers of delta
    - schedule: 'after' | 'before' | 'split' | 'interleave' controls the order within a level
    - extra_first: int|bool; if truthy, add a 5th copy (start=18) on the first 'extra_first' levels (bool->1)
    - translation: 'left' | 'center' anchor for positioning copies
    - blocker_anchor: 'left' | 'center' anchor for positioning blockers
    """
    T = [(0.0, 1.0)]
    for i in range(depth):
        lo = min(l for l, r in T)
        hi = max(r for l, r in T)
        delta = hi - lo
        center = (lo + hi) / 2.0

        # Support per-level offset cycles
        if isinstance(starts, (list, tuple)) and starts and isinstance(starts[0], (list, tuple)):
            offs_base = tuple(starts[i % len(starts)])
        else:
            offs_base = tuple(starts)

        # Optional extra copy at start=18 for early levels
        extra_levels = int(extra_first) if isinstance(extra_first, bool) else int(extra_first)
        offs = offs_base
        if extra_levels > 0 and i < extra_levels and 18 not in offs:
            offs = offs + (18,)

        def make_copies(from_T, offsets):
            S = []
            for start in offsets:
                if translation == 'left':
                    offset = delta * start - lo
                else:
                    offset = delta * start - center
                for (l, r) in from_T:
                    S.append((l + offset, r + offset))
            return S

        # scale blockers with their own anchor
        if blocker_anchor == 'left':
            blk = [(delta * a, delta * b) for (a, b) in blockers]
        else:
            blk = [(delta * a - center, delta * b - center) for (a, b) in blockers]

        if schedule == 'after':
            S = make_copies(T, offs) + blk
        elif schedule == 'before':
            S = list(blk) + make_copies(T, offs)
        elif schedule == 'split':
            h = len(offs) // 2
            S = make_copies(T, offs[:h]) + list(blk) + make_copies(T, offs[h:])
        else:  # 'interleave': alternate copies and single blockers to increase coupling
            S = []
            m = max(len(offs), len(blk))
            for j in range(m):
                if j < len(offs):
                    S += make_copies(T, (offs[j],))
                if j < len(blk):
                    S.append(blk[j])

        T = S
    return T
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
def construct_intervals(iterations=4, normalize=True):
    """
    Adaptive search-driven construction. Sweep a modest parameter space (offsets, blockers,
    schedule, translation, extra-first, depth) and return the instance maximizing FirstFit/omega.
    Arguments:
      iterations: maximum recursion depth considered (we try iterations-1 and iterations, min 2)
      normalize: normalize endpoints to a compact integer grid (recommended)
    Returns: list of intervals (l, r) in arrival order.
    """
    depths = sorted(set([max(2, iterations - 1), max(2, iterations)]))

    start_sets = [
        (2, 6, 10, 14),   # canonical
        (1, 5, 9, 13),    # shift left
        (3, 7, 11, 15),   # shift right
        (0, 4, 8, 12),    # leftmost
    ]
    blocker_templates = [
        [(1, 5), (12, 16), (4, 9), (8, 13)],             # canonical
        [(1, 5), (11, 15), (4, 9), (8, 13)],             # slight shift
        [(2, 6), (12, 16), (4, 9), (8, 13)],             # shift first
        [(1, 6), (11, 16), (3, 9), (7, 13)],             # lengthened
    ]
    schedules = ['after', 'before', 'split']
    translations = ['left', 'center']
    extras = [False, True]

    best_T = None
    best_ratio = -1.0
    best_n = None
    best_cols = 0
    best_om = 0

    for d in depths:
        # guard explosion: rough size ~ (4^d)*8; keep manageable
        if (4 ** d) * 8 > 4000:
            continue
        for starts in start_sets:
            for blockers in blocker_templates:
                for sch in schedules:
                    for tr in translations:
                        for ex in extras:
                            T = _build_candidate(d, starts, blockers, schedule=sch, extra_first=ex, translation=tr)
                            om = _omega_open(T)
                            if om == 0:
                                continue
                            cols = _ff_count(T)
                            ratio = cols / om
                            n = len(T)
                            better = False
                            if ratio > best_ratio + 1e-12:
                                better = True
                            elif abs(ratio - best_ratio) <= 1e-12:
                                if best_n is None or n < best_n:
                                    better = True
                                elif n == best_n and cols > best_cols:
                                    better = True
                            if better:
                                best_ratio = ratio
                                best_T = T
                                best_n = n
                                best_cols = cols
                                best_om = om

    # Fallback to canonical if search failed
    if best_T is None:
        best_T = _build_candidate(depth=max(2, iterations), starts=(2, 6, 10, 14),
                                  blockers=[(1, 5), (12, 16), (4, 9), (8, 13)],
                                  schedule='after', extra_first=False, translation='left')

    return _normalize_grid(best_T) if normalize else best_T
=======
def construct_intervals(iterations=4, normalize=True):
    """
    Adaptive search-driven construction. Sweep a modest parameter space (offset cycles, blockers,
    schedule, translation vs blocker-anchors, extra-first depth window, recursion depth)
    and return the instance maximizing FirstFit/omega.
    Arguments:
      iterations: maximum recursion depth considered (we try iterations-1, iterations, iterations+1; min 2)
      normalize: normalize endpoints to a compact integer grid (recommended)
    Returns: list of intervals (l, r) in arrival order.
    """
    depths = sorted(set([max(2, iterations - 1), max(2, iterations), max(2, iterations + 1)]))

    # Offset sets and cycles (cycled per level when a tuple of tuples is provided)
    canonical = (2, 6, 10, 14)
    alt_a = (1, 5, 9, 13)
    alt_b = (3, 7, 11, 15)
    alt_left = (0, 4, 8, 12)
    skew_a = (2, 6, 9, 13)
    skew_b = (3, 6, 10, 13)

    start_sets = [
        canonical, alt_a, alt_b, alt_left, skew_a, skew_b,
        (canonical, alt_a),           # cycle canonical with left-shift
        (canonical, alt_b),           # cycle canonical with right-shift
    ]

    # Blocker templates (Figure-4-like and variants)
    blocker_templates = [
        [(1, 5), (12, 16), (4, 9), (8, 13)],             # canonical
        [(1, 5), (11, 15), (4, 9), (8, 13)],             # slight shift
        [(2, 6), (12, 16), (4, 9), (8, 13)],             # shift first
        [(1, 6), (11, 16), (3, 9), (7, 13)],             # lengthened
        [(0, 4), (7, 11), (3, 7), (10, 14)],             # Template B (staggered)
        [(1, 5), (9, 13), (5, 9), (12, 16)],             # Template C (coupled middle)
        [(3, 8), (7, 12), (11, 16), (15, 20)],           # aggressive staggered
    ]

    schedules = ['after', 'before', 'split', 'interleave']
    translations = ['left', 'center']          # for copies
    blocker_anchors = ['left', 'center']       # separate anchor for blockers
    extras = [0, 1, 2]                         # add extra copy at first 0/1/2 levels

    best_T = None
    best_ratio = -1.0
    best_n = None
    best_cols = 0
    best_om = 0

    for d in depths:
        # Guard explosion: depth 5 yields ~2388 intervals; allow comfortably
        if (4 ** d) * 8 > 25000:
            continue
        for starts in start_sets:
            for blockers in blocker_templates:
                for sch in schedules:
                    for tr in translations:
                        for ba in blocker_anchors:
                            for ex in extras:
                                T = _build_candidate(d, starts, blockers, schedule=sch,
                                                     extra_first=ex, translation=tr, blocker_anchor=ba)
                                om = _omega_open(T)
                                if om == 0:
                                    continue
                                cols = _ff_count(T)
                                ratio = cols / om
                                n = len(T)
                                better = False
                                if ratio > best_ratio + 1e-12:
                                    better = True
                                elif abs(ratio - best_ratio) <= 1e-12:
                                    if best_n is None or n < best_n:
                                        better = True
                                    elif n == best_n and cols > best_cols:
                                        better = True
                                if better:
                                    best_ratio = ratio
                                    best_T = T
                                    best_n = n
                                    best_cols = cols
                                    best_om = om

    # Fallback to canonical if search failed
    if best_T is None:
        best_T = _build_candidate(depth=max(2, iterations), starts=canonical,
                                  blockers=[(1, 5), (12, 16), (4, 9), (8, 13)],
                                  schedule='after', extra_first=0, translation='left', blocker_anchor='left')

    return _normalize_grid(best_T) if normalize else best_T
>>>>>>> REPLACE
</DIFF>