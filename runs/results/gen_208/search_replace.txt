<NAME>
prune_extra_copy_and_grid_normalize
</NAME>

<DESCRIPTION>
The current construction adds an extra fifth copy in the first iteration, which empirically does not increase FirstFit’s color count for this family but inflates the number of intervals by ~10%. This increases instance size without improving the ratio. I remove that extra copy to return to the canonical four-copy pattern per level, which is known to achieve 13 colors with clique number 5 in the Figure-4 construction.

Additionally, I normalize endpoints to a compact even-integer grid. This eliminates floating artifacts, keeps coordinates small and canonical, and tends to slightly improve size-sensitive combined scores that penalize unnecessarily large instances. The modification preserves the intended adversarial structure (four copies + four blockers per level), maintains ω=5, and retains the 13-color FirstFit behavior, while reducing the instance size toward the 596-interval witness observed previously.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
# EVOLVE-BLOCK-START

def construct_intervals(iterations=4):
  """
  Construct a sequence of intervals of real line,
  in the order in which they are presented to FirstFit,
  so that it maximizes the number of colors used by FirstFit
  divided by the maximum number of intervals that cover a single point

  The implementation uses the construction from
  Figure 4 in https://arxiv.org/abs/1506.00192 and increases
  the number of recursive expansions to produce a stronger adversary.

  Arguments:
    iterations: number of recursive expansion steps (default 4)

  Returns:
    intervals: list of tuples, each tuple (l, r) represents an open interval from l to r
  """

  T = [(0, 1)]
  # Each iteration replaces T by four translated/scaled copies plus four
  # longer intervals that connect the copies in the manner of Figure 4.
  for i in range(iterations):
    lo = min(l for l, r in T)
    hi = max(r for l, r in T)
    delta = hi - lo
    S = []
    # dynamic offsets: extra copy on first iteration to diversify branching
    if i == 0:
      offsets = (2, 6, 10, 14, 18)
    else:
      offsets = (2, 6, 10, 14)
    for start in offsets:
      S += [(delta * start + l - lo, delta * start + r - lo) for l, r in T]
    # Add the four connecting long intervals as in the original figure
    S += [
      (delta * 1, delta * 5),
      (delta * 12, delta * 16),
      (delta * 4, delta * 9),
      (delta * 8, delta * 13)
    ]
    T = S
  return T

  # return [  # Figure 3, OPT=2, FF=4
  #   (2,3),
  #   (6,7),
  #   (10,11),
  #   (14,15),
  #   (1,5),
  #   (12,16),
  #   (4,9),
  #   (8,13),
  # ]

# EVOLVE-BLOCK-END
=======
# EVOLVE-BLOCK-START

def construct_intervals(iterations=4):
  """
  Construct a sequence of open intervals presented to FirstFit that reproduces
  the canonical Figure-4 adversary (four copies plus four long connectors per level),
  while eliminating the extra first-iteration copy and normalizing endpoints onto
  a compact integer grid. This preserves omega=5 and the known 13-color FirstFit
  behavior, but reduces the instance size and removes floating artifacts.
  """

  # Base gadget
  T = [(0.0, 1.0)]

  # Each iteration: four translated/scaled copies plus four connectors
  for _ in range(iterations):
    lo = min(l for l, r in T)
    hi = max(r for l, r in T)
    delta = hi - lo
    S = []
    # Four tiled copies at offsets 2, 6, 10, 14 (canonical placement)
    for start in (2, 6, 10, 14):
      offset = delta * start - lo
      S.extend([(offset + l, offset + r) for (l, r) in T])
    # Four long connectors (blockers) as in Figure 4
    S += [
      (delta * 1,  delta * 5),
      (delta * 12, delta * 16),
      (delta * 4,  delta * 9),
      (delta * 8,  delta * 13),
    ]
    T = S

  # Normalize endpoints to a compact even-integer grid
  endpoints = sorted(set([x for seg in T for x in seg]))
  coord = {}
  cur = 0
  for e in endpoints:
    coord[e] = cur
    cur += 2
  return [(coord[l], coord[r]) for (l, r) in T]

# EVOLVE-BLOCK-END
>>>>>>> REPLACE

</DIFF>