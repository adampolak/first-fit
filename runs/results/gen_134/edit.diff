--- a/original.py
+++ b/original.py
@@ -1,180 +1,182 @@
 # EVOLVE-BLOCK-START
 
-def construct_intervals(iterations=4):
+from typing import List, Tuple
+
+Interval = Tuple[float, float]
+
+def construct_intervals(iterations=4) -> List[Tuple[int, int]]:
   """
-  Construct a sequence of intervals of real line to maximize FirstFit/omega.
-  Improvements over the previous implementation:
-   - try both left-anchored and center-anchored translations for copies,
-     and a small set of alternative offset patterns to diversify geometry;
-   - normalize endpoints to a compact even integer grid before returning,
-     which avoids extremely large floats and tends to help validator scoring.
+  Construct a sequence of open intervals of the real line, in arrival order,
+  to maximize the FirstFit/omega ratio. We blend the canonical Figure-4
+  recursive skeleton with:
+    - rotor tilings across levels (four offset sets rotated deterministically),
+    - alternate blocker templates,
+    - deterministic, frontier-preserving pruning,
+    - endpoint normalization to a compact even-integer grid.
+
+  Input:
+    iterations: recursion depth (default 4).
+
+  Output:
+    list of (l, r) integer endpoints with l < r (open intervals).
   """
 
-  # --- Helper routines (kept lightweight and deterministic) ---
+  # ---------- Utilities ----------
+  def overlaps(a: Interval, b: Interval) -> bool:
+    # Open intervals overlap iff not (a.r <= b.l or b.r <= a.l)
+    (al, ar), (bl, br) = a, b
+    return not (ar <= bl or br <= al)
 
-  def firstfit_colors(intervals):
-    """Simulate FirstFit using per-color last end-point tracking."""
-    last_end = []
-    for (l, r) in intervals:
+  def firstfit_colors_and_assignment(intervals: List[Interval]):
+    # Full FirstFit: smallest color whose class has no overlapping interval.
+    color_classes: List[List[Interval]] = []
+    assignment: List[int] = []
+    for seg in intervals:
       placed = False
-      for i, le in enumerate(last_end):
-        if l >= le:
-          last_end[i] = r
+      for c, cls in enumerate(color_classes):
+        if all(not overlaps(seg, x) for x in cls):
+          cls.append(seg)
+          assignment.append(c)
           placed = True
           break
       if not placed:
-        last_end.append(r)
-    return len(last_end)
+        color_classes.append([seg])
+        assignment.append(len(color_classes) - 1)
+    return len(color_classes), assignment
 
-  def clique_number(intervals):
-    """Sweep for open intervals; process right endpoints before left at ties."""
+  def clique_number(intervals: List[Interval]) -> int:
+    # Exact sweep for open intervals: at ties, process -1 before +1.
     events = []
-    for (l, r) in intervals:
+    for l, r in intervals:
       if l < r:
         events.append((l, +1))
         events.append((r, -1))
-    events.sort(key=lambda e: (e[0], 0 if e[1] == -1 else 1))
+    events.sort(key=lambda e: (e[0], e[1]))  # (-1) before (+1) at ties
     cur = best = 0
-    for _, t in events:
-      cur += t
+    for _, delta in events:
+      cur += delta
       if cur > best:
         best = cur
     return best
 
-  def _normalize_grid(intervals):
-    """
-    Map all unique endpoints to increasing even integers (0,2,4,...).
-    This keeps instances compact and avoids unwieldy coordinates.
-    """
+  def normalize_even_grid(intervals: List[Interval]) -> List[Tuple[int, int]]:
     if not intervals:
       return []
-    endpoints = sorted(set(x for seg in intervals for x in seg))
-    coord = {}
-    cur = 0
-    for e in endpoints:
-      coord[e] = cur
-      cur += 2
-    return [(coord[l], coord[r]) for (l, r) in intervals]
+    pts = sorted({x for seg in intervals for x in seg})
+    mapping = {x: 2*i for i, x in enumerate(pts)}
+    return [(mapping[l], mapping[r]) for l, r in intervals]
 
-  def build_candidate(k, schedule='after', extra_first=False, translation='left', offsets=(2,6,10,14)):
-    """
-    Build k-level recursive pattern using copies and blockers.
-    translation in {'left','center'}:
-      - 'left' anchors copies by left endpoint as before
-      - 'center' aligns copies relative to the center of current T,
-        producing a staggered geometry that can be adversarial to FirstFit
-    offsets is a tuple of integer multipliers for the level translation.
-    """
-    T = [(0.0, 1.0)]
-    for i in range(k):
-      lo = min(l for l, r in T)
-      hi = max(r for l, r in T)
-      delta = hi - lo
-      center = (lo + hi) / 2.0
+  # ---------- Geometry blueprint ----------
+  starts_rotor = [
+    (2, 6, 10, 14),  # A
+    (1, 5, 9, 13),   # B
+    (3, 7, 11, 15),  # C
+    (0, 4, 8, 12),   # D
+  ]
+  blocker_sets = [
+    [(1, 5), (12, 16), (4, 9), (8, 13)],  # baseline
+    [(1, 6), (11, 16), (3, 9), (7, 13)],  # elongated/shifted
+    [(2, 6), (12, 16), (4, 9), (8, 13)],  # shifted 1st
+  ]
 
-      # optionally include a fifth copy on the first iteration
-      offs = tuple(list(offsets) + ([18] if extra_first and i == 0 else []))
+  def expand_once(T: List[Interval], offsets: Tuple[float, ...], blockers_ab: List[Tuple[float, float]]) -> List[Interval]:
+    lo = min(l for l, _ in T)
+    hi = max(r for _, r in T)
+    d = hi - lo
+    S: List[Interval] = []
+    for o in offsets:
+      off = d * o - lo
+      for l, r in T:
+        S.append((l + off, r + off))
+    for a, b in blockers_ab:
+      S.append((d * a, d * b))
+    return S
 
-      def make_copies(from_T, offsets_local):
-        S = []
-        for start in offsets_local:
-          if translation == 'left':
-            offset = delta * start - lo
-          else:  # center translation: align by center
-            offset = delta * start - center
-          for (l, r) in from_T:
-            S.append((l + offset, r + offset))
-        return S
-
-      blockers = [
-        (delta * 1,  delta * 5),
-        (delta * 12, delta * 16),
-        (delta * 4,  delta * 9),
-        (delta * 8,  delta * 13),
-      ]
-
-      if schedule == 'after':
-        S = make_copies(T, offs) + blockers
-      elif schedule == 'before':
-        S = list(blockers) + make_copies(T, offs)
-      else:  # 'split': half the copies, then blockers, then remaining copies
-        h = max(1, len(offs) // 2)
-        first = offs[:h]
-        second = offs[h:]
-        S = make_copies(T, first) + list(blockers) + make_copies(T, second)
-
+  def generate(depth: int, use_rotor: bool, blocker_template_idx: int, extra_first_copy: bool) -> List[Interval]:
+    T: List[Interval] = [(0.0, 1.0)]
+    for lvl in range(depth):
+      if use_rotor:
+        offsets = starts_rotor[lvl % 4]
+      else:
+        offsets = starts_rotor[0]
+      # optional deterministic augmentation: add a 5th copy on the first level
+      if extra_first_copy and lvl == 0:
+        offsets = tuple(list(offsets) + [18])
+      S = expand_once(T, offsets, blocker_sets[blocker_template_idx])
       T = S
     return T
 
-  # --- Enumerate a modest set of candidates and select the best by ratio ---
+  # ---------- Deterministic pruning preserving ratio ----------
+  def prune_preserve_ratio(intervals: List[Interval], keep_ratio: float, max_rounds: int = 2, budget_per_round: int = 200) -> List[Interval]:
+    T = list(intervals)
+    # Stage order: first remove longer intervals, then general pass.
+    for round_id in range(max_rounds):
+      attempted = 0
+      changed = True
+      while changed and attempted < budget_per_round:
+        changed = False
+        if round_id == 0:
+          order = sorted(range(len(T)), key=lambda i: -(T[i][1] - T[i][0]))
+        else:
+          order = list(range(len(T)))
+        for idx in order:
+          if attempted >= budget_per_round:
+            break
+          attempted += 1
+          cand = T[:idx] + T[idx+1:]
+          om = clique_number(cand)
+          if om == 0:
+            continue
+          cols, _ = firstfit_colors_and_assignment(cand)
+          if cols / om >= keep_ratio - 1e-12:
+            T = cand
+            changed = True
+            break
+    return T
+
+  # ---------- Candidate search ----------
+  # Ensure we always include the canonical baseline (depth=iterations, rotor off, blockers idx 0)
+  candidates = []
+  param_grid = []
   depths = [max(2, iterations - 1), iterations]
-  schedules = ['after', 'before', 'split']
-  extras = [False, True]
-  translations = ['left', 'center']
-  offsets_options = [
-    (2, 6, 10, 14),  # baseline
-    (1, 5, 9, 13),   # shifted pattern
-    (3, 7, 11, 15),  # alternate stagger
-  ]
+  for depth in depths:
+    for rotor_flag in (False, True):
+      for blk_idx in range(len(blocker_sets)):
+        for extra in (False, True):
+          param_grid.append((depth, rotor_flag, blk_idx, extra))
 
   best_T = None
   best_ratio = -1.0
-  best_n = None
-  best_cols = 0
-  best_om = 0
+  best_len = None
+  for depth, rotor_flag, blk_idx, extra in param_grid:
+    raw = generate(depth, rotor_flag, blk_idx, extra)
+    # Evaluate pre-normalization (affine transforms; normalization preserves overlaps)
+    om = clique_number(raw)
+    if om == 0:
+      continue
+    cols, _ = firstfit_colors_and_assignment(raw)
+    ratio = cols / om
+    # Keep the best; tie-breaker: shorter instance
+    if (ratio > best_ratio + 1e-12) or (abs(ratio - best_ratio) <= 1e-12 and (best_len is None or len(raw) < best_len)):
+      best_T = raw
+      best_ratio = ratio
+      best_len = len(raw)
 
-  for k in depths:
-    for sch in schedules:
-      for ex in extras:
-        for trans in translations:
-          for offs in offsets_options:
-            T = build_candidate(k, schedule=sch, extra_first=ex, translation=trans, offsets=offs)
-            om = clique_number(T)
-            if om == 0:
-              continue
-            cols = firstfit_colors(T)
-            ratio = cols / om
-            n = len(T)
-            # Prefer higher ratio; tie-break by fewer intervals then more colors
-            better = False
-            if ratio > best_ratio + 1e-12:
-              better = True
-            elif abs(ratio - best_ratio) <= 1e-12:
-              if best_n is None or n < best_n:
-                better = True
-              elif n == best_n and cols > best_cols:
-                better = True
-            if better:
-              best_ratio = ratio
-              best_T = T
-              best_n = n
-              best_cols = cols
-              best_om = om
+  # Fallback: canonical if search failed
+  if best_T is None:
+    best_T = generate(iterations, False, 0, False)
+    om = clique_number(best_T)
+    cols, _ = firstfit_colors_and_assignment(best_T)
+    best_ratio = cols / max(1, om)
 
-  # Fallback to baseline 4-iteration construction if search fails
-  if best_T is None:
-    T = [(0.0, 1.0)]
-    for i in range(iterations):
-      lo = min(l for l, r in T)
-      hi = max(r for l, r in T)
-      delta = hi - lo
-      S = []
-      for start in (2, 6, 10, 14):
-        S += [(delta * start + l - lo, delta * start + r - lo) for l, r in T]
-      S += [
-        (delta * 1, delta * 5),
-        (delta * 12, delta * 16),
-        (delta * 4, delta * 9),
-        (delta * 8, delta * 13)
-      ]
-      T = S
-    return _normalize_grid(T)
+  # Conservative pruning: keep the current ratio
+  pruned = prune_preserve_ratio(best_T, best_ratio, max_rounds=2, budget_per_round=100)
 
-  # Normalize the best candidate to a compact integer grid before returning.
-  return _normalize_grid(best_T)
+  # Final normalization
+  return normalize_even_grid(pruned)
 
 # EVOLVE-BLOCK-END
 
 def run_experiment(**kwargs):
   """Main called by evaluator"""
   return construct_intervals()