--- a/original.py
+++ b/original.py
@@ -1,151 +1,107 @@
 # EVOLVE-BLOCK-START
 
+from functools import lru_cache
+
 def _normalize_grid(intervals):
-  """
-  Normalize endpoints to a compact integer grid while preserving order.
-  Each unique endpoint is mapped to an increasing even integer.
-  Returns a new list of (l, r) with integer coordinates.
-  """
-  endpoints = sorted(set([x for seg in intervals for x in seg]))
-  coord = {}
-  cur = 0
-  for e in endpoints:
-    coord[e] = cur
-    cur += 2  # spacing by 2 to keep even gaps
+    endpoints = sorted({x for seg in intervals for x in seg})
+    coord = {v:2*i for i,v in enumerate(endpoints)}
+    return [(coord[l],coord[r]) for (l,r) in intervals]
 
-  return [(coord[l], coord[r]) for (l, r) in intervals]
+def _ff_count(intervals):
+    last_end=[]
+    for l,r in intervals:
+        placed=False
+        for i,le in enumerate(last_end):
+            if l>=le:
+                last_end[i]=r
+                placed=True
+                break
+        if not placed:
+            last_end.append(r)
+    return len(last_end)
 
+def _omega_open(intervals):
+    ev=[]
+    for l,r in intervals:
+        if l<r:
+            ev.append((l,1)); ev.append((r,-1))
+    ev.sort(key=lambda x:(x[0],0 if x[1]==-1 else 1))
+    cur=best=0
+    for _,t in ev:
+        cur+=t
+        best=max(best,cur)
+    return best
+
+# four offset patterns A,B,C,D
+PATTERNS=[(2,6,10,14),(1,5,9,13),(3,7,11,15),(0,4,8,12)]
+# canonical blockers
+BLOCKERS=[(1,5),(12,16),(4,9),(8,13)]
+
+@lru_cache(maxsize=None)
+def _build(level, pattern_idx):
+    """
+    Recursively build at given level using pattern PATTERNS[pattern_idx %4].
+    Inserts waves: short if level%2==0, long if level%3==0.
+    """
+    if level==0:
+        return ((0.0,1.0),)
+    prev=_build(level-1,pattern_idx-1)
+    lo=min(l for l,r in prev); hi=max(r for l,r in prev)
+    delta=hi-lo
+    center=(lo+hi)/2.0
+    offs=PATTERNS[pattern_idx%4]
+    # place copies
+    S=[]
+    for st in offs:
+        off=delta*st - lo
+        for l,r in prev:
+            S.append((l+off,r+off))
+    # blockers
+    for a,b in BLOCKERS:
+        S.append((delta*a,delta*b))
+    # short wave
+    if level%2==0:
+        S.append((delta*3,delta*5))
+        S.append((delta*5,delta*7))
+    # long wave
+    if level%3==0:
+        S.append((delta*7,delta*11))
+        S.append((delta*11,delta*17))
+    return tuple(S)
+
+def _prune(intervals):
+    """
+    Single-pass left-to-right removal if ratio unchanged.
+    """
+    cur=list(intervals)
+    # normalize for evaluation
+    def eval_ratio(T):
+        Tn=_normalize_grid(T)
+        om=_omega_open(Tn)
+        if om==0: return -1
+        return _ff_count(Tn)/om
+    base=eval_ratio(cur)
+    i=0
+    while i<len(cur):
+        cand=cur[:i]+cur[i+1:]
+        if eval_ratio(cand)>=base:
+            cur=cand
+            # do not increment i to re-examine at same index
+        else:
+            i+=1
+    return cur
 
 def construct_intervals(iterations=4, normalize=True):
-  """
-  Build a sequence of open intervals that aims to maximize FirstFit/omega
-  using a small parameter sweep around the canonical 4-copy/4-blocker recursion.
-  The final output is normalized to a compact integer grid.
-  """
-  # Local helpers to evaluate candidates on raw coordinates (open intervals)
-  def _ff_count(intervals):
-    last_end = []
-    for (l, r) in intervals:
-      placed = False
-      for i, le in enumerate(last_end):
-        if l >= le:
-          last_end[i] = r
-          placed = True
-          break
-      if not placed:
-        last_end.append(r)
-    return len(last_end)
-
-  def _omega_open(intervals):
-    events = []
-    for (l, r) in intervals:
-      if l < r:
-        events.append((l, +1))
-        events.append((r, -1))
-    # right (-1) before left (+1) on ties (open intervals)
-    events.sort(key=lambda e: (e[0], 0 if e[1] == -1 else 1))
-    cur = best = 0
-    for _, t in events:
-      cur += t
-      if cur > best:
-        best = cur
-    return best
-
-  # Parameterized builder
-  def _build(depth, starts, blockers, schedule='after', translation='left'):
-    T = [(0.0, 1.0)]
-    for _ in range(depth):
-      lo = min(l for l, r in T)
-      hi = max(r for l, r in T)
-      delta = hi - lo
-      center = (lo + hi) / 2.0
-
-      def place_copies(from_T, offs):
-        U = []
-        for start in offs:
-          offset = delta * start - (lo if translation == 'left' else center)
-          for (l, r) in from_T:
-            U.append((l + offset, r + offset))
-        return U
-
-      # scale blockers according to anchor
-      if translation == 'left':
-        blk = [(delta * a, delta * b) for (a, b) in blockers]
-      else:
-        blk = [(delta * a - center, delta * b - center) for (a, b) in blockers]
-
-      if schedule == 'before':
-        S = list(blk) + place_copies(T, starts)
-      elif schedule == 'split':
-        h = len(starts) // 2
-        S = place_copies(T, starts[:h]) + list(blk) + place_copies(T, starts[h:])
-      else:  # 'after'
-        S = place_copies(T, starts) + list(blk)
-      T = S
-    return T
-
-  # Sweep a modest space of blueprints
-  depths = sorted(set([max(2, iterations - 1), max(2, iterations), min(5, iterations + 1)]))
-  start_sets = [
-    (2, 6, 10, 14),  # canonical
-    (1, 5, 9, 13),
-    (3, 7, 11, 15),
-    (0, 4, 8, 12),
-  ]
-  blocker_templates = [
-    [(1, 5), (12, 16), (4, 9), (8, 13)],   # canonical
-    [(1, 5), (11, 15), (4, 9), (8, 13)],   # slight shift
-    [(2, 6), (12, 16), (4, 9), (8, 13)],   # shift first
-  ]
-  schedules = ['after', 'before', 'split']
-  translations = ['left', 'center']
-
-  best_T = None
-  best_ratio = -1.0
-  best_n = None
-  best_cols = 0
-  best_om = 0
-
-  for d in depths:
-    for starts in start_sets:
-      for blockers in blocker_templates:
-        for sch in schedules:
-          for tr in translations:
-            T = _build(d, starts, blockers, schedule=sch, translation=tr)
-            n = len(T)
-            # guard against explosion (keep search modest)
-            if n > 2000:
-              continue
-            om = _omega_open(T)
-            if om <= 0:
-              continue
-            cols = _ff_count(T)
-            ratio = cols / om
-            better = False
-            if ratio > best_ratio + 1e-12:
-              better = True
-            elif abs(ratio - best_ratio) <= 1e-12:
-              if best_n is None or n < best_n:
-                better = True
-              elif n == best_n and cols > best_cols:
-                better = True
-            if better:
-              best_ratio = ratio
-              best_T = T
-              best_n = n
-              best_cols = cols
-              best_om = om
-
-  # Fallback to canonical if search didn't produce anything
-  if best_T is None:
-    T = _build(max(2, iterations), (2, 6, 10, 14), [(1, 5), (12, 16), (4, 9), (8, 13)], schedule='after', translation='left')
-  else:
-    T = best_T
-
-  return _normalize_grid(T) if normalize else T
+    """
+    Build at fixed depth=4 using cyclic patterns and waves, then prune.
+    """
+    DEPTH=4
+    T= list(_build(DEPTH,DEPTH))
+    T_pruned=_prune(T)
+    return _normalize_grid(T_pruned) if normalize else T_pruned
 
 # EVOLVE-BLOCK-END
 
 def run_experiment(**kwargs):
   """Main called by evaluator"""
   return construct_intervals()