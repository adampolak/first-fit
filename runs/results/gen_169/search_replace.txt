<NAME>
rotor_anchor_sandwich_search
</NAME>

<DESCRIPTION>
I expand the deterministic search space in three targeted ways that are known to influence FirstFit’s behavior without necessarily inflating the clique number:
1) More rotor patterns: I add the D-offset pattern (0, 4, 8, 12) and a longer 4-cycle rotor (canonical, alt_a, alt_b, D). This cycles geometries across levels and can couple colors across copies in new ways.
2) Blocker anchor modes: In addition to the standard left-anchored connectors, I include a center-anchored variant that positions the long connectors around the current scale’s center. This changes relative arrival interactions while preserving clique constraints.
3) Additional scheduling orders: I add two more deterministic orders—'before' (blockers before copies) and 'sandwich' (copies quartered with blockers interleaved between quarters). These orders are known to perturb FirstFit assignments and can force extra colors without changing omega.

These edits are minimal, self-consistent, and keep the program fast. They broaden the geometry/arrival-order search enough to plausibly find instances with a slightly higher FF/omega ratio than the current 13/5, or at least different strong witnesses. Even if the ratio ties, this diversification increases the chance of a marginal gain.

</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
  # Pattern space (compact)
  canonical = (2, 6, 10, 14)
  alt_a     = (1, 5, 9, 13)
  alt_b     = (3, 7, 11, 15)

  pattern_cycles = [
    (canonical,),                 # canonical only
    (canonical, alt_a),           # alternate canonical/alt_a
    (canonical, alt_b),           # alternate canonical/alt_b
  ]
=======
  # Pattern space (compact)
  canonical = (2, 6, 10, 14)
  alt_a     = (1, 5, 9, 13)
  alt_b     = (3, 7, 11, 15)
  alt_d     = (0, 4, 8, 12)  # additional stagger pattern

  # Rotor cycles across levels; include longer 4-cycle to diversify geometry
  pattern_cycles = [
    (canonical,),                         # canonical only
    (canonical, alt_a),                   # alternate canonical/alt_a
    (canonical, alt_b),                   # alternate canonical/alt_b
    (canonical, alt_a, alt_b, alt_d),     # 4-cycle rotor
    (alt_d,),                             # D-only baseline
  ]
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
  schedules = ['after', 'split']             # two effective orders
  extras    = [False, True]                  # optional extra first copy
=======
  schedules = ['after', 'split', 'before', 'sandwich']  # expanded scheduling orders
  extras    = [False, True]                  # optional extra first copy
  anchor_modes = ['left', 'center']          # blocker anchoring modes
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
  for depth in depths:
    for pat in pattern_cycles:
      for conn in blockers_templates:
        for sch in schedules:
          for ex in extras:
            # Build candidate
            T = [(0.0, 1.0)]
            for lvl in range(depth):
              lo = min(l for l, r in T)
              hi = max(r for l, r in T)
              delta = hi - lo

              # Offsets for this level
              # pat is a tuple; pick the appropriate cycle entry
              offs_base = pat[min(lvl, len(pat) - 1)]
              offs = list(offs_base)
              if ex and lvl == 0:
                offs.append(offs_base[-1] + 4)

              def copies(src_T, offsets):
                S = []
                for start in offsets:
                  offset = delta * start - lo
                  for (l, r) in src_T:
                    S.append((l + offset, r + offset))
                return S

              blks = [(delta * a, delta * b) for (a, b) in conn]

              if sch == 'after':
                T = copies(T, offs) + blks
              else:  # 'split'
                h = len(offs) // 2
                T = copies(T, offs[:h]) + blks + copies(T, offs[h:])

            om = clique_number(T)
            if om <= 0:
              continue
            cols = firstfit_colors(T)
            ratio = cols / om
            n = len(T)
            cand = (ratio, -n, cols, om, T)
            if best is None or cand > best:
              best = cand
=======
  for depth in depths:
    for pat in pattern_cycles:
      for conn in blockers_templates:
        for sch in schedules:
          for ex in extras:
            for anchor in anchor_modes:
              # Build candidate
              T = [(0.0, 1.0)]
              for lvl in range(depth):
                lo = min(l for l, r in T)
                hi = max(r for l, r in T)
                delta = hi - lo
                center = (lo + hi) / 2.0

                # Offsets for this level
                # pat is a tuple; pick the appropriate cycle entry
                offs_base = pat[min(lvl, len(pat) - 1)]
                offs = list(offs_base)
                if ex and lvl == 0:
                  offs.append(offs_base[-1] + 4)

                def copies(src_T, offsets):
                  S = []
                  for start in offsets:
                    offset = delta * start - lo
                    for (l, r) in src_T:
                      S.append((l + offset, r + offset))
                  return S

                # Build blockers with selected anchor mode
                if anchor == 'left':
                  blks = [(delta * a, delta * b) for (a, b) in conn]
                else:  # 'center'
                  blks = [(delta * a - center, delta * b - center) for (a, b) in conn]

                # Apply schedule
                if sch == 'after':
                  T = copies(T, offs) + blks
                elif sch == 'before':
                  T = blks + copies(T, offs)
                elif sch == 'split':
                  h = len(offs) // 2
                  T = copies(T, offs[:h]) + blks + copies(T, offs[h:])
                else:  # 'sandwich': quarter the copies with blockers interleaved
                  q1 = len(offs) // 4
                  q2 = len(offs) // 2
                  q3 = (3 * len(offs)) // 4
                  T = (
                    copies(T, offs[:q1])
                    + blks
                    + copies(T, offs[q1:q2])
                    + blks
                    + copies(T, offs[q2:q3])
                    + blks
                    + copies(T, offs[q3:])
                  )

              om = clique_number(T)
              if om <= 0:
                continue
              cols = firstfit_colors(T)
              ratio = cols / om
              n = len(T)
              cand = (ratio, -n, cols, om, T)
              if best is None or cand > best:
                best = cand
>>>>>>> REPLACE

</DIFF>