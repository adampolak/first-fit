--- a/original.py
+++ b/original.py
@@ -1,359 +1,120 @@
 # EVOLVE-BLOCK-START
 
 from math import gcd
-from itertools import islice
 
-# ---------- Basic geometric and algorithmic utilities ----------
+def _normalize_grid(intervals):
+    """Map unique endpoints to even integers preserving order."""
+    pts = sorted({x for seg in intervals for x in seg})
+    m = {x:i*2 for i,x in enumerate(pts)}
+    return [(m[l], m[r]) for (l,r) in intervals]
 
-def overlaps(a, b):
-    """Open-interval overlap test: True iff intervals overlap."""
-    (l1, r1), (l2, r2) = a, b
-    return max(l1, l2) < min(r1, r2)
-
-def firstfit_colors(intervals):
-    """
-    Simulate FirstFit coloring on the given arrival order of open intervals.
-    Returns number of colors used.
-    """
-    colors = []  # lists of intervals per color (intervals in arrival order)
-    for iv in intervals:
+def _ff_count(intervals):
+    """Fast FirstFit via per-color last_end tracking."""
+    last_end = []
+    for (l,r) in intervals:
         placed = False
-        for cls in colors:
-            # since each color class must be pairwise disjoint, we can check last interval only,
-            # but to be safe (and robust under non-sorted classes) check all.
-            conflict = False
-            for u in cls:
-                if overlaps(u, iv):
-                    conflict = True
-                    break
-            if not conflict:
-                cls.append(iv)
+        for i,le in enumerate(last_end):
+            if l >= le:
+                last_end[i] = r
                 placed = True
                 break
         if not placed:
-            colors.append([iv])
-    return len(colors)
+            last_end.append(r)
+    return len(last_end)
 
-def clique_number(intervals):
-    """
-    Compute omega = maximum number of open intervals covering some point,
-    by a sweep-line on endpoints. Right endpoints processed before left endpoints
-    at ties to model open intervals correctly.
-    """
-    events = []
-    for (l, r) in intervals:
-        if l >= r:
-            continue
-        events.append((l, +1))
-        events.append((r, -1))
-    # sort so (-1) comes before (+1) at same coordinate
-    events.sort(key=lambda e: (e[0], 0 if e[1] == -1 else 1))
+def _omega_open(intervals):
+    """Sweep-line omega for open intervals."""
+    ev = []
+    for l,r in intervals:
+        if l<r:
+            ev.append((l,1))
+            ev.append((r,-1))
+    ev.sort(key=lambda x:(x[0], x[1]==1))
     cur = best = 0
-    for _, t in events:
-        cur += t
-        if cur > best:
-            best = cur
+    for _,d in ev:
+        cur += d
+        if cur>best: best=cur
     return best
 
-def normalize_to_grid(intervals):
-    """
-    Map all unique endpoints to a compact integer grid with spacing 2 between
-    consecutive unique endpoints (so we can safely place half-length intervals).
-    Returns list of integer intervals (l, r).
-    """
-    if not intervals:
-        return []
-    eps = sorted(set(x for seg in intervals for x in seg))
-    coord = {}
-    cur = 0
-    for e in eps:
-        coord[e] = cur
-        cur += 2
-    return [(coord[l], coord[r]) for (l, r) in intervals]
-
-# ---------- Recursive base pattern builder (Figure-4 style) ----------
-
-def build_recursive_pattern(base_seed, depth, offsets=(2,6,10,14), blockers=((1,5),(12,16),(4,9),(8,13)), extra_first=False):
-    """
-    Build the recursive four-copy + four-blocker pattern.
-      - base_seed: list of (l,r) floats
-      - depth: number of recursive levels
-      - offsets: tuple of copy-start multipliers
-      - blockers: list of (a,b) multipliers for long connectors
-      - extra_first: if True, add one extra copy at level 0 (small variant)
-    """
-    T = [tuple(iv) for iv in base_seed]
+def _build_candidate(depth, starts, blockers, schedule, extra_first, extra_last, translation):
+    """Recursive k-copy + 4-blocker construction with scheduling."""
+    T = [(0.0,1.0)]
     for lvl in range(depth):
-        lo = min(l for l,r in T)
-        hi = max(r for l,r in T)
+        lo = min(l for l,_ in T)
+        hi = max(r for _,r in T)
         delta = hi - lo
-        S = []
-        offs = list(offsets)
-        if extra_first and lvl == 0:
-            # add a further copy step (+4)
-            offs = offs + [offs[-1] + 4]
-        for start in offs:
-            off = delta * start - lo
-            for (l,r) in T:
-                S.append((l + off, r + off))
-        for (a,b) in blockers:
-            S.append((delta * a, delta * b))
+        center = (lo+hi)/2.0
+        offs = list(starts)
+        if extra_first and lvl==0: offs.append(starts[-1]+4)
+        if extra_last  and lvl==depth-1: offs.append(starts[-1]+4)
+        def make(fromT, offs_list):
+            out=[]
+            for s in offs_list:
+                off = (delta*s - (lo if translation=='left' else center))
+                for l,r in fromT:
+                    out.append((l+off, r+off))
+            return out
+        if translation=='left':
+            blk = [(delta*a, delta*b) for a,b in blockers]
+        else:
+            blk = [((delta*a-center),(delta*b-center)) for a,b in blockers]
+        if schedule=='after':
+            S = make(T,offs)+blk
+        elif schedule=='before':
+            S = blk+make(T,offs)
+        elif schedule=='split':
+            h=len(offs)//2
+            S = make(T,offs[:h])+blk+make(T,offs[h:])
+        else:  # interleaved
+            S=[]
+            for i,s in enumerate(offs):
+                S+=make(T,[s])
+                if i<len(blk): S.append(blk[i])
         T = S
     return T
 
-# ---------- Greedy augmentation (waves) ----------
+def construct_intervals(iterations=4, normalize=True):
+    """Search small parameter space for best FF/omega ratio."""
+    depths = [max(2,iterations-1), max(2,iterations)]
+    start_sets = [(2,6,10,14),(1,5,9,13),(3,7,11,15),(0,4,8,12)]
+    blocker_templates = [
+        [(1,5),(12,16),(4,9),(8,13)],
+        [(1,5),(11,15),(4,9),(8,13)],
+        [(2,6),(12,16),(4,9),(8,13)],
+        [(1,6),(11,16),(3,9),(7,13)]
+    ]
+    schedules = ['after','before','split','interleaved']
+    translations = ['left','center']
+    extra_opts = [(False,False),(True,False),(False,True),(True,True)]
 
-def compute_coverage_map(intervals):
-    """
-    Given integer intervals, compute coverage count for each atomic segment between sorted endpoints.
-    Returns:
-      - coords: sorted unique endpoints
-      - seg_counts: list of coverage counts for intervals (coords[i], coords[i+1])
-    """
-    if not intervals:
-        return [], []
-    endpoints = sorted(set(x for iv in intervals for x in iv))
-    events = []
-    for (l,r) in intervals:
-        if l >= r:
-            continue
-        events.append((l, +1))
-        events.append((r, -1))
-    events.sort(key=lambda e: (e[0], 0 if e[1] == -1 else 1))
-    coords = sorted(set(e[0] for e in events))
-    # build segment coverage between consecutive coords
-    seg_counts = []
-    cur = 0
-    # iterate events and produce counts for each interval between distinct coords
-    # create dict from coord->current coverage after processing events at that coord
-    idx = 0
-    coord_list = sorted(set(x for x in endpoints))
-    counts_between = {}
-    ev_idx = 0
-    evn = len(events)
-    for i in range(len(coord_list)):
-        x = coord_list[i]
-        # process all events at x (with -1 before +1 done by events sort)
-        while ev_idx < evn and events[ev_idx][0] == x:
-            cur += events[ev_idx][1]
-            ev_idx += 1
-        # coverage on (x, next_x) is cur (but if there is no next, ignore)
-        if i+1 < len(coord_list):
-            counts_between[(coord_list[i], coord_list[i+1])] = cur
-    # produce coords and seg_counts list in same order
-    coords = coord_list
-    seg_counts = [counts_between[(coords[i], coords[i+1])] for i in range(len(coords)-1)]
-    return coords, seg_counts
-
-def try_add_wave(cur_intervals, target_omega, wave_length=2, candidates_limit=600):
-    """
-    Try to add short "wave" intervals (of integer length wave_length) to increase FirstFit colors
-    without increasing clique number above target_omega.
-
-    Strategy:
-      - enumerate a set of candidate left endpoints chosen between unique endpoints of current intervals
-      - for each candidate construct interval (x, x+wave_length)
-      - accept the first candidate that increases FirstFit color count while keeping omega <= target_omega
-    Returns:
-      - (accepted_interval or None, new_intervals)
-    """
-    # Work on normalized integer intervals
-    T = list(cur_intervals)
-    if not T:
-        return None, T
-    coords = sorted(set(x for iv in T for x in iv))
-    # generate candidate left positions: between coords[i], coords[i+1]-wave_length (so interval fits)
-    # to limit candidates, sample uniformly across range as well as near dense regions
-    min_x = min(coords)
-    max_x = max(coords)
-    # candidate lefts: use endpoints and midpoints of large gaps
-    left_candidates = set()
-    for a,b in zip(coords, coords[1:]):
-        # try left placements anchored near a, near midpoint, and near b-wave_length
-        if b - a <= 0:
-            continue
-        # choose up to three placements in this gap if it can host wave_length
-        if b - a >= wave_length + 1:
-            left_candidates.add(a + 1)
-            left_candidates.add((a + b) // 2)
-            left_candidates.add(b - wave_length - 1)
-        else:
-            left_candidates.add(a)
-    # also sample a small grid across whole range
-    step = max(1, (max_x - min_x) // 30)
-    for x in range(min_x, max_x - wave_length + 1, step):
-        left_candidates.add(x)
-    # cap candidates
-    lefts = sorted(left_candidates)
-    if len(lefts) > candidates_limit:
-        # downsample deterministically
-        lefts = [lefts[i] for i in range(0, len(lefts), max(1, len(lefts)//candidates_limit))]
-
-    base_cols = firstfit_colors(T)
-    base_om = clique_number(T)
-    # quick reject if base_om already exceeds target
-    if base_om > target_omega:
-        target_omega = base_om
-
-    for x in lefts:
-        cand = (x, x + wave_length)
-        # don't add degenerate or overlapping with endpoints equalities only (open intervals)
-        if cand[0] >= cand[1]:
-            continue
-        # ensure clique remains <= target_omega
-        new_om = clique_number(T + [cand])
-        if new_om > target_omega:
-            continue
-        # compute FirstFit colors on the augmented sequence (append at the end)
-        new_cols = firstfit_colors(T + [cand])
-        if new_cols > base_cols:
-            # accept
-            T2 = T + [cand]
-            return cand, T2
-    return None, T
-
-# ---------- Conservative pruning to keep instance compact ----------
-
-def conservative_prune(intervals, keep_ratio):
-    """
-    Try removing intervals one-by-one (prefer long ones) while preserving observed FirstFit/OPT ratio >= keep_ratio.
-    Deterministic greedy pass.
-    """
-    cur = list(intervals)
-    if not cur:
-        return cur
-    # compute base observed ratio
-    aux_norm = normalize_to_grid(cur)
-    base_cols = firstfit_colors(aux_norm)
-    base_om = clique_number(aux_norm) or 1
-    base_ratio = base_cols / base_om
-    # only prune if base_ratio >= keep_ratio (it should be)
-    target = keep_ratio if keep_ratio is not None else base_ratio
-
-    def length(iv):
-        return iv[1] - iv[0]
-    # greedy remove longest intervals first
-    changed = True
-    while changed:
-        changed = False
-        order = sorted(range(len(cur)), key=lambda i: (-length(cur[i]), i))
-        for idx in order:
-            cand = cur[:idx] + cur[idx+1:]
-            cand_norm = normalize_to_grid(cand)
-            if not cand_norm:
-                continue
-            c = firstfit_colors(cand_norm)
-            o = clique_number(cand_norm)
-            if o == 0:
-                continue
-            if (c / o) >= target - 1e-12:
-                cur = cand
-                changed = True
-                break
-    return cur
-
-# ---------- High-level construction + augmentation search ----------
-
-def construct_intervals():
-    """
-    Build intervals (in arrival order) and attempt to augment them with waves to
-    increase FirstFit color usage while keeping omega controlled.
-
-    Returns normalized integer intervals.
-    """
-    # base seeds and templates to try
-    base_seeds = [
-        [(0.0, 1.0)],                      # canonical single seed
-        [(0.0, 1.0), (2.0, 3.0)],          # two disjoint seeds
-    ]
-    depths = [3, 4]  # try a couple of depths (keeps sizes manageable)
-    offset_templates = [
-        (2,6,10,14),    # canonical
-        (1,5,9,13),     # alternative
-    ]
-    blocker_templates = [
-        ((1,5),(12,16),(4,9),(8,13)),  # canonical
-        ((0,4),(11,15),(3,8),(7,12)),  # variant
-    ]
-    extra_first_choices = [False, True]
-
-    # Evaluate baseline candidates and pick the best one by FF/OPT ratio
-    best = None  # tuple (ratio, cols, om, intervals_raw)
-    for base in base_seeds:
-        for depth in depths:
-            for offs in offset_templates:
-                for blks in blocker_templates:
-                    for extra in extra_first_choices:
-                        T = build_recursive_pattern(base_seed=base, depth=depth, offsets=offs, blockers=blks, extra_first=extra)
-                        Tn = normalize_to_grid(T)
-                        if not Tn:
-                            continue
-                        om = clique_number(Tn)
-                        if om == 0:
-                            continue
-                        cols = firstfit_colors(Tn)
-                        ratio = cols / om
-                        cand = (ratio, cols, om, T)
-                        if best is None or cand[0] > best[0] + 1e-12 or (abs(cand[0]-best[0])<=1e-12 and len(T) < len(best[3])):
-                            best = cand
-
+    best = None  # (ratio, -size, cols, intervals_raw)
+    for d in depths:
+        if (4**d)*8 > 5000: continue
+        for starts in start_sets:
+            for blks in blocker_templates:
+                for sch in schedules:
+                    for tr in translations:
+                        for ef,el in extra_opts:
+                            T = _build_candidate(d, starts, blks, sch, ef, el, tr)
+                            Tn = _normalize_grid(T)
+                            om = _omega_open(Tn)
+                            if om<1: continue
+                            cols = _ff_count(Tn)
+                            ratio = cols/om
+                            key = (ratio, -len(Tn), cols)
+                            if best is None or key>best[0]:
+                                best = (key, Tn)
     if best is None:
-        # fallback: simple canonical depth=4
-        T = build_recursive_pattern([(0.0,1.0)], depth=4)
+        # fallback canonical
+        T = _build_candidate(max(2,iterations), (2,6,10,14), [(1,5),(12,16),(4,9),(8,13)],
+                              'after', False, False, 'left')
+        out = _normalize_grid(T)
     else:
-        T = best[3]
-
-    # Normalize to integer grid for augmentation steps
-    current = normalize_to_grid(T)
-    current_om = clique_number(current)
-    current_cols = firstfit_colors(current)
-    best_ratio = current_cols / current_om if current_om > 0 else 0
-
-    # Augmentation loop: try to add up to max_waves that improve colors while preserving omega
-    max_waves = 60  # keep moderate
-    wave_length = max(1, max(1, max((r-l) for l,r in current)) // 30)  # choose a small wave length relative to scale
-    # ensure wave_length at least 2 for stability if space allows
-    wave_length = max(1, min(3, wave_length))
-    added_any = True
-    waves_added = 0
-    # We'll accept only additions that strictly increase FF colors and keep omega unchanged (or <= original)
-    target_omega = current_om
-    while waves_added < max_waves and added_any:
-        added_any = False
-        cand, newT = try_add_wave(current, target_omega, wave_length=wave_length, candidates_limit=800)
-        if cand is not None:
-            # Update current
-            current = normalize_to_grid(newT)
-            new_om = clique_number(current)
-            new_cols = firstfit_colors(current)
-            if new_om <= target_omega and new_cols > current_cols:
-                current_cols = new_cols
-                current_om = new_om
-                best_ratio = current_cols / current_om if current_om > 0 else best_ratio
-                waves_added += 1
-                added_any = True
-            else:
-                # revert (shouldn't happen given try_add_wave guard) but keep safe
-                # if candidate didn't help, stop to keep deterministic behavior
-                break
-
-    # After augmentation, perform conservative pruning while preserving observed ratio
-    observed_ratio = current_cols / current_om if current_om > 0 else best_ratio
-    pruned = conservative_prune(current, observed_ratio)
-    final_norm = normalize_to_grid(pruned)
-    # final sanity: ensure we didn't lose the ratio through pruning; if so, return pre-prune
-    if final_norm:
-        final_cols = firstfit_colors(final_norm)
-        final_om = clique_number(final_norm) or 1
-        if final_cols / final_om + 1e-12 < observed_ratio:
-            return current  # return pre-prune normalized
-        else:
-            return final_norm
-    else:
-        return current
+        out = best[1]
+    return out if normalize else [(float(l),float(r)) for l,r in out]
 
 # EVOLVE-BLOCK-END
 
 def run_experiment(**kwargs):
   """Main called by evaluator"""
   return construct_intervals()