--- a/original.py
+++ b/original.py
@@ -1,163 +1,230 @@
 # EVOLVE-BLOCK-START
 
 def construct_intervals(iterations=4):
   """
   Construct a sequence of intervals of real line to maximize FirstFit/omega.
-  We explore small variations inspired by adversarial arrival-order engineering:
-  - schedule of blockers vs copies at each level (before/after/split)
-  - optional extra copy at the first iteration to couple layers
-  We evaluate candidates via an in-block FirstFit and omega computation, and return the best.
+  We explore variations inspired by adversarial arrival-order engineering:
+    - schedule of blockers vs copies per level (before/after/split/mix)
+    - interleaving strategy for copies (block vs zip)
+    - multiple offset and blocker templates including extra caps
+    - optional extra copy on the first level
+  We evaluate candidates via FirstFit and omega computation, and return the best.
   """
 
-  # --- Helper routines (kept lightweight and deterministic) ---
+  # --- Helper routines (deterministic and correct for open intervals) ---
+
+  def overlaps(a, b):
+    (l1, r1), (l2, r2) = a, b
+    return max(l1, l2) < min(r1, r2)
 
   def firstfit_colors(intervals):
-    """Simulate FirstFit using per-color last end-point tracking."""
-    last_end = []
-    for (l, r) in intervals:
+    """
+    Simulate FirstFit using explicit conflict checks within each color class.
+    This is O(n^2) in the worst case but n is modest in our sweep.
+    """
+    colors = []  # list of color classes; each is a list of intervals in arrival order
+    for iv in intervals:
       placed = False
-      for i, le in enumerate(last_end):
-        if l >= le:
-          last_end[i] = r
+      for c in colors:
+        # check if iv overlaps any in color c
+        conflict = False
+        for u in c:
+          if overlaps(u, iv):
+            conflict = True
+            break
+        if not conflict:
+          c.append(iv)
           placed = True
           break
       if not placed:
-        last_end.append(r)
-    return len(last_end)
+        colors.append([iv])
+    return len(colors)
 
   def clique_number(intervals):
     """Sweep for open intervals; process right endpoints before left at ties."""
     events = []
     for (l, r) in intervals:
       if l < r:
         events.append((l, +1))
         events.append((r, -1))
     events.sort(key=lambda e: (e[0], 0 if e[1] == -1 else 1))
     cur = best = 0
     for _, t in events:
       cur += t
       if cur > best:
         best = cur
     return best
 
-  def build_candidate(k, schedule='after', extra_first=False):
-    """
-    Build k-level recursive pattern using four scaled copies per level,
-    with four long connectors ("blockers"), and schedule controlling
-    the arrival order within each level.
-    schedule in {'after','before','split'}.
+  def build_candidate(k, offsets, blockers_tpl, schedule='after', interleave='block', extra_first=False):
+    """
+    Build k-level recursive pattern using scaled copies per level and long connectors ("blockers").
+    - offsets: tuple of starting positions (scaled by delta) for copies
+    - blockers_tpl: tuple of (a,b) ranges (scaled by delta)
+    - schedule in {'after','before','split','mix'} controls arrival order
+    - interleave in {'block','zip'} controls how copies are interleaved
+    - extra_first: if True, add a fifth copy only at the first iteration (offset=18)
     """
     T = [(0.0, 1.0)]
     for i in range(k):
       lo = min(l for l, r in T)
       hi = max(r for l, r in T)
       delta = hi - lo
 
       # Offsets for this level; optionally add a fifth copy on the first iteration
-      offs = (2, 6, 10, 14, 18) if (extra_first and i == 0) else (2, 6, 10, 14)
-
-      # Prepare copies
-      def make_copies(from_T, offsets):
+      offs = list(offsets)
+      if extra_first and i == 0 and 18 not in offs:
+        offs = list(offs) + [18]
+
+      # Prepare per-copy lists
+      copy_lists = []
+      for start in offs:
+        offset = delta * start - lo  # left-anchored translation
+        copy_lists.append([(l + offset, r + offset) for (l, r) in T])
+
+      # Interleave copies
+      if interleave == 'zip' and copy_lists:
+        S_copies = []
+        m = len(copy_lists[0])
+        for j in range(m):
+          for lst in copy_lists:
+            S_copies.append(lst[j])
+      else:
+        # default 'block' flattening
+        S_copies = []
+        for lst in copy_lists:
+          S_copies.extend(lst)
+
+      # Blockers (scaled by delta)
+      blockers = [(delta * a, delta * b) for (a, b) in blockers_tpl]
+
+      # Compose per schedule
+      if schedule == 'after':
+        S = S_copies + blockers
+      elif schedule == 'before':
+        S = list(blockers) + S_copies
+      elif schedule == 'split':
+        h = max(1, len(offs) // 2)
+        first = []
+        for idx in range(h):
+          first.extend(copy_lists[idx])
+        second = []
+        for idx in range(h, len(offs)):
+          second.extend(copy_lists[idx])
+        S = first + list(blockers) + second
+      else:  # 'mix': alternate a chunk of copies then one blocker, round-robin
         S = []
-        for start in offsets:
-          offset = delta * start - lo  # left-anchored translation
-          for (l, r) in from_T:
-            S.append((l + offset, r + offset))
-        return S
-
-      # Blockers as in Figure 4
-      blockers = [
-        (delta * 1,  delta * 5),
-        (delta * 12, delta * 16),
-        (delta * 4,  delta * 9),
-        (delta * 8,  delta * 13),
-      ]
-
-      if schedule == 'after':
-        S = make_copies(T, offs) + blockers
-      elif schedule == 'before':
-        S = list(blockers) + make_copies(T, offs)
-      else:  # 'split': half the copies, then blockers, then remaining copies
-        h = len(offs) // 2
-        first = offs[:h]
-        second = offs[h:]
-        S = make_copies(T, first) + list(blockers) + make_copies(T, second)
+        bi = 0
+        ci = 0
+        # chunk size: small to induce coupling
+        chunk = max(1, len(S_copies) // (len(blockers) + 1)) if blockers else len(S_copies)
+        while ci < len(S_copies) or bi < len(blockers):
+          take = min(chunk, len(S_copies) - ci)
+          if take > 0:
+            S.extend(S_copies[ci:ci+take])
+            ci += take
+          if bi < len(blockers):
+            S.append(blockers[bi])
+            bi += 1
 
       T = S
     return T
 
-  # --- Enumerate a modest set of candidates and select the best by ratio ---
-  configs = []
+  # --- Enumerate a targeted set of candidates and select the best by ratio ---
   depths = [max(2, iterations - 1), iterations]  # try one less and the given
-  schedules = ['after', 'before', 'split']
+
+  # Offsets to sweep (4-copy backbones with staggered variants; include one 5-copy option)
+  offsets_set = [
+    (2, 6, 10, 14),      # canonical backbone
+    (1, 5, 9, 13),       # shifted left
+    (3, 7, 11, 15),      # shifted right
+    (0, 4, 8, 12),       # anchored at 0
+    (2, 6, 9, 14),       # slight skew
+    (2, 7, 11, 14),      # asymmetric skew
+    (2, 6, 10, 14, 18),  # 5-copy variant
+  ]
+
+  # Blocker templates (caps) to couple towers; include extra caps variants
+  blockers_templates = [
+    ((1, 5), (12, 16), (4, 9), (8, 13)),                    # baseline (Figure 4)
+    ((1, 5), (12, 16), (3, 7), (9, 13)),                    # asymmetric mid caps
+    ((1, 6), (11, 16), (4, 8), (10, 14)),                   # lengthened extremes
+    ((0, 4), (6, 10), (8, 12), (14, 18)),                   # pushed-out caps
+    ((1, 5), (12, 16), (4, 9), (8, 13), (2, 14), (6, 10)),  # extra two caps
+  ]
+
+  schedules = ['after', 'before', 'split', 'mix']
+  interleaves = ['block', 'zip']
   extras = [False, True]
 
   best_T = None
   best_ratio = -1.0
   best_n = None
   best_cols = 0
   best_om = 0
 
   for k in depths:
-    for sch in schedules:
-      for ex in extras:
-        T = build_candidate(k, schedule=sch, extra_first=ex)
-        om = clique_number(T)
-        if om == 0:
-          continue
-        cols = firstfit_colors(T)
-        ratio = cols / om
-        n = len(T)
-        # Prefer higher ratio; tie-break by fewer intervals then more colors
-        better = False
-        if ratio > best_ratio + 1e-12:
-          better = True
-        elif abs(ratio - best_ratio) <= 1e-12:
-          if best_n is None or n < best_n:
-            better = True
-          elif n == best_n and cols > best_cols:
-            better = True
-        if better:
-          best_ratio = ratio
-          best_T = T
-          best_n = n
-          best_cols = cols
-          best_om = om
+    for offs in offsets_set:
+      for bl in blockers_templates:
+        for sch in schedules:
+          for inter in interleaves:
+            for ex in extras:
+              T = build_candidate(k, offsets=offs, blockers_tpl=bl, schedule=sch, interleave=inter, extra_first=ex)
+              om = clique_number(T)
+              if om == 0:
+                continue
+              cols = firstfit_colors(T)
+              ratio = cols / om
+              n = len(T)
+              # Prefer higher ratio; tie-break by fewer intervals then more colors
+              better = False
+              if ratio > best_ratio + 1e-12:
+                better = True
+              elif abs(ratio - best_ratio) <= 1e-12:
+                if best_n is None or n < best_n:
+                  better = True
+                elif n == best_n and cols > best_cols:
+                  better = True
+              if better:
+                best_ratio = ratio
+                best_T = T
+                best_n = n
+                best_cols = cols
+                best_om = om
 
   # Fallback to baseline 4-iteration construction if search fails
   if best_T is None:
     T = [(0, 1)]
     for i in range(iterations):
       lo = min(l for l, r in T)
       hi = max(r for l, r in T)
       delta = hi - lo
       S = []
       for start in (2, 6, 10, 14):
         S += [(delta * start + l - lo, delta * start + r - lo) for l, r in T]
       S += [
         (delta * 1, delta * 5),
         (delta * 12, delta * 16),
         (delta * 4, delta * 9),
         (delta * 8, delta * 13)
       ]
       T = S
     return T
 
   return best_T
 
   # return [  # Figure 3, OPT=2, FF=4
   #   (2,3),
   #   (6,7),
   #   (10,11),
   #   (14,15),
   #   (1,5),
   #   (12,16),
   #   (4,9),
   #   (8,13),
   # ]
 
 # EVOLVE-BLOCK-END
 
 def run_experiment(**kwargs):
   """Main called by evaluator"""
   return construct_intervals()