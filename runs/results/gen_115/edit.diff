--- a/original.py
+++ b/original.py
@@ -1,406 +1,54 @@
 # EVOLVE-BLOCK-START
 
-from math import gcd
+def construct_intervals():
+    """
+    Build a 5‐branch fractal with rich connectors, zip interleaving, and alternating reversal.
+    Returns a normalized list of integer intervals.
+    """
+    # Base seed: one unit interval
+    T = [(0.0, 1.0)]
+    # Parameters
+    depth = 4
+    offsets = [2, 6, 10, 14, 18]      # 5 copies per level
+    # Connect adjacent copies plus an end‐cap connector
+    connectors = [(offsets[i]-1, offsets[i+1]+1) for i in range(len(offsets)-1)]
+    connectors.append((offsets[0]-2, offsets[-1]+2))
 
-# ------------------------------
-# Overlap and sweep utilities
-# ------------------------------
-
-def overlaps(a, b):
-    """Open-interval overlap test: return True iff intervals overlap."""
-    (l1, r1), (l2, r2) = a, b
-    return max(l1, l2) < min(r1, r2)
-
-def clique_number(intervals):
-    """
-    Compute omega (maximum number of intervals covering a single point) using sweep.
-    Open intervals: endpoints do not contribute; handle right(-1) before left(+1) at ties.
-    """
-    events = []
-    for (l, r) in intervals:
-        if l >= r:
-            continue
-        events.append((l, +1))
-        events.append((r, -1))
-    if not events:
-        return 0
-    events.sort(key=lambda e: (e[0], 0 if e[1] == -1 else 1))
-    cur = 0
-    best = 0
-    for _, t in events:
-        cur += t
-        if cur > best:
-            best = cur
-    return best
-
-# ------------------------------
-# FirstFit simulation
-# ------------------------------
-
-def firstfit_colors(intervals):
-    """
-    Simulate FirstFit coloring on the given arrival order.
-    Return total number of colors used.
-    """
-    colors = []  # list of color classes; each is a list of intervals in arrival order
-    for iv in intervals:
-        placed = False
-        for c in colors:
-            conflict = False
-            for u in c:
-                if overlaps(u, iv):
-                    conflict = True
-                    break
-            if not conflict:
-                c.append(iv)
-                placed = True
-                break
-        if not placed:
-            colors.append([iv])
-    return len(colors)
-
-# ------------------------------
-# Pattern builder (4-copy + 4-blockers)
-# ------------------------------
-
-def make_copies(T, offsets, delta, lo, center, translation):
-    """
-    Create translated copies of T according to offsets and translation rule.
-    translation in {'left', 'center'}.
-    """
-    S = []
-    for start in offsets:
-        if translation == 'left':
-            offset = delta * start - lo
-        else:
-            offset = delta * start - center
-        for (l, r) in T:
-            S.append((l + offset, r + offset))
-    return S
-
-def add_blockers(S, blockers, delta, anchor, center):
-    """
-    Add blockers scaled by delta. Anchor may be 'left' (absolute) or 'center' (center-shifted).
-    """
-    for (a, b) in blockers:
-        if anchor == 'left':
-            S.append((delta * a, delta * b))
-        else:
-            S.append((delta * a - center, delta * b - center))
-    return S
-
-def build_pattern(k, base_seed, offsets, blockers, translation, blocker_anchor,
-                  schedule='after', interleave='block', reverse_alt=False):
-    """
-    Recursively expand the base_seed k times using the multi-copy + blockers scheme.
-    New controls:
-      - schedule: 'after' (copies then blockers), 'before' (blockers then copies),
-                  'split' (first half copies, blockers, second half copies)
-      - interleave: 'block' (emit full copies contiguously), 'zip' (round-robin)
-      - reverse_alt: if True, every other copy is presented in reversed order
-    """
-    T = list(base_seed)
-    for _ in range(k):
+    for level in range(depth):
         lo = min(l for l, r in T)
         hi = max(r for l, r in T)
         delta = hi - lo
         center = (lo + hi) / 2.0
 
-        # Build per-copy lists
+        # Build each copy, alternating reversed order
         copy_lists = []
         for idx, start in enumerate(offsets):
-            if translation == 'left':
-                off = delta * start - lo
-            else:
-                off = delta * start - center
-            seq = T if not (reverse_alt and (idx % 2 == 1)) else list(reversed(T))
-            copy_lists.append([(l + off, r + off) for (l, r) in seq])
+            off = delta * start - center
+            seq = T if (idx % 2 == 0) else list(reversed(T))
+            copy_lists.append([(l + off, r + off) for l, r in seq])
 
-        # Interleave copies
-        if interleave == 'zip' and copy_lists:
-            m = len(copy_lists[0])
-            S_copies = []
-            for j in range(m):
-                for lst in copy_lists:
-                    S_copies.append(lst[j])
-        else:
-            # default: block copies contiguously
-            S_copies = []
+        # Zip‐interleave all copies
+        S = []
+        block_size = len(copy_lists[0])
+        for i in range(block_size):
             for lst in copy_lists:
-                S_copies.extend(lst)
+                S.append(lst[i])
 
-        # Build blockers for this level
-        S_blockers = []
-        for (a, b) in blockers:
-            if blocker_anchor == 'left':
-                S_blockers.append((delta * a, delta * b))
-            else:
-                S_blockers.append((delta * a - center, delta * b - center))
+        # Add all blockers (connectors)
+        for a, b in connectors:
+            S.append((delta * a - center, delta * b - center))
 
-        # Compose according to schedule
-        if schedule == 'before':
-            S = S_blockers + S_copies
-        elif schedule == 'split' and copy_lists:
-            h = max(1, len(copy_lists) // 2)
-            first_half = []
-            for i in range(h):
-                first_half.extend(copy_lists[i])
-            second_half = []
-            for i in range(h, len(copy_lists)):
-                second_half.extend(copy_lists[i])
-            S = first_half + S_blockers + second_half
-        else:
-            S = S_copies + S_blockers
+        # Next iteration uses S
+        T = S
 
-        T = S
-    return T
-
-# ------------------------------
-# Normalization and evaluation
-# ------------------------------
-
-def normalize_intervals(intervals):
-    """
-    Normalize to small integer coordinates:
-    - scale by 2 to eliminate .5 if produced by center shifts
-    - translate so min coordinate is >= 0
-    - divide by global gcd to shrink
-    """
-    if not intervals:
-        return intervals
-    scaled = []
-    for (l, r) in intervals:
-        L = int(round(l * 2))
-        R = int(round(r * 2))
-        scaled.append((L, R))
-    min_coord = min(min(l, r) for l, r in scaled)
-    shifted = [(l - min_coord, r - min_coord) for (l, r) in scaled]
-    vals = []
-    for (l, r) in shifted:
-        vals.append(abs(l))
-        vals.append(abs(r))
-    g = 0
-    for v in vals:
-        g = gcd(g, v)
-    if g > 1:
-        shrunk = [(l // g, r // g) for (l, r) in shifted]
-    else:
-        shrunk = shifted
-    return shrunk
-
-def evaluate(intervals):
-    """
-    Compute FF colors and omega, with a small penalty for ridiculously large outputs.
-    Return (score, omega, num_colors, n, intervals_normalized)
-    """
-    Tn = normalize_intervals(intervals)
-    n = len(Tn)
-    if n == 0:
-        return (-1.0, 0, 0, n, Tn)
-    om = clique_number(Tn)
-    if om == 0:
-        return (-1.0, 0, 0, n, Tn)
-    cols = firstfit_colors(Tn)
-    ratio = cols / om
-    score = ratio - 1e-6 * (n / 10000.0)
-    return (score, om, cols, n, Tn)
-
-# ------------------------------
-# Pruning: strict then relaxed
-# ------------------------------
-
-def prune_strict(intervals, target_cols, target_omega):
-    """
-    Strict pruning: remove any interval whose removal keeps both FirstFit colors and omega unchanged.
-    Deterministic order: try longer intervals first to remove redundant long blockers if any.
-    """
-    cur = list(intervals)
-    def length(iv): return iv[1] - iv[0]
-    order = sorted(range(len(cur)), key=lambda i: (-length(cur[i]), i))
-    changed = True
-    while changed:
-        changed = False
-        for idx in list(order):
-            if idx >= len(cur):
-                continue
-            cand = cur[:idx] + cur[idx+1:]
-            Tn = normalize_intervals(cand)
-            om = clique_number(Tn)
-            cols = firstfit_colors(Tn)
-            if om == target_omega and cols == target_cols:
-                cur = cand
-                order = sorted(range(len(cur)), key=lambda i: (-length(cur[i]), i))
-                changed = True
-                break
-    return cur
-
-def prune_relaxed(intervals, min_ratio, max_omega):
-    """
-    Relaxed pruning: remove intervals if the ratio remains >= min_ratio and omega <= max_omega.
-    Prefer to remove longer intervals first; greedily iterate to fixpoint.
-    """
-    cur = list(intervals)
-    def length(iv): return iv[1] - iv[0]
-    order = sorted(range(len(cur)), key=lambda i: (-length(cur[i]), i))
-    changed = True
-    while changed:
-        changed = False
-        for idx in list(order):
-            if idx >= len(cur):
-                continue
-            cand = cur[:idx] + cur[idx+1:]
-            Tn = normalize_intervals(cand)
-            om = clique_number(Tn)
-            if om == 0 or om > max_omega:
-                continue
-            cols = firstfit_colors(Tn)
-            ratio = cols / om
-            if ratio + 1e-12 >= min_ratio and om <= max_omega:
-                cur = cand
-                order = sorted(range(len(cur)), key=lambda i: (-length(cur[i]), i))
-                changed = True
-                break
-    return cur
-
-# ------------------------------
-# Orchestrator
-# ------------------------------
-
-def construct_intervals():
-    """
-    Build a sequence of open intervals that aims to maximize FirstFit/OPT.
-    We sweep several recommended blueprints and pick the best validated candidate.
-    Then run a conservative two-phase pruning to reduce interval count without hurting the ratio.
-    """
-    # search space inspired by the provided recommendations
-    offsets_set = [
-        (2, 6, 10, 14),        # baseline
-        (1, 5, 9, 13),         # shift left
-        (3, 7, 11, 15),        # shift right
-        (0, 4, 8, 12),         # anchored at 0
-        (1.5, 5.5, 9.5, 13.5), # half-step stagger
-        (2, 6, 9, 14),         # slight skew
-        (2, 7, 11, 14),        # shifted second copy
-    ]
-    blockers_templates = [
-        # Template A: baseline
-        ((1, 5), (12, 16), (4, 9), (8, 13)),
-        # Template B: early/late shorter
-        ((0, 4), (6, 10), (8, 12), (14, 18)),
-        # Template C: tighter middle coupling
-        ((2, 6), (4, 8), (10, 14), (12, 16)),
-        # Template D: asymmetric nudges
-        ((1, 5), (12, 16), (3, 7), (9, 13)),
-        # Template E: lengthened extremes
-        ((1, 6), (11, 16), (4, 8), (10, 14)),
-        # Template F: six-blocker couplers (adds two caps)
-        ((1, 5), (12, 16), (4, 9), (8, 13), (2, 14), (6, 10)),
-    ]
-    translations = ['left', 'center']  # how copies are positioned
-    blocker_anchors = ['left', 'center']  # how blockers are positioned
-    depths = [3, 4, 5]  # sweep as recommended
-    schedules = ['after', 'before', 'split']
-    interleaves = ['block', 'zip']
-    reverse_flags = [False, True]
-    base_seeds = [
-        [(0.0, 1.0)],                      # single seed (classic)
-        [(0.0, 1.0), (2.0, 3.0)],          # two disjoint seeds variant
-    ]
-    extra_copies_opts = [0, 1, 2]  # allow up to two extra translated copies on first level
-
-    best = None  # (score, om, cols, n, intervals_norm, raw_intervals)
-    # Enumerate combinations with a guard on worst-case explosion
-    for base in base_seeds:
-        for k in depths:
-            for offsets in offsets_set:
-                for blockers in blockers_templates:
-                    for translation in translations:
-                        for anchor in blocker_anchors:
-                            for extra in extra_copies_opts:
-                                offs = list(offsets)
-                                if extra >= 1:
-                                    last = offs[-1] if offs else 0
-                                    offs.append(last + 4)
-                                if extra == 2:
-                                    last2 = offs[-2] if len(offs) >= 2 else (offs[-1] if offs else 0)
-                                    offs.append(last2 + 8)
-                                offs = tuple(offs)
-
-                                # crude size guard adjusted for arbitrary number of copies per level
-                                approx = (len(offs) ** k) * (len(base) + len(blockers))
-                                if approx > 3500:
-                                    continue
-
-                                for schedule in schedules:
-                                    for interleave in interleaves:
-                                        for rev in reverse_flags:
-                                            T = build_pattern(
-                                                k=k,
-                                                base_seed=base,
-                                                offsets=offs,
-                                                blockers=blockers,
-                                                translation=translation,
-                                                blocker_anchor=anchor,
-                                                schedule=schedule,
-                                                interleave=interleave,
-                                                reverse_alt=rev,
-                                            )
-                                            score, om, cols, n, Tn = evaluate(T)
-                                            cand = (score, om, cols, n, Tn, T)
-                                            if best is None:
-                                                best = cand
-                                            else:
-                                                if cand[0] > best[0] + 1e-9:
-                                                    best = cand
-                                                elif abs(cand[0] - best[0]) <= 1e-9:
-                                                    if cand[3] < best[3]:
-                                                        best = cand
-                                                    elif cand[3] == best[3] and cand[2] > best[2]:
-                                                        best = cand
-
-    # Fallback to baseline if search didn't produce anything
-    if best is None:
-        k = 4
-        T = [(0.0, 1.0)]
-        for _ in range(k):
-            lo = min(l for l, r in T)
-            hi = max(r for l, r in T)
-            delta = hi - lo
-            S = []
-            for start in (2, 6, 10, 14):
-                offset = delta * start - lo
-                for (l, r) in T:
-                    S.append((l + offset, r + offset))
-            S += [
-                (delta * 1,  delta * 5),
-                (delta * 12, delta * 16),
-                (delta * 4,  delta * 9),
-                (delta * 8,  delta * 13),
-            ]
-            T = S
-        return normalize_intervals(T)
-
-    # Apply two-phase pruning to the raw best intervals
-    raw_best = best[5]
-    _, best_om, best_cols, _, _, _ = best
-    # Phase 1: strict pruning (keep alg and omega identical)
-    phase1 = prune_strict(raw_best, best_cols, best_om)
-    # Phase 2: relaxed pruning (keep ratio and omega cap)
-    target_ratio = best_cols / best_om if best_om > 0 else 0.0
-    phase2 = prune_relaxed(phase1, target_ratio, best_om)
-
-    final = normalize_intervals(phase2)
-    if not final:
-        return best[4]
-    # Final safety: if ratio dropped (shouldn't), revert to best normalized
-    om = clique_number(final)
-    cols = firstfit_colors(final)
-    if om == 0 or cols / om + 1e-12 < target_ratio or om > best_om:
-        return best[4]
-    return final
+    # Normalize to small integer grid (even spacing)
+    pts = sorted(set(x for seg in T for x in seg))
+    coord = {v: 2*i for i, v in enumerate(pts)}
+    normalized = [(coord[l], coord[r]) for (l, r) in T]
+    return normalized
 
 # EVOLVE-BLOCK-END
 
 def run_experiment(**kwargs):
   """Main called by evaluator"""
   return construct_intervals()