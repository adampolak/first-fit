--- a/original.py
+++ b/original.py
@@ -1,61 +1,163 @@
 # EVOLVE-BLOCK-START
 
 def construct_intervals(iterations=4):
   """
-  Construct a sequence of intervals of real line,
-  in the order in which they are presented to FirstFit,
-  so that it maximizes the number of colors used by FirstFit
-  divided by the maximum number of intervals that cover a single point
-
-  The implementation uses the construction from
-  Figure 4 in https://arxiv.org/abs/1506.00192 and increases
-  the number of recursive expansions to produce a stronger adversary.
-
-  Arguments:
-    iterations: number of recursive expansion steps (default 4)
-
-  Returns:
-    intervals: list of tuples, each tuple (l, r) represents an open interval from l to r
+  Construct a sequence of intervals of real line to maximize FirstFit/omega.
+  We explore small variations inspired by adversarial arrival-order engineering:
+  - schedule of blockers vs copies at each level (before/after/split)
+  - optional extra copy at the first iteration to couple layers
+  We evaluate candidates via an in-block FirstFit and omega computation, and return the best.
   """
 
-  T = [(0, 1)]
-  # Each iteration replaces T by four translated/scaled copies plus four
-  # longer intervals that connect the copies in the manner of Figure 4.
-  for i in range(iterations):
-    lo = min(l for l, r in T)
-    hi = max(r for l, r in T)
-    delta = hi - lo
-    S = []
-    # dynamic offsets: extra copy on first iteration to diversify branching
-    if i == 0:
-      offsets = (2, 6, 10, 14, 18)
-    else:
-      offsets = (2, 6, 10, 14)
-    for start in offsets:
-      S += [(delta * start + l - lo, delta * start + r - lo) for l, r in T]
-    # Add the four connecting long intervals as in the original figure
-    S += [
-      (delta * 1, delta * 5),
-      (delta * 12, delta * 16),
-      (delta * 4, delta * 9),
-      (delta * 8, delta * 13)
-    ]
-    T = S
-  return T
+  # --- Helper routines (kept lightweight and deterministic) ---
+
+  def firstfit_colors(intervals):
+    """Simulate FirstFit using per-color last end-point tracking."""
+    last_end = []
+    for (l, r) in intervals:
+      placed = False
+      for i, le in enumerate(last_end):
+        if l >= le:
+          last_end[i] = r
+          placed = True
+          break
+      if not placed:
+        last_end.append(r)
+    return len(last_end)
+
+  def clique_number(intervals):
+    """Sweep for open intervals; process right endpoints before left at ties."""
+    events = []
+    for (l, r) in intervals:
+      if l < r:
+        events.append((l, +1))
+        events.append((r, -1))
+    events.sort(key=lambda e: (e[0], 0 if e[1] == -1 else 1))
+    cur = best = 0
+    for _, t in events:
+      cur += t
+      if cur > best:
+        best = cur
+    return best
+
+  def build_candidate(k, schedule='after', extra_first=False):
+    """
+    Build k-level recursive pattern using four scaled copies per level,
+    with four long connectors ("blockers"), and schedule controlling
+    the arrival order within each level.
+    schedule in {'after','before','split'}.
+    """
+    T = [(0.0, 1.0)]
+    for i in range(k):
+      lo = min(l for l, r in T)
+      hi = max(r for l, r in T)
+      delta = hi - lo
+
+      # Offsets for this level; optionally add a fifth copy on the first iteration
+      offs = (2, 6, 10, 14, 18) if (extra_first and i == 0) else (2, 6, 10, 14)
+
+      # Prepare copies
+      def make_copies(from_T, offsets):
+        S = []
+        for start in offsets:
+          offset = delta * start - lo  # left-anchored translation
+          for (l, r) in from_T:
+            S.append((l + offset, r + offset))
+        return S
+
+      # Blockers as in Figure 4
+      blockers = [
+        (delta * 1,  delta * 5),
+        (delta * 12, delta * 16),
+        (delta * 4,  delta * 9),
+        (delta * 8,  delta * 13),
+      ]
+
+      if schedule == 'after':
+        S = make_copies(T, offs) + blockers
+      elif schedule == 'before':
+        S = list(blockers) + make_copies(T, offs)
+      else:  # 'split': half the copies, then blockers, then remaining copies
+        h = len(offs) // 2
+        first = offs[:h]
+        second = offs[h:]
+        S = make_copies(T, first) + list(blockers) + make_copies(T, second)
+
+      T = S
+    return T
+
+  # --- Enumerate a modest set of candidates and select the best by ratio ---
+  configs = []
+  depths = [max(2, iterations - 1), iterations]  # try one less and the given
+  schedules = ['after', 'before', 'split']
+  extras = [False, True]
+
+  best_T = None
+  best_ratio = -1.0
+  best_n = None
+  best_cols = 0
+  best_om = 0
+
+  for k in depths:
+    for sch in schedules:
+      for ex in extras:
+        T = build_candidate(k, schedule=sch, extra_first=ex)
+        om = clique_number(T)
+        if om == 0:
+          continue
+        cols = firstfit_colors(T)
+        ratio = cols / om
+        n = len(T)
+        # Prefer higher ratio; tie-break by fewer intervals then more colors
+        better = False
+        if ratio > best_ratio + 1e-12:
+          better = True
+        elif abs(ratio - best_ratio) <= 1e-12:
+          if best_n is None or n < best_n:
+            better = True
+          elif n == best_n and cols > best_cols:
+            better = True
+        if better:
+          best_ratio = ratio
+          best_T = T
+          best_n = n
+          best_cols = cols
+          best_om = om
+
+  # Fallback to baseline 4-iteration construction if search fails
+  if best_T is None:
+    T = [(0, 1)]
+    for i in range(iterations):
+      lo = min(l for l, r in T)
+      hi = max(r for l, r in T)
+      delta = hi - lo
+      S = []
+      for start in (2, 6, 10, 14):
+        S += [(delta * start + l - lo, delta * start + r - lo) for l, r in T]
+      S += [
+        (delta * 1, delta * 5),
+        (delta * 12, delta * 16),
+        (delta * 4, delta * 9),
+        (delta * 8, delta * 13)
+      ]
+      T = S
+    return T
+
+  return best_T
 
   # return [  # Figure 3, OPT=2, FF=4
   #   (2,3),
   #   (6,7),
   #   (10,11),
   #   (14,15),
   #   (1,5),
   #   (12,16),
   #   (4,9),
   #   (8,13),
   # ]
 
 # EVOLVE-BLOCK-END
 
 def run_experiment(**kwargs):
   """Main called by evaluator"""
   return construct_intervals()