--- a/original.py
+++ b/original.py
@@ -1,42 +1,68 @@
 # EVOLVE-BLOCK-START
 
-def construct_intervals():
-    """
-    Build a sequence of open intervals that forces FirstFit
-    to use ~13 colors while the maximum clique size is 5,
-    achieving a ratio ≈2.6.
-    """
-    # key parameter: recursion depth
-    k = 4
+def _normalize_grid(intervals):
+  """
+  Normalize endpoints to a compact integer grid while preserving order.
+  Each unique endpoint is mapped to an increasing even integer.
+  Returns a new list of (l, r) with integer coordinates.
+  """
+  endpoints = sorted(set([x for seg in intervals for x in seg]))
+  coord = {}
+  cur = 0
+  for e in endpoints:
+    coord[e] = cur
+    cur += 2  # spacing by 2 to keep even gaps
 
-    # base case: one small interval
-    T = [(0.0, 1.0)]
+  return [(coord[l], coord[r]) for (l, r) in intervals]
 
-    # each iteration makes 4 scaled copies + 4 blockers
-    for _ in range(k):
-        lo = min(l for l, r in T)
-        hi = max(r for l, r in T)
-        delta = hi - lo
 
-        S = []
-        # 4 tiled copies at positions 2,6,10,14
-        for start in (2, 6, 10, 14):
-            offset = delta * start - lo
-            for (l, r) in T:
-                S.append((l + offset, r + offset))
+def construct_intervals(iterations=4, normalize=True):
+  """
+  Build a sequence of open intervals that forces FirstFit
+  to use many colors while keeping the clique size controlled.
+  This is a cross-over of:
+    - Figure-4 style recursive expansion (four copies per level, plus four blockers)
+    - a normalization step to map endpoints to a compact integer grid
 
-        # 4 extra “blocking” intervals that overlap all four copies
-        S.append((delta * 1,  delta * 5))
-        S.append((delta * 12, delta * 16))
-        S.append((delta * 4,  delta * 9))
-        S.append((delta * 8,  delta * 13))
+  Arguments:
+    iterations: number of recursive expansion steps (default 4)
+    normalize: whether to apply endpoint normalization (default True)
 
-        T = S
+  Returns:
+    intervals: list of tuples (l, r) with integer endpoints (open intervals)
+  """
+  # Base gadget: a canonical small pattern (one unit interval)
+  T = [(0.0, 1.0)]
 
+  # For each iteration we replace T by four translated/scaled copies
+  # plus four long connector intervals (as in the Figure-4 construction).
+  for _ in range(iterations):
+    lo = min(l for l, r in T)
+    hi = max(r for l, r in T)
+    delta = hi - lo
+    S = []
+    # Place four scaled/translated copies at staggered offsets
+    for start in (2, 6, 10, 14):
+      offset = delta * start - lo
+      S.extend([(offset + l, offset + r) for l, r in T])
+    # Add the four connecting long intervals (these create the coupling
+    # between copies but are designed not to increase the clique beyond
+    # the intended constant)
+    S += [
+      (delta * 1,  delta * 5),
+      (delta * 12, delta * 16),
+      (delta * 4,  delta * 9),
+      (delta * 8,  delta * 13)
+    ]
+    T = S
+
+  if normalize:
+    return _normalize_grid(T)
+  else:
     return T
 
 # EVOLVE-BLOCK-END
 
 def run_experiment(**kwargs):
   """Main called by evaluator"""
   return construct_intervals()