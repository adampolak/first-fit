<NAME>
param_sweep_offsets_blockers
</NAME>

<DESCRIPTION>
I introduce a small, self-contained parameter sweep inside construct_intervals that explores nearby recursive blueprints without rewriting the whole module. The sweep varies:
- offsets for the 4 tiled copies (four symmetric choices),
- blocker templates (three variants),
- arrival-order schedule (before/after/split),
- translation anchor (left/center),
- recursion depth around the baseline (iterations-1, iterations, iterations+1 capped to 5).

This is inspired by known techniques to exploit arrival-order engineering and slight geometric variations that can increase FirstFitâ€™s color usage without increasing the clique number, as seen in the literature and the 4-copy/4-blocker construction. The evaluation uses lightweight nested helpers for FirstFit counting and omega via sweep (open-interval semantics) on the raw coordinates; the final chosen instance is normalized to a compact integer grid exactly as before.

This targeted change keeps the existing normalization and API but adds a principled search over variants that have shown promise in prior work, potentially discovering a better FF/omega ratio (or confirming the baseline) while staying within modest size bounds.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
def construct_intervals(iterations=4, normalize=True):
  """
  Build a sequence of open intervals that forces FirstFit
  to use many colors while keeping the clique size controlled.
  This is a cross-over of:
    - Figure-4 style recursive expansion (four copies per level, plus four blockers)
    - a normalization step to map endpoints to a compact integer grid

  Arguments:
    iterations: number of recursive expansion steps (default 4)
    normalize: whether to apply endpoint normalization (default True)

  Returns:
    intervals: list of tuples (l, r) with integer endpoints (open intervals)
  """
  # Base gadget: a canonical small pattern (one unit interval)
  T = [(0.0, 1.0)]

  # For each iteration we replace T by four translated/scaled copies
  # plus four long connector intervals (as in the Figure-4 construction).
  for _ in range(iterations):
    lo = min(l for l, r in T)
    hi = max(r for l, r in T)
    delta = hi - lo
    S = []
    # Place four scaled/translated copies at staggered offsets
    for start in (2, 6, 10, 14):
      offset = delta * start - lo
      S.extend([(offset + l, offset + r) for l, r in T])
    # Add the four connecting long intervals (these create the coupling
    # between copies but are designed not to increase the clique beyond
    # the intended constant)
    S += [
      (delta * 1,  delta * 5),
      (delta * 12, delta * 16),
      (delta * 4,  delta * 9),
      (delta * 8,  delta * 13)
    ]
    T = S

  if normalize:
    return _normalize_grid(T)
  else:
    return T
=======
def construct_intervals(iterations=4, normalize=True):
  """
  Build a sequence of open intervals that aims to maximize FirstFit/omega
  using a small parameter sweep around the canonical 4-copy/4-blocker recursion.
  The final output is normalized to a compact integer grid.
  """
  # Local helpers to evaluate candidates on raw coordinates (open intervals)
  def _ff_count(intervals):
    last_end = []
    for (l, r) in intervals:
      placed = False
      for i, le in enumerate(last_end):
        if l >= le:
          last_end[i] = r
          placed = True
          break
      if not placed:
        last_end.append(r)
    return len(last_end)

  def _omega_open(intervals):
    events = []
    for (l, r) in intervals:
      if l < r:
        events.append((l, +1))
        events.append((r, -1))
    # right (-1) before left (+1) on ties (open intervals)
    events.sort(key=lambda e: (e[0], 0 if e[1] == -1 else 1))
    cur = best = 0
    for _, t in events:
      cur += t
      if cur > best:
        best = cur
    return best

  # Parameterized builder
  def _build(depth, starts, blockers, schedule='after', translation='left'):
    T = [(0.0, 1.0)]
    for _ in range(depth):
      lo = min(l for l, r in T)
      hi = max(r for l, r in T)
      delta = hi - lo
      center = (lo + hi) / 2.0

      def place_copies(from_T, offs):
        U = []
        for start in offs:
          offset = delta * start - (lo if translation == 'left' else center)
          for (l, r) in from_T:
            U.append((l + offset, r + offset))
        return U

      # scale blockers according to anchor
      if translation == 'left':
        blk = [(delta * a, delta * b) for (a, b) in blockers]
      else:
        blk = [(delta * a - center, delta * b - center) for (a, b) in blockers]

      if schedule == 'before':
        S = list(blk) + place_copies(T, starts)
      elif schedule == 'split':
        h = len(starts) // 2
        S = place_copies(T, starts[:h]) + list(blk) + place_copies(T, starts[h:])
      else:  # 'after'
        S = place_copies(T, starts) + list(blk)
      T = S
    return T

  # Sweep a modest space of blueprints
  depths = sorted(set([max(2, iterations - 1), max(2, iterations), min(5, iterations + 1)]))
  start_sets = [
    (2, 6, 10, 14),  # canonical
    (1, 5, 9, 13),
    (3, 7, 11, 15),
    (0, 4, 8, 12),
  ]
  blocker_templates = [
    [(1, 5), (12, 16), (4, 9), (8, 13)],   # canonical
    [(1, 5), (11, 15), (4, 9), (8, 13)],   # slight shift
    [(2, 6), (12, 16), (4, 9), (8, 13)],   # shift first
  ]
  schedules = ['after', 'before', 'split']
  translations = ['left', 'center']

  best_T = None
  best_ratio = -1.0
  best_n = None
  best_cols = 0
  best_om = 0

  for d in depths:
    for starts in start_sets:
      for blockers in blocker_templates:
        for sch in schedules:
          for tr in translations:
            T = _build(d, starts, blockers, schedule=sch, translation=tr)
            n = len(T)
            # guard against explosion (keep search modest)
            if n > 2000:
              continue
            om = _omega_open(T)
            if om <= 0:
              continue
            cols = _ff_count(T)
            ratio = cols / om
            better = False
            if ratio > best_ratio + 1e-12:
              better = True
            elif abs(ratio - best_ratio) <= 1e-12:
              if best_n is None or n < best_n:
                better = True
              elif n == best_n and cols > best_cols:
                better = True
            if better:
              best_ratio = ratio
              best_T = T
              best_n = n
              best_cols = cols
              best_om = om

  # Fallback to canonical if search didn't produce anything
  if best_T is None:
    T = _build(max(2, iterations), (2, 6, 10, 14), [(1, 5), (12, 16), (4, 9), (8, 13)], schedule='after', translation='left')
  else:
    T = best_T

  return _normalize_grid(T) if normalize else T
>>>>>>> REPLACE
</DIFF>