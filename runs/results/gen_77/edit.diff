--- a/original.py
+++ b/original.py
@@ -1,68 +1,151 @@
 # EVOLVE-BLOCK-START
 
 def _normalize_grid(intervals):
   """
   Normalize endpoints to a compact integer grid while preserving order.
   Each unique endpoint is mapped to an increasing even integer.
   Returns a new list of (l, r) with integer coordinates.
   """
   endpoints = sorted(set([x for seg in intervals for x in seg]))
   coord = {}
   cur = 0
   for e in endpoints:
     coord[e] = cur
     cur += 2  # spacing by 2 to keep even gaps
 
   return [(coord[l], coord[r]) for (l, r) in intervals]
 
 
 def construct_intervals(iterations=4, normalize=True):
   """
-  Build a sequence of open intervals that forces FirstFit
-  to use many colors while keeping the clique size controlled.
-  This is a cross-over of:
-    - Figure-4 style recursive expansion (four copies per level, plus four blockers)
-    - a normalization step to map endpoints to a compact integer grid
+  Build a sequence of open intervals that aims to maximize FirstFit/omega
+  using a small parameter sweep around the canonical 4-copy/4-blocker recursion.
+  The final output is normalized to a compact integer grid.
+  """
+  # Local helpers to evaluate candidates on raw coordinates (open intervals)
+  def _ff_count(intervals):
+    last_end = []
+    for (l, r) in intervals:
+      placed = False
+      for i, le in enumerate(last_end):
+        if l >= le:
+          last_end[i] = r
+          placed = True
+          break
+      if not placed:
+        last_end.append(r)
+    return len(last_end)
 
-  Arguments:
-    iterations: number of recursive expansion steps (default 4)
-    normalize: whether to apply endpoint normalization (default True)
+  def _omega_open(intervals):
+    events = []
+    for (l, r) in intervals:
+      if l < r:
+        events.append((l, +1))
+        events.append((r, -1))
+    # right (-1) before left (+1) on ties (open intervals)
+    events.sort(key=lambda e: (e[0], 0 if e[1] == -1 else 1))
+    cur = best = 0
+    for _, t in events:
+      cur += t
+      if cur > best:
+        best = cur
+    return best
 
-  Returns:
-    intervals: list of tuples (l, r) with integer endpoints (open intervals)
-  """
-  # Base gadget: a canonical small pattern (one unit interval)
-  T = [(0.0, 1.0)]
+  # Parameterized builder
+  def _build(depth, starts, blockers, schedule='after', translation='left'):
+    T = [(0.0, 1.0)]
+    for _ in range(depth):
+      lo = min(l for l, r in T)
+      hi = max(r for l, r in T)
+      delta = hi - lo
+      center = (lo + hi) / 2.0
 
-  # For each iteration we replace T by four translated/scaled copies
-  # plus four long connector intervals (as in the Figure-4 construction).
-  for _ in range(iterations):
-    lo = min(l for l, r in T)
-    hi = max(r for l, r in T)
-    delta = hi - lo
-    S = []
-    # Place four scaled/translated copies at staggered offsets
-    for start in (2, 6, 10, 14):
-      offset = delta * start - lo
-      S.extend([(offset + l, offset + r) for l, r in T])
-    # Add the four connecting long intervals (these create the coupling
-    # between copies but are designed not to increase the clique beyond
-    # the intended constant)
-    S += [
-      (delta * 1,  delta * 5),
-      (delta * 12, delta * 16),
-      (delta * 4,  delta * 9),
-      (delta * 8,  delta * 13)
-    ]
-    T = S
+      def place_copies(from_T, offs):
+        U = []
+        for start in offs:
+          offset = delta * start - (lo if translation == 'left' else center)
+          for (l, r) in from_T:
+            U.append((l + offset, r + offset))
+        return U
 
-  if normalize:
-    return _normalize_grid(T)
+      # scale blockers according to anchor
+      if translation == 'left':
+        blk = [(delta * a, delta * b) for (a, b) in blockers]
+      else:
+        blk = [(delta * a - center, delta * b - center) for (a, b) in blockers]
+
+      if schedule == 'before':
+        S = list(blk) + place_copies(T, starts)
+      elif schedule == 'split':
+        h = len(starts) // 2
+        S = place_copies(T, starts[:h]) + list(blk) + place_copies(T, starts[h:])
+      else:  # 'after'
+        S = place_copies(T, starts) + list(blk)
+      T = S
+    return T
+
+  # Sweep a modest space of blueprints
+  depths = sorted(set([max(2, iterations - 1), max(2, iterations), min(5, iterations + 1)]))
+  start_sets = [
+    (2, 6, 10, 14),  # canonical
+    (1, 5, 9, 13),
+    (3, 7, 11, 15),
+    (0, 4, 8, 12),
+  ]
+  blocker_templates = [
+    [(1, 5), (12, 16), (4, 9), (8, 13)],   # canonical
+    [(1, 5), (11, 15), (4, 9), (8, 13)],   # slight shift
+    [(2, 6), (12, 16), (4, 9), (8, 13)],   # shift first
+  ]
+  schedules = ['after', 'before', 'split']
+  translations = ['left', 'center']
+
+  best_T = None
+  best_ratio = -1.0
+  best_n = None
+  best_cols = 0
+  best_om = 0
+
+  for d in depths:
+    for starts in start_sets:
+      for blockers in blocker_templates:
+        for sch in schedules:
+          for tr in translations:
+            T = _build(d, starts, blockers, schedule=sch, translation=tr)
+            n = len(T)
+            # guard against explosion (keep search modest)
+            if n > 2000:
+              continue
+            om = _omega_open(T)
+            if om <= 0:
+              continue
+            cols = _ff_count(T)
+            ratio = cols / om
+            better = False
+            if ratio > best_ratio + 1e-12:
+              better = True
+            elif abs(ratio - best_ratio) <= 1e-12:
+              if best_n is None or n < best_n:
+                better = True
+              elif n == best_n and cols > best_cols:
+                better = True
+            if better:
+              best_ratio = ratio
+              best_T = T
+              best_n = n
+              best_cols = cols
+              best_om = om
+
+  # Fallback to canonical if search didn't produce anything
+  if best_T is None:
+    T = _build(max(2, iterations), (2, 6, 10, 14), [(1, 5), (12, 16), (4, 9), (8, 13)], schedule='after', translation='left')
   else:
-    return T
+    T = best_T
+
+  return _normalize_grid(T) if normalize else T
 
 # EVOLVE-BLOCK-END
 
 def run_experiment(**kwargs):
   """Main called by evaluator"""
   return construct_intervals()