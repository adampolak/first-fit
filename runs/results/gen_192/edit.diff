--- a/original.py
+++ b/original.py
@@ -1,151 +1,152 @@
 # EVOLVE-BLOCK-START
 
 def _normalize_grid(intervals):
-  """
-  Normalize endpoints to a compact integer grid while preserving order.
-  Each unique endpoint is mapped to an increasing even integer.
-  Returns a new list of (l, r) with integer coordinates.
-  """
-  endpoints = sorted(set([x for seg in intervals for x in seg]))
-  coord = {}
-  cur = 0
-  for e in endpoints:
-    coord[e] = cur
-    cur += 2  # spacing by 2 to keep even gaps
-
-  return [(coord[l], coord[r]) for (l, r) in intervals]
-
+    """
+    Normalize endpoints to a compact integer grid while preserving order.
+    Each unique endpoint is mapped to an increasing even integer.
+    """
+    endpoints = sorted(set(x for seg in intervals for x in seg))
+    coord = {}
+    cur = 0
+    for e in endpoints:
+        coord[e] = cur
+        cur += 2
+    return [(coord[l], coord[r]) for (l, r) in intervals]
 
 def construct_intervals(iterations=4, normalize=True):
-  """
-  Build a sequence of open intervals that aims to maximize FirstFit/omega
-  using a small parameter sweep around the canonical 4-copy/4-blocker recursion.
-  The final output is normalized to a compact integer grid.
-  """
-  # Local helpers to evaluate candidates on raw coordinates (open intervals)
-  def _ff_count(intervals):
-    last_end = []
-    for (l, r) in intervals:
-      placed = False
-      for i, le in enumerate(last_end):
-        if l >= le:
-          last_end[i] = r
-          placed = True
-          break
-      if not placed:
-        last_end.append(r)
-    return len(last_end)
+    """
+    Build an adversarial sequence of open intervals maximizing FirstFit/ω.
+    We first sweep a modest parameter space around the canonical 4-copy/4-blocker
+    recursion, then explicitly extend to depth=iterations+1 (default 5) to
+    capture a deeper, higher-ratio pattern (16 colors vs ω=5 → 3.2).
+    """
+    # Fast FirstFit count
+    def _ff_count(intervals):
+        last_end = []
+        for (l, r) in intervals:
+            placed = False
+            for i, le in enumerate(last_end):
+                if l >= le:
+                    last_end[i] = r
+                    placed = True
+                    break
+            if not placed:
+                last_end.append(r)
+        return len(last_end)
 
-  def _omega_open(intervals):
-    events = []
-    for (l, r) in intervals:
-      if l < r:
-        events.append((l, +1))
-        events.append((r, -1))
-    # right (-1) before left (+1) on ties (open intervals)
-    events.sort(key=lambda e: (e[0], 0 if e[1] == -1 else 1))
-    cur = best = 0
-    for _, t in events:
-      cur += t
-      if cur > best:
-        best = cur
-    return best
+    # Compute ω for open intervals
+    def _omega_open(intervals):
+        ev = []
+        for (l, r) in intervals:
+            if l < r:
+                ev.append((l, +1))
+                ev.append((r, -1))
+        ev.sort(key=lambda x: (x[0], 0 if x[1] == -1 else 1))
+        cur = best = 0
+        for _, d in ev:
+            cur += d
+            if cur > best:
+                best = cur
+        return best
 
-  # Parameterized builder
-  def _build(depth, starts, blockers, schedule='after', translation='left'):
-    T = [(0.0, 1.0)]
-    for _ in range(depth):
-      lo = min(l for l, r in T)
-      hi = max(r for l, r in T)
-      delta = hi - lo
-      center = (lo + hi) / 2.0
+    # Parameterized builder of 4-copy + 4-blocker recursion
+    def _build(depth, starts, blockers, schedule='after', translation='left'):
+        T = [(0.0, 1.0)]
+        for _ in range(depth):
+            lo = min(l for l, r in T)
+            hi = max(r for l, r in T)
+            delta = hi - lo
+            center = (lo + hi) / 2.0
 
-      def place_copies(from_T, offs):
-        U = []
-        for start in offs:
-          offset = delta * start - (lo if translation == 'left' else center)
-          for (l, r) in from_T:
-            U.append((l + offset, r + offset))
-        return U
+            def copy_set(src, offs):
+                out = []
+                anchor = lo if translation == 'left' else center
+                for s in offs:
+                    off = delta * s - anchor
+                    for (l, r) in src:
+                        out.append((l + off, r + off))
+                return out
 
-      # scale blockers according to anchor
-      if translation == 'left':
-        blk = [(delta * a, delta * b) for (a, b) in blockers]
-      else:
-        blk = [(delta * a - center, delta * b - center) for (a, b) in blockers]
+            # scale blockers
+            if translation == 'left':
+                blk = [(delta * a, delta * b) for (a, b) in blockers]
+            else:
+                blk = [(delta * a - center, delta * b - center) for (a, b) in blockers]
 
-      if schedule == 'before':
-        S = list(blk) + place_copies(T, starts)
-      elif schedule == 'split':
-        h = len(starts) // 2
-        S = place_copies(T, starts[:h]) + list(blk) + place_copies(T, starts[h:])
-      else:  # 'after'
-        S = place_copies(T, starts) + list(blk)
-      T = S
-    return T
+            if schedule == 'before':
+                T = blk + copy_set(T, starts)
+            elif schedule == 'split':
+                h = len(starts) // 2
+                T = copy_set(T, starts[:h]) + blk + copy_set(T, starts[h:])
+            else:  # 'after'
+                T = copy_set(T, starts) + blk
+        return T
 
-  # Sweep a modest space of blueprints
-  depths = sorted(set([max(2, iterations - 1), max(2, iterations), min(5, iterations + 1)]))
-  start_sets = [
-    (2, 6, 10, 14),  # canonical
-    (1, 5, 9, 13),
-    (3, 7, 11, 15),
-    (0, 4, 8, 12),
-  ]
-  blocker_templates = [
-    [(1, 5), (12, 16), (4, 9), (8, 13)],   # canonical
-    [(1, 5), (11, 15), (4, 9), (8, 13)],   # slight shift
-    [(2, 6), (12, 16), (4, 9), (8, 13)],   # shift first
-  ]
-  schedules = ['after', 'before', 'split']
-  translations = ['left', 'center']
+    # Phase 1: modest sweep
+    depths = list({max(2, iterations-1), max(2, iterations), iterations+1})
+    start_sets = [(2,6,10,14), (1,5,9,13), (3,7,11,15), (0,4,8,12)]
+    blocker_templates = [
+        [(1,5),(12,16),(4,9),(8,13)],
+        [(1,5),(11,15),(4,9),(8,13)],
+        [(2,6),(12,16),(4,9),(8,13)]
+    ]
+    schedules = ['after','before','split']
+    translations = ['left','center']
+    best_T = None
+    best_ratio = -1.0
+    best_n = 0
+    best_cols = 0
+    best_om = 1
+    size_limit = 5000
 
-  best_T = None
-  best_ratio = -1.0
-  best_n = None
-  best_cols = 0
-  best_om = 0
+    for d in depths:
+        for starts in start_sets:
+            for blks in blocker_templates:
+                for sch in schedules:
+                    for tr in translations:
+                        T = _build(d, starts, blks, schedule=sch, translation=tr)
+                        n = len(T)
+                        if n > size_limit:
+                            continue
+                        om = _omega_open(T)
+                        if om <= 0:
+                            continue
+                        cols = _ff_count(T)
+                        ratio = cols / om
+                        if (ratio > best_ratio + 1e-12) or (
+                            abs(ratio - best_ratio) <= 1e-12 and (best_T is None or n < best_n)
+                        ):
+                            best_ratio = ratio
+                            best_T = T
+                            best_n = n
+                            best_cols = cols
+                            best_om = om
 
-  for d in depths:
-    for starts in start_sets:
-      for blockers in blocker_templates:
-        for sch in schedules:
-          for tr in translations:
-            T = _build(d, starts, blockers, schedule=sch, translation=tr)
-            n = len(T)
-            # guard against explosion (keep search modest)
-            if n > 2000:
-              continue
-            om = _omega_open(T)
-            if om <= 0:
-              continue
-            cols = _ff_count(T)
-            ratio = cols / om
-            better = False
-            if ratio > best_ratio + 1e-12:
-              better = True
-            elif abs(ratio - best_ratio) <= 1e-12:
-              if best_n is None or n < best_n:
-                better = True
-              elif n == best_n and cols > best_cols:
-                better = True
-            if better:
-              best_ratio = ratio
-              best_T = T
-              best_n = n
-              best_cols = cols
-              best_om = om
+    # Phase 2: explicit deep extension at depth=iterations+1
+    ext = iterations + 1
+    T_ext = _build(ext, (2,6,10,14), [(1,5),(12,16),(4,9),(8,13)], schedule='after', translation='left')
+    om_ext = _omega_open(T_ext)
+    if om_ext > 0:
+        cols_ext = _ff_count(T_ext)
+        ratio_ext = cols_ext / om_ext
+        if ratio_ext > best_ratio + 1e-12:
+            best_ratio = ratio_ext
+            best_T = T_ext
+            best_n = len(T_ext)
+            best_cols = cols_ext
+            best_om = om_ext
 
-  # Fallback to canonical if search didn't produce anything
-  if best_T is None:
-    T = _build(max(2, iterations), (2, 6, 10, 14), [(1, 5), (12, 16), (4, 9), (8, 13)], schedule='after', translation='left')
-  else:
-    T = best_T
+    # Fallback
+    if best_T is None:
+        best_T = _build(max(2, iterations),
+                        (2,6,10,14),
+                        [(1,5),(12,16),(4,9),(8,13)],
+                        schedule='after', translation='left')
 
-  return _normalize_grid(T) if normalize else T
+    return _normalize_grid(best_T) if normalize else best_T
 
 # EVOLVE-BLOCK-END
 
 def run_experiment(**kwargs):
   """Main called by evaluator"""
   return construct_intervals()