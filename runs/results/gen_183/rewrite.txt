# EVOLVE-BLOCK-START

from math import gcd
from functools import reduce

def construct_intervals(iterations=4):
    """
    Build a sequence of open intervals that aims to maximize FirstFit/OPT ratio.

    Strategy (crossover):
      - recursive 4-copy expansion with 4 long blockers per level (Figure-4 motif)
      - allow scheduling variants: blockers placed 'before', 'after' or 'split' between copies
      - optionally add an extra copy on the first iteration to strengthen coupling
      - evaluate candidates by internal FirstFit simulation and omega sweep
      - normalize endpoints to a compact integer grid and reduce by gcd

    Arguments:
      iterations: hint for depth; we try a small depth sweep around it.

    Returns:
      intervals: list[(l,r)] of integer endpoints (open intervals) in presentation order.
    """
    # ---------- Utilities ----------

    def firstfit_colors(intervals):
        """
        Fast FirstFit simulation using per-color last endpoint tracking.
        Assumes intervals are given in arrival order.
        """
        last_end = []  # last_end[i] is the right endpoint of the last interval assigned to color i
        for l, r in intervals:
            placed = False
            # scan colors in order (FirstFit); typically number of colors is moderate
            for i in range(len(last_end)):
                if l >= last_end[i]:
                    last_end[i] = r
                    placed = True
                    break
            if not placed:
                last_end.append(r)
        return len(last_end)

    def clique_number(intervals):
        """
        Compute omega: maximum overlap (open intervals).
        For open intervals, at the same coordinate right endpoints should be processed before left endpoints.
        """
        events = []
        for l, r in intervals:
            if l < r:
                events.append((l, +1))
                events.append((r, -1))
        # tie-break: -1 processed before +1 at same coordinate
        events.sort(key=lambda e: (e[0], 0 if e[1] == -1 else 1))
        cur = best = 0
        for _, t in events:
            cur += t
            if cur > best:
                best = cur
        return best

    def normalize_and_shrink(intervals):
        """
        Map unique endpoints to small integers (even spacing), then divide by gcd to compress.
        Preserves ordering and open/closed overlaps.
        """
        if not intervals:
            return []
        pts = sorted(set(x for seg in intervals for x in seg))
        coord = {p: 2 * i for i, p in enumerate(pts)}  # even spacing
        mapped = [(coord[l], coord[r]) for (l, r) in intervals]
        # Shift so min >= 0 (already is), compute gcd of all endpoints to shrink
        vals = []
        for l, r in mapped:
            vals.append(abs(l))
            vals.append(abs(r))
        g = 0
        for v in vals:
            g = gcd(g, v)
        if g <= 1:
            return mapped
        return [(l // g, r // g) for (l, r) in mapped]

    # ---------- Construction building blocks ----------

    def make_copies(T, delta, lo, offsets, anchor='left', center=None):
        """
        Translate/scale template T into a union of copies positioned by offsets.
        anchor: 'left' or 'center' for interpreting offsets.
        """
        S = []
        if anchor == 'left':
            for start in offsets:
                offset = delta * start - lo
                for l, r in T:
                    S.append((l + offset, r + offset))
        else:  # center-based anchor
            assert center is not None
            for start in offsets:
                offset = delta * start - center
                for l, r in T:
                    S.append((l + offset, r + offset))
        return S

    def make_blockers(delta, anchor='left', center=None, template=None):
        """
        Create the four connecting long intervals scaled by delta.
        Template is a sequence of (a,b) factors (relative to delta).
        """
        if template is None:
            template = ((1, 5), (12, 16), (4, 9), (8, 13))
        S = []
        if anchor == 'left':
            for a, b in template:
                S.append((delta * a, delta * b))
        else:
            assert center is not None
            for a, b in template:
                S.append((delta * a - center, delta * b - center))
        return S

    def build_recursive(base_seed, k, offsets, blocker_template,
                        schedule='after', extra_first=False, translation_anchor='left', blocker_anchor='left'):
        """
        Build k-level recursive structure.
        schedule: 'after', 'before', 'split'
        extra_first: add a 5th copy on first level (helps couple colors across layers)
        translation_anchor / blocker_anchor: 'left' or 'center'
        """
        T = list(base_seed)
        for level in range(k):
            lo = min(l for l, r in T)
            hi = max(r for l, r in T)
            delta = hi - lo
            center = (lo + hi) / 2.0
            offs = offsets
            if extra_first and level == 0:
                # add an extra copy at offset 18 to increase pressure
                offs = tuple(list(offsets) + [18])

            # create copies and blockers with requested anchors
            copies_all = make_copies(T, delta, lo, offs,
                                     anchor=translation_anchor, center=center)
            blockers = make_blockers(delta, anchor=blocker_anchor, center=center, template=blocker_template)

            if schedule == 'after':
                S = copies_all + blockers
            elif schedule == 'before':
                S = blockers + copies_all
            else:  # split: put half the copies, then blockers, then remaining copies
                h = len(offs) // 2
                first = offs[:h]
                second = offs[h:]
                first_copies = make_copies(T, delta, lo, first, anchor=translation_anchor, center=center)
                second_copies = make_copies(T, delta, lo, second, anchor=translation_anchor, center=center)
                S = first_copies + blockers + second_copies
            T = S
        return T

    # ---------- Parameter sweep ----------

    # candidate parameter sets (compact to keep computations modest)
    offsets_options = [
        (2, 6, 10, 14),  # baseline
        (1, 5, 9, 13),
        (3, 7, 11, 15),
        (0, 4, 8, 12),
    ]
    blocker_templates = [
        ((1, 5), (12, 16), (4, 9), (8, 13)),  # baseline
        ((0, 4), (6, 10), (8, 12), (14, 18)), # shifted
        ((2, 6), (4, 8), (10, 14), (12, 16)), # tighter
    ]
    schedules = ['after', 'before', 'split']
    anchors = ['left', 'center']
    base_seeds = [
        [(0.0, 1.0)],
        [(0.0, 1.0), (2.0, 3.0)]
    ]
    # try depths around provided iterations
    depths = sorted(set([max(2, iterations - 1), iterations, min(iterations + 1, 6)]))
    # safety cap on instance size (approx): avoid huge explosion
    SIZE_CAP = 4000

    best = None  # tuple: (score, omega, cols, n, intervals)
    # enumerate modest grid with deterministic ordering
    candidates_tested = 0
    MAX_CANDIDATES = 200  # safety bound to avoid extreme loops

    for base in base_seeds:
        for k in depths:
            # quick size estimate: roughly (len(base) + 4) * 4^k
            est_size = int((len(base) + 4) * (4 ** k))
            if est_size > SIZE_CAP:
                continue
            for offsets in offsets_options:
                for btemp in blocker_templates:
                    for schedule in schedules:
                        for trans_anchor in anchors:
                            for block_anchor in anchors:
                                # limit total enumeration
                                candidates_tested += 1
                                if candidates_tested > MAX_CANDIDATES:
                                    break

                                T = build_recursive(
                                    base_seed=base,
                                    k=k,
                                    offsets=offsets,
                                    blocker_template=btemp,
                                    schedule=schedule,
                                    extra_first=True,  # try with extra_first to strengthen adversary
                                    translation_anchor=trans_anchor,
                                    blocker_anchor=block_anchor
                                )

                                # compute metrics on the raw (floating) construction
                                om = clique_number(T)
                                if om <= 0:
                                    continue
                                cols = firstfit_colors(T)
                                ratio = cols / om
                                n = len(T)
                                # tiny tie-breaker preference for smaller constructions
                                score = ratio - 1e-6 * (n / 10000.0)

                                cand = (score, om, cols, n, T)
                                if best is None:
                                    best = cand
                                else:
                                    if cand[0] > best[0] + 1e-12:
                                        best = cand
                                    elif abs(cand[0] - best[0]) <= 1e-12:
                                        # tie-break: fewer intervals, then more colors, then larger omega
                                        if cand[3] < best[3]:
                                            best = cand
                                        elif cand[3] == best[3]:
                                            if cand[2] > best[2]:
                                                best = cand
                                            elif cand[2] == best[2] and cand[1] > best[1]:
                                                best = cand
                            if candidates_tested > MAX_CANDIDATES:
                                break
                        if candidates_tested > MAX_CANDIDATES:
                            break
                    if candidates_tested > MAX_CANDIDATES:
                        break
                if candidates_tested > MAX_CANDIDATES:
                    break
            if candidates_tested > MAX_CANDIDATES:
                break
        if candidates_tested > MAX_CANDIDATES:
            break

    # fallback: baseline Figure-4 style expansion if we found nothing
    if best is None:
        T = [(0.0, 1.0)]
        for _ in range(4):
            lo = min(l for l, r in T)
            hi = max(r for l, r in T)
            delta = hi - lo
            S = []
            for start in (2, 6, 10, 14):
                offset = delta * start - lo
                for l, r in T:
                    S.append((l + offset, r + offset))
            S += [
                (delta * 1,  delta * 5),
                (delta * 12, delta * 16),
                (delta * 4,  delta * 9),
                (delta * 8,  delta * 13)
            ]
            T = S
        return normalize_and_shrink(T)

    # Normalize best candidate and return integer grid intervals
    normalized = normalize_and_shrink(best[4])
    return normalized

# EVOLVE-BLOCK-END