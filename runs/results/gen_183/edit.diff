--- a/original.py
+++ b/original.py
@@ -1,193 +1,284 @@
 # EVOLVE-BLOCK-START
 
+from math import gcd
+from functools import reduce
+
 def construct_intervals(iterations=4):
-  """
-  Build a sequence of open intervals that aims to maximize FirstFit/OPT.
-  Strategy:
-    - 4-copy recursive expansion + 4 blockers per level (Figure-4 style)
-    - Parameter sweep over offsets, blocker templates, translation anchors, and depth
-    - Evaluate each candidate via an internal FirstFit simulation and clique sweep
-    - Normalize endpoints to a compact integer grid before returning
-
-  Arguments:
-    iterations: optional hint; included in the depth sweep if in {3,4,5}
-
-  Returns:
-    intervals: list[(l,r)] of open intervals with integer endpoints
-  """
-
-  # ------------ helpers ------------
-  def overlaps(a, b):
-    (l1, r1), (l2, r2) = a, b
-    # open-interval overlap:
-    return max(l1, l2) < min(r1, r2)
-
-  def firstfit_colors(intervals):
     """
-    Simulate FirstFit on the given arrival order.
-    Colors are independent sets w.r.t. open-interval overlap.
+    Build a sequence of open intervals that aims to maximize FirstFit/OPT ratio.
+
+    Strategy (crossover):
+      - recursive 4-copy expansion with 4 long blockers per level (Figure-4 motif)
+      - allow scheduling variants: blockers placed 'before', 'after' or 'split' between copies
+      - optionally add an extra copy on the first iteration to strengthen coupling
+      - evaluate candidates by internal FirstFit simulation and omega sweep
+      - normalize endpoints to a compact integer grid and reduce by gcd
+
+    Arguments:
+      iterations: hint for depth; we try a small depth sweep around it.
+
+    Returns:
+      intervals: list[(l,r)] of integer endpoints (open intervals) in presentation order.
     """
-    colors = []  # list of color classes
-    for iv in intervals:
-      placed = False
-      for c in colors:
-        conflict = False
-        for u in c:
-          if overlaps(u, iv):
-            conflict = True
+    # ---------- Utilities ----------
+
+    def firstfit_colors(intervals):
+        """
+        Fast FirstFit simulation using per-color last endpoint tracking.
+        Assumes intervals are given in arrival order.
+        """
+        last_end = []  # last_end[i] is the right endpoint of the last interval assigned to color i
+        for l, r in intervals:
+            placed = False
+            # scan colors in order (FirstFit); typically number of colors is moderate
+            for i in range(len(last_end)):
+                if l >= last_end[i]:
+                    last_end[i] = r
+                    placed = True
+                    break
+            if not placed:
+                last_end.append(r)
+        return len(last_end)
+
+    def clique_number(intervals):
+        """
+        Compute omega: maximum overlap (open intervals).
+        For open intervals, at the same coordinate right endpoints should be processed before left endpoints.
+        """
+        events = []
+        for l, r in intervals:
+            if l < r:
+                events.append((l, +1))
+                events.append((r, -1))
+        # tie-break: -1 processed before +1 at same coordinate
+        events.sort(key=lambda e: (e[0], 0 if e[1] == -1 else 1))
+        cur = best = 0
+        for _, t in events:
+            cur += t
+            if cur > best:
+                best = cur
+        return best
+
+    def normalize_and_shrink(intervals):
+        """
+        Map unique endpoints to small integers (even spacing), then divide by gcd to compress.
+        Preserves ordering and open/closed overlaps.
+        """
+        if not intervals:
+            return []
+        pts = sorted(set(x for seg in intervals for x in seg))
+        coord = {p: 2 * i for i, p in enumerate(pts)}  # even spacing
+        mapped = [(coord[l], coord[r]) for (l, r) in intervals]
+        # Shift so min >= 0 (already is), compute gcd of all endpoints to shrink
+        vals = []
+        for l, r in mapped:
+            vals.append(abs(l))
+            vals.append(abs(r))
+        g = 0
+        for v in vals:
+            g = gcd(g, v)
+        if g <= 1:
+            return mapped
+        return [(l // g, r // g) for (l, r) in mapped]
+
+    # ---------- Construction building blocks ----------
+
+    def make_copies(T, delta, lo, offsets, anchor='left', center=None):
+        """
+        Translate/scale template T into a union of copies positioned by offsets.
+        anchor: 'left' or 'center' for interpreting offsets.
+        """
+        S = []
+        if anchor == 'left':
+            for start in offsets:
+                offset = delta * start - lo
+                for l, r in T:
+                    S.append((l + offset, r + offset))
+        else:  # center-based anchor
+            assert center is not None
+            for start in offsets:
+                offset = delta * start - center
+                for l, r in T:
+                    S.append((l + offset, r + offset))
+        return S
+
+    def make_blockers(delta, anchor='left', center=None, template=None):
+        """
+        Create the four connecting long intervals scaled by delta.
+        Template is a sequence of (a,b) factors (relative to delta).
+        """
+        if template is None:
+            template = ((1, 5), (12, 16), (4, 9), (8, 13))
+        S = []
+        if anchor == 'left':
+            for a, b in template:
+                S.append((delta * a, delta * b))
+        else:
+            assert center is not None
+            for a, b in template:
+                S.append((delta * a - center, delta * b - center))
+        return S
+
+    def build_recursive(base_seed, k, offsets, blocker_template,
+                        schedule='after', extra_first=False, translation_anchor='left', blocker_anchor='left'):
+        """
+        Build k-level recursive structure.
+        schedule: 'after', 'before', 'split'
+        extra_first: add a 5th copy on first level (helps couple colors across layers)
+        translation_anchor / blocker_anchor: 'left' or 'center'
+        """
+        T = list(base_seed)
+        for level in range(k):
+            lo = min(l for l, r in T)
+            hi = max(r for l, r in T)
+            delta = hi - lo
+            center = (lo + hi) / 2.0
+            offs = offsets
+            if extra_first and level == 0:
+                # add an extra copy at offset 18 to increase pressure
+                offs = tuple(list(offsets) + [18])
+
+            # create copies and blockers with requested anchors
+            copies_all = make_copies(T, delta, lo, offs,
+                                     anchor=translation_anchor, center=center)
+            blockers = make_blockers(delta, anchor=blocker_anchor, center=center, template=blocker_template)
+
+            if schedule == 'after':
+                S = copies_all + blockers
+            elif schedule == 'before':
+                S = blockers + copies_all
+            else:  # split: put half the copies, then blockers, then remaining copies
+                h = len(offs) // 2
+                first = offs[:h]
+                second = offs[h:]
+                first_copies = make_copies(T, delta, lo, first, anchor=translation_anchor, center=center)
+                second_copies = make_copies(T, delta, lo, second, anchor=translation_anchor, center=center)
+                S = first_copies + blockers + second_copies
+            T = S
+        return T
+
+    # ---------- Parameter sweep ----------
+
+    # candidate parameter sets (compact to keep computations modest)
+    offsets_options = [
+        (2, 6, 10, 14),  # baseline
+        (1, 5, 9, 13),
+        (3, 7, 11, 15),
+        (0, 4, 8, 12),
+    ]
+    blocker_templates = [
+        ((1, 5), (12, 16), (4, 9), (8, 13)),  # baseline
+        ((0, 4), (6, 10), (8, 12), (14, 18)), # shifted
+        ((2, 6), (4, 8), (10, 14), (12, 16)), # tighter
+    ]
+    schedules = ['after', 'before', 'split']
+    anchors = ['left', 'center']
+    base_seeds = [
+        [(0.0, 1.0)],
+        [(0.0, 1.0), (2.0, 3.0)]
+    ]
+    # try depths around provided iterations
+    depths = sorted(set([max(2, iterations - 1), iterations, min(iterations + 1, 6)]))
+    # safety cap on instance size (approx): avoid huge explosion
+    SIZE_CAP = 4000
+
+    best = None  # tuple: (score, omega, cols, n, intervals)
+    # enumerate modest grid with deterministic ordering
+    candidates_tested = 0
+    MAX_CANDIDATES = 200  # safety bound to avoid extreme loops
+
+    for base in base_seeds:
+        for k in depths:
+            # quick size estimate: roughly (len(base) + 4) * 4^k
+            est_size = int((len(base) + 4) * (4 ** k))
+            if est_size > SIZE_CAP:
+                continue
+            for offsets in offsets_options:
+                for btemp in blocker_templates:
+                    for schedule in schedules:
+                        for trans_anchor in anchors:
+                            for block_anchor in anchors:
+                                # limit total enumeration
+                                candidates_tested += 1
+                                if candidates_tested > MAX_CANDIDATES:
+                                    break
+
+                                T = build_recursive(
+                                    base_seed=base,
+                                    k=k,
+                                    offsets=offsets,
+                                    blocker_template=btemp,
+                                    schedule=schedule,
+                                    extra_first=True,  # try with extra_first to strengthen adversary
+                                    translation_anchor=trans_anchor,
+                                    blocker_anchor=block_anchor
+                                )
+
+                                # compute metrics on the raw (floating) construction
+                                om = clique_number(T)
+                                if om <= 0:
+                                    continue
+                                cols = firstfit_colors(T)
+                                ratio = cols / om
+                                n = len(T)
+                                # tiny tie-breaker preference for smaller constructions
+                                score = ratio - 1e-6 * (n / 10000.0)
+
+                                cand = (score, om, cols, n, T)
+                                if best is None:
+                                    best = cand
+                                else:
+                                    if cand[0] > best[0] + 1e-12:
+                                        best = cand
+                                    elif abs(cand[0] - best[0]) <= 1e-12:
+                                        # tie-break: fewer intervals, then more colors, then larger omega
+                                        if cand[3] < best[3]:
+                                            best = cand
+                                        elif cand[3] == best[3]:
+                                            if cand[2] > best[2]:
+                                                best = cand
+                                            elif cand[2] == best[2] and cand[1] > best[1]:
+                                                best = cand
+                            if candidates_tested > MAX_CANDIDATES:
+                                break
+                        if candidates_tested > MAX_CANDIDATES:
+                            break
+                    if candidates_tested > MAX_CANDIDATES:
+                        break
+                if candidates_tested > MAX_CANDIDATES:
+                    break
+            if candidates_tested > MAX_CANDIDATES:
+                break
+        if candidates_tested > MAX_CANDIDATES:
             break
-        if not conflict:
-          c.append(iv)
-          placed = True
-          break
-      if not placed:
-        colors.append([iv])
-    return len(colors)
-
-  def clique_number(intervals):
-    """
-    Max number of intervals covering a single point (omega) using sweep.
-    For open intervals, at equal coordinates process right(-1) before left(+1).
-    """
-    events = []  # (x, type) type=-1 for right, +1 for left
-    for (l, r) in intervals:
-      if l < r:
-        events.append((l, +1))
-        events.append((r, -1))
-    events.sort(key=lambda e: (e[0], 0 if e[1] == -1 else 1))
-    cur = best = 0
-    for _, t in events:
-      cur += t
-      if cur > best:
-        best = cur
-    return best
-
-  def normalize_grid(intervals):
-    """
-    Map each unique endpoint to an increasing integer grid (even spacing).
-    Preserves open-interval overlap and arrival order.
-    """
-    if not intervals:
-      return []
-    pts = sorted(set([x for seg in intervals for x in seg]))
-    coord = {e: 2*i for i, e in enumerate(pts)}
-    return [(coord[l], coord[r]) for (l, r) in intervals]
-
-  def build_pattern(base_seed, k, offsets, blockers, translation='left', blocker_anchor='left'):
-    """
-    Recursively expand base_seed k times with 4 copies and 4 blockers.
-    translation in {'left','center'} controls copy offsets.
-    blocker_anchor in {'left','center'} controls blocker placement.
-    """
-    T = list(base_seed)
-    for _ in range(k):
-      lo = min(l for l, r in T)
-      hi = max(r for l, r in T)
-      delta = hi - lo
-      center = (lo + hi) / 2.0
-
-      S = []
-      for start in offsets:
-        if translation == 'left':
-          off = delta * start - lo
-        else:  # center-based
-          off = delta * start - center
-        for (l, r) in T:
-          S.append((l + off, r + off))
-
-      for (a, b) in blockers:
-        if blocker_anchor == 'left':
-          S.append((delta * a, delta * b))
-        else:
-          S.append((delta * a - center, delta * b - center))
-
-      T = S
-    return T
-
-  def evaluate(intervals):
-    """Return (score, omega, colors, n)."""
-    if not intervals:
-      return (-1.0, 0, 0, 0)
-    om = clique_number(intervals)
-    if om <= 0:
-      return (-1.0, 0, 0, len(intervals))
-    cols = firstfit_colors(intervals)
-    # Slight penalty for larger instances to break ties
-    score = cols / om - 1e-6 * (len(intervals) / 10000.0)
-    return (score, om, cols, len(intervals))
-
-  # ------------ parameter sweep ------------
-  offsets_set = [
-    (2, 6, 10, 14),
-    (1, 5, 9, 13),
-    (3, 7, 11, 15),
-    (0, 4, 8, 12),
-  ]
-  blockers_templates = [
-    # A: baseline as in Figure 4
-    ((1, 5), (12, 16), (4, 9), (8, 13)),
-    # B: variant geometry
-    ((0, 4), (6, 10), (8, 12), (14, 18)),
-    # C: tighter mid coupling
-    ((2, 6), (4, 8), (10, 14), (12, 16)),
-  ]
-  translations = ['left', 'center']
-  blocker_anchors = ['left', 'center']
-  depths = [d for d in {3, 4, 5, iterations} if d in (3, 4, 5)]
-  base_seeds = [
-    [(0.0, 1.0)],
-    [(0.0, 1.0), (2.0, 3.0)],
-  ]
-
-  best = None  # (score, om, cols, n, intervals)
-
-  for base in base_seeds:
-    for k in depths:
-      # avoid overly large instances (approx size ~ 4^k * |base| + O(4^k))
-      if (4 ** k) * (len(base) + 2) > 3000:
-        continue
-      for offsets in offsets_set:
-        for blockers in blockers_templates:
-          for tr in translations:
-            for ba in blocker_anchors:
-              T = build_pattern(base_seed=base, k=k, offsets=offsets,
-                                blockers=blockers, translation=tr, blocker_anchor=ba)
-              score, om, cols, n = evaluate(T)
-              cand = (score, om, cols, n, T)
-              if best is None:
-                best = cand
-              else:
-                if cand[0] > best[0] + 1e-9:
-                  best = cand
-                elif abs(cand[0] - best[0]) <= 1e-9:
-                  # tie-break by fewer intervals, then more colors
-                  if cand[3] < best[3] or (cand[3] == best[3] and cand[2] > best[2]):
-                    best = cand
-
-  # Fallback to the known-safe baseline if sweep failed (should not happen)
-  if best is None:
-    T = [(0.0, 1.0)]
-    for _ in range(4):
-      lo = min(l for l, r in T)
-      hi = max(r for l, r in T)
-      delta = hi - lo
-      S = []
-      for start in (2, 6, 10, 14):
-        S += [(delta * start + l - lo, delta * start + r - lo) for l, r in T]
-      S += [
-        (delta * 1,  delta * 5),
-        (delta * 12, delta * 16),
-        (delta * 4,  delta * 9),
-        (delta * 8,  delta * 13)
-      ]
-      T = S
-    return normalize_grid(T)
-
-  # Normalize endpoints to compact integer grid and return
-  return normalize_grid(best[4])
+
+    # fallback: baseline Figure-4 style expansion if we found nothing
+    if best is None:
+        T = [(0.0, 1.0)]
+        for _ in range(4):
+            lo = min(l for l, r in T)
+            hi = max(r for l, r in T)
+            delta = hi - lo
+            S = []
+            for start in (2, 6, 10, 14):
+                offset = delta * start - lo
+                for l, r in T:
+                    S.append((l + offset, r + offset))
+            S += [
+                (delta * 1,  delta * 5),
+                (delta * 12, delta * 16),
+                (delta * 4,  delta * 9),
+                (delta * 8,  delta * 13)
+            ]
+            T = S
+        return normalize_and_shrink(T)
+
+    # Normalize best candidate and return integer grid intervals
+    normalized = normalize_and_shrink(best[4])
+    return normalized
 
 # EVOLVE-BLOCK-END
 
 def run_experiment(**kwargs):
   """Main called by evaluator"""
   return construct_intervals()