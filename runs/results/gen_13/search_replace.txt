<NAME>enhanced_tiling_with_pluggable_opts</NAME>

<DESCRIPTION>
Introduces a pluggable tiling mechanism into the adversarial interval construction by:
- adding translation and blocker_anchor parameters to construct_intervals (defaulting to the original behavior for compatibility).
- implementing center-based tiling option and center-based anchoring for blockers, controlled via the new parameters.
- preserving the existing recursive expansion logic and the four-copy/four-blocker structure, while making the configuration extensible for future experiments.
- maintaining a safe default to ensure backward compatibility with existing evaluation pipelines.
This targeted change enables exploring a larger design space without rewriting the core framework.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
def construct_intervals(iterations=4):
  """
  Construct a sequence of intervals of real line,
  in the order in which they are presented to FirstFit,
  so that maximizes the number of colors used by FirstFit
  divided by the maximum number of intervals that cover a single point

  The implementation uses the construction from
  Figure 4 in https://arxiv.org/abs/1506.00192 and increases
  the number of recursive expansions to produce a stronger adversary.

  Arguments:
    iterations: number of recursive expansion steps (default 4)

  Returns:
    intervals: list of tuples, each tuple (l, r) represents an open interval from l to r
  """

  T = [(0, 1)]
  # Each iteration replaces T by four translated/scaled copies plus four
  # longer intervals that connect the copies in the manner of Figure 4.
  for _ in range(iterations):
    lo = min(l for l, r in T)
    hi = max(r for l, r in T)
    delta = hi - lo
    S = []
    # Place four scaled copies at offsets chosen to stagger intervals
    for start in (2, 6, 10, 14):
      S += [(delta * start + l - lo, delta * start + r - lo) for l, r in T]
    # Add the four connecting long intervals as in the original figure
    S += [
      (delta * 1, delta * 5),
      (delta * 12, delta * 16),
      (delta * 4, delta * 9),
      (delta * 8, delta * 13)
    ]
    T = S
  return T

  # return [  # Figure 3, OPT=2, FF=4
  #   (2,3),
  #   (6,7),
  #   (10,11),
  #   (14,15),
  #   (1,5),
  #   (12,16),
  #   (4,9),
  #   (8,13),
  # ]
=======
def construct_intervals(iterations=4, translation='left', blocker_anchor='left'):
  """
  Construct a sequence of intervals of real line,
  in the order in which they are presented to FirstFit,
  so that maximizes the number of colors used by FirstFit
  divided by the maximum number of intervals that cover a single point.

  Enhanced to support pluggable tiling:
  - translation: 'left' (existing behavior) or 'center' (center-based tiling)
  - blocker_anchor: 'left' (absolute) or 'center' (center-based alignment for blockers)

  The implementation uses the construction from
  Figure 4 in https://arxiv.org/abs/1506.00192 and increases
  the number of recursive expansions to produce a stronger adversary.

  Arguments:
    iterations: number of recursive expansion steps (default 4)
    translation: tiling strategy for copies ('left' or 'center')
    blocker_anchor: how blockers are anchored ('left' or 'center')

  Returns:
    intervals: list of tuples, each tuple (l, r) represents an open interval from l to r
  """

  T = [(0, 1)]
  # Each iteration replaces T by four translated/scaled copies plus four
  # longer intervals that connect the copies in the manner of Figure 4.
  for _ in range(iterations):
    lo = min(l for l, r in T)
    hi = max(r for l, r in T)
    delta = hi - lo
    center = (lo + hi) / 2.0

    S = []
    # Place four scaled copies at offsets chosen to stagger intervals
    for start in (2, 6, 10, 14):
      if translation == 'left':
        offset = delta * start - lo
      else:  # center-based tiling
        offset = delta * start - center
      S += [(l + offset, r + offset) for l, r in T]

    # Add the four connecting long intervals as in the original figure
    if blocker_anchor == 'left':
      S += [
        (delta * 1, delta * 5),
        (delta * 12, delta * 16),
        (delta * 4, delta * 9),
        (delta * 8, delta * 13)
      ]
    else:  # center-based blockers
      S += [
        (delta * 1 - center, delta * 5 - center),
        (delta * 12 - center, delta * 16 - center),
        (delta * 4 - center, delta * 9 - center),
        (delta * 8 - center, delta * 13 - center)
      ]
    T = S
  return T

  # return [  # Figure 3, OPT=2, FF=4
  #   (2,3),
  #   (6,7),
  #   (10,11),
  #   (14,15),
  #   (1,5),
  #   (12,16),
  #   (4,9),
  #   (8,13),
  # ]
>>>>>>> REPLACE
</DIFF>