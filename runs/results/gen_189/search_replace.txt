<NAME>
interleaved_perturbed_backbone
</NAME>

<DESCRIPTION>
Introduce a deterministic cycle-and-perturbation on the 4-copy backbone and an interleaved blocker schedule to increase arrival-order coupling (which tends to force FirstFit to use more colors). Concretely:
- Cycle among four offset patterns (A=(2,6,10,14), B=(1,5,9,13), C=(3,7,11,15), D=(0,4,8,12)) instead of just two, so deeper levels use different tilings.
- Apply a tiny deterministic perturbation to each copy position (depends on level and start) to break perfect symmetry and create extra overlaps across levels.
- Use an "interleaved" insertion of long blockers on alternating levels (and reverse the copy order on those levels) so blockers appear earlier relative to some copies, increasing the early-color pollution and making later intervals require larger color indices.
- Deduplicate identical intervals (preserve arrival order) to keep the instance compact.
- Preserve normalization to an even integer grid.

These changes are conservative and deterministic, and aim to raise FirstFit while keeping omega controlled (they keep the canonical blocker template). The implementation is targeted and self-contained (only replaces the existing construct_intervals block).
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
def construct_intervals(iterations=4, extra_first=True):
  """
  Construct a sequence of intervals of real line,
  in the order in which they are presented to FirstFit,
  so that it maximizes the number of colors used by FirstFit
  divided by the maximum number of intervals that cover a single point

  This variant:
    - alternates copy offsets between two staggerings across levels
      (canonical and shifted) to increase coupling between levels;
    - optionally adds an extra fifth copy on the first iteration to
      pollute early small colors (extra_first=True);
    - normalizes endpoints to a compact integer grid before returning.

  Arguments:
    iterations: number of recursive expansion steps (default 4)
    extra_first: whether to add a fifth copy at the first iteration (default True)

  Returns:
    intervals: list of tuples, each tuple (l, r) represents an open interval from l to r
  """

  # two offset patterns to alternate between levels (helps arrival-order engineering)
  offsets_patterns = [
    (2, 6, 10, 14),   # canonical
    (1, 5, 9, 13)     # shifted (interleaved) alternative
  ]

  T = [(0, 1)]
  # Each iteration replaces T by multiple translated/scaled copies plus connectors.
  for lvl in range(iterations):
    lo = min(l for l, r in T)
    hi = max(r for l, r in T)
    delta = hi - lo
    S = []

    # pick offsets for this level (alternate patterns)
    base_offsets = offsets_patterns[lvl % len(offsets_patterns)]
    if extra_first and lvl == 0:
      # extend first-level offsets with an extra copy to increase early coupling
      offs = tuple(list(base_offsets) + [18])
    else:
      offs = base_offsets

    # Place translated copies (left-anchored)
    for start in offs:
      S += [(delta * start + l - lo, delta * start + r - lo) for l, r in T]

    # Add the four connecting long intervals as in the original figure
    S += [
      (delta * 1, delta * 5),
      (delta * 12, delta * 16),
      (delta * 4, delta * 9),
      (delta * 8, delta * 13)
    ]
    T = S

  # Normalize endpoints to a compact integer grid while preserving order.
  # Map each unique endpoint to an increasing even integer (to ensure
  # positive lengths and avoid degeneracy).
  endpoints = sorted(set([x for seg in T for x in seg]))
  coord = {}
  cur = 0
  for e in endpoints:
    coord[e] = cur
    cur += 2
  normalized = [(coord[l], coord[r]) for (l, r) in T]

  return normalized

  # return [  # Figure 3, OPT=2, FF=4
  #   (2,3),
  #   (6,7),
  #   (10,11),
  #   (14,15),
  #   (1,5),
  #   (12,16),
  #   (4,9),
  #   (8,13),
  # ]
=======
def construct_intervals(iterations=4, extra_first=True):
  """
  Construct a sequence of intervals for the FirstFit adversary.

  Improvements over the canonical variant:
    - cycle among four offset patterns (A,B,C,D) instead of only two,
      creating more varied tilings across levels;
    - apply a tiny deterministic perturbation to each copy's placement
      (depends on level and start) to break perfect symmetry and induce
      additional cross-level overlaps;
    - on alternating levels insert the four long blockers interleaved
      among the copies (and reverse the copy order on those levels)
      so that blockers appear earlier relative to some copies and
      pollute small colors more effectively;
    - deduplicate identical intervals (preserve arrival order) to keep
      the instance compact;
    - finally normalize endpoints to a compact even-integer grid.

  These are conservative, deterministic changes intended to increase
  the number of colors FirstFit uses while keeping omega controlled.
  """

  # four cyclic offset patterns (A,B,C,D)
  offsets_patterns = [
    (2, 6, 10, 14),   # A: canonical
    (1, 5, 9, 13),    # B: shifted
    (3, 7, 11, 15),   # C: shifted-right
    (0, 4, 8, 12)     # D: leftmost
  ]

  # canonical blockers (kept same geometric multipliers)
  blockers_template = [(1, 5), (12, 16), (4, 9), (8, 13)]

  # start with a tiny seed to keep clique small
  T = [(0.0, 1.0)]

  for lvl in range(iterations):
    lo = min(l for l, r in T)
    hi = max(r for l, r in T)
    delta = hi - lo
    S = []

    # choose base offsets from the 4-pattern cycle
    base_offsets = offsets_patterns[lvl % len(offsets_patterns)]
    if extra_first and lvl == 0:
      offs = tuple(list(base_offsets) + [18])  # small extra coupling on first level
    else:
      offs = base_offsets

    # decide whether to interleave blockers on this level (alternate levels)
    interleave = (lvl % 2 == 1)
    # when interleaving, also reverse copy order to vary arrival
    reverse_order = interleave

    ordered_offs = list(offs)
    if reverse_order:
      ordered_offs = list(reversed(ordered_offs))

    # small deterministic perturbation generator (range â‰ˆ [-0.12, +0.12])
    def perturb_for(start):
      # integerize start to keep perturb deterministic and small
      key = int(start)
      v = ((lvl * 3 + key) % 5) - 2  # in {-2,-1,0,1,2}
      return v * 0.06

    # Build S by adding copies per start and optionally interleaving a blocker
    for idx, start in enumerate(ordered_offs):
      p = perturb_for(start)
      offset = delta * (start + p) - lo
      # append translated copy of entire previous level T for this start
      for (l, r) in T:
        S.append((offset + l, offset + r))
      # interleave the corresponding blocker (if any) to affect arrival order
      if interleave and idx < len(blockers_template):
        a, b = blockers_template[idx]
        S.append((delta * a, delta * b))

    # if not interleaving, append blockers after all copies (canonical order)
    if not interleave:
      for (a, b) in blockers_template:
        S.append((delta * a, delta * b))

    T = S

  # deduplicate identical intervals while preserving arrival order (keeps instance compact)
  seen = set()
  T_dedup = []
  for (l, r) in T:
    key = (float(l), float(r))
    if key not in seen:
      seen.add(key)
      T_dedup.append((l, r))
  T = T_dedup

  # Normalize endpoints to a compact integer grid while preserving order.
  # Map each unique endpoint to an increasing even integer (to ensure
  # positive lengths and avoid degeneracy).
  endpoints = sorted(set([x for seg in T for x in seg]))
  coord = {}
  cur = 0
  for e in endpoints:
    coord[e] = cur
    cur += 2
  normalized = [(coord[l], coord[r]) for (l, r) in T]

  return normalized
>>>>>>> REPLACE
</DIFF>