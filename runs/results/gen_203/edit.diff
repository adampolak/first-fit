--- a/original.py
+++ b/original.py
@@ -1,151 +1,162 @@
 # EVOLVE-BLOCK-START
 
 def _normalize_grid(intervals):
   """
   Normalize endpoints to a compact integer grid while preserving order.
   Each unique endpoint is mapped to an increasing even integer.
   Returns a new list of (l, r) with integer coordinates.
   """
   endpoints = sorted(set([x for seg in intervals for x in seg]))
   coord = {}
   cur = 0
   for e in endpoints:
     coord[e] = cur
     cur += 2  # spacing by 2 to keep even gaps
 
   return [(coord[l], coord[r]) for (l, r) in intervals]
 
 
 def construct_intervals(iterations=4, normalize=True):
   """
   Build a sequence of open intervals that aims to maximize FirstFit/omega
   using a small parameter sweep around the canonical 4-copy/4-blocker recursion.
   The final output is normalized to a compact integer grid.
   """
   # Local helpers to evaluate candidates on raw coordinates (open intervals)
   def _ff_count(intervals):
     last_end = []
     for (l, r) in intervals:
       placed = False
       for i, le in enumerate(last_end):
         if l >= le:
           last_end[i] = r
           placed = True
           break
       if not placed:
         last_end.append(r)
     return len(last_end)
 
   def _omega_open(intervals):
     events = []
     for (l, r) in intervals:
       if l < r:
         events.append((l, +1))
         events.append((r, -1))
     # right (-1) before left (+1) on ties (open intervals)
     events.sort(key=lambda e: (e[0], 0 if e[1] == -1 else 1))
     cur = best = 0
     for _, t in events:
       cur += t
       if cur > best:
         best = cur
     return best
 
   # Parameterized builder
-  def _build(depth, starts, blockers, schedule='after', translation='left'):
+  def _build(depth, starts, blockers, schedule='after', translation='left', extra_first=True):
+    """
+    Recursive expansion with an optional extra firstâ€level copy to enhance coupling.
+    extra_first=True appends an additional copy at offset max(starts)+4 on level 0.
+    """
     T = [(0.0, 1.0)]
-    for _ in range(depth):
+    for lvl in range(depth):
       lo = min(l for l, r in T)
       hi = max(r for l, r in T)
       delta = hi - lo
       center = (lo + hi) / 2.0
+      # compute offsets, injecting extra copy at level 0
+      if extra_first and lvl == 0:
+        offs = tuple(list(starts) + [max(starts) + 4])
+      else:
+        offs = starts
 
       def place_copies(from_T, offs):
         U = []
         for start in offs:
           offset = delta * start - (lo if translation == 'left' else center)
           for (l, r) in from_T:
             U.append((l + offset, r + offset))
         return U
 
       # scale blockers according to anchor
       if translation == 'left':
         blk = [(delta * a, delta * b) for (a, b) in blockers]
       else:
         blk = [(delta * a - center, delta * b - center) for (a, b) in blockers]
 
+      # place copies and blockers using computed offsets
       if schedule == 'before':
-        S = list(blk) + place_copies(T, starts)
+        S = list(blk) + place_copies(T, offs)
       elif schedule == 'split':
-        h = len(starts) // 2
-        S = place_copies(T, starts[:h]) + list(blk) + place_copies(T, starts[h:])
+        h = len(offs) // 2
+        S = place_copies(T, offs[:h]) + list(blk) + place_copies(T, offs[h:])
       else:  # 'after'
-        S = place_copies(T, starts) + list(blk)
+        S = place_copies(T, offs) + list(blk)
       T = S
     return T
 
   # Sweep a modest space of blueprints
   depths = sorted(set([max(2, iterations - 1), max(2, iterations), min(5, iterations + 1)]))
   start_sets = [
     (2, 6, 10, 14),  # canonical
     (1, 5, 9, 13),
     (3, 7, 11, 15),
     (0, 4, 8, 12),
+    (1.5, 5.5, 9.5, 13.5),  # half-step stagger
   ]
   blocker_templates = [
     [(1, 5), (12, 16), (4, 9), (8, 13)],   # canonical
     [(1, 5), (11, 15), (4, 9), (8, 13)],   # slight shift
     [(2, 6), (12, 16), (4, 9), (8, 13)],   # shift first
   ]
   schedules = ['after', 'before', 'split']
   translations = ['left', 'center']
 
   best_T = None
   best_ratio = -1.0
   best_n = None
   best_cols = 0
   best_om = 0
 
   for d in depths:
     for starts in start_sets:
       for blockers in blocker_templates:
         for sch in schedules:
           for tr in translations:
             T = _build(d, starts, blockers, schedule=sch, translation=tr)
             n = len(T)
             # guard against explosion (keep search modest)
             if n > 2000:
               continue
             om = _omega_open(T)
             if om <= 0:
               continue
             cols = _ff_count(T)
             ratio = cols / om
             better = False
             if ratio > best_ratio + 1e-12:
               better = True
             elif abs(ratio - best_ratio) <= 1e-12:
               if best_n is None or n < best_n:
                 better = True
               elif n == best_n and cols > best_cols:
                 better = True
             if better:
               best_ratio = ratio
               best_T = T
               best_n = n
               best_cols = cols
               best_om = om
 
   # Fallback to canonical if search didn't produce anything
   if best_T is None:
     T = _build(max(2, iterations), (2, 6, 10, 14), [(1, 5), (12, 16), (4, 9), (8, 13)], schedule='after', translation='left')
   else:
     T = best_T
 
   return _normalize_grid(T) if normalize else T
 
 # EVOLVE-BLOCK-END
 
 def run_experiment(**kwargs):
   """Main called by evaluator"""
   return construct_intervals()