<NAME>builder_extra_first_coupling</NAME>
<DESCRIPTION>
Extend the recursive builder to optionally include an extra first‐level copy by default, increasing layer coupling and boosting the FirstFit color usage. Change the builder to use an iteration index, compute a modified offset list `offs` (including the extra copy at `max(starts)+4` on level 0), and enable this via a default `extra_first=True` parameter. Adjust all calls to use `offs` instead of raw `starts` so the extra copy is applied seamlessly.
</DESCRIPTION>
<DIFF>
<<<<<<< SEARCH
  # Parameterized builder
  def _build(depth, starts, blockers, schedule='after', translation='left'):
    T = [(0.0, 1.0)]
    for _ in range(depth):
      lo = min(l for l, r in T)
      hi = max(r for l, r in T)
      delta = hi - lo
      center = (lo + hi) / 2.0

      def place_copies(from_T, offs):
        U = []
        for start in offs:
          offset = delta * start - (lo if translation == 'left' else center)
          for (l, r) in from_T:
            U.append((l + offset, r + offset))
        return U

      # scale blockers according to anchor
      if translation == 'left':
        blk = [(delta * a, delta * b) for (a, b) in blockers]
      else:
        blk = [(delta * a - center, delta * b - center) for (a, b) in blockers]

      if schedule == 'before':
        S = list(blk) + place_copies(T, starts)
      elif schedule == 'split':
        h = len(starts) // 2
        S = place_copies(T, starts[:h]) + list(blk) + place_copies(T, starts[h:])
      else:  # 'after'
        S = place_copies(T, starts) + list(blk)
      T = S
    return T
=======
  # Parameterized builder
  def _build(depth, starts, blockers, schedule='after', translation='left', extra_first=True):
    """
    Recursive expansion with an optional extra first‐level copy to enhance coupling.
    extra_first=True appends an additional copy at offset max(starts)+4 on level 0.
    """
    T = [(0.0, 1.0)]
    for lvl in range(depth):
      lo = min(l for l, r in T)
      hi = max(r for l, r in T)
      delta = hi - lo
      center = (lo + hi) / 2.0
      # compute offsets, injecting extra copy at level 0
      if extra_first and lvl == 0:
        offs = tuple(list(starts) + [max(starts) + 4])
      else:
        offs = starts

      def place_copies(from_T, offs):
        U = []
        for start in offs:
          offset = delta * start - (lo if translation == 'left' else center)
          for (l, r) in from_T:
            U.append((l + offset, r + offset))
        return U

      # scale blockers according to anchor
      if translation == 'left':
        blk = [(delta * a, delta * b) for (a, b) in blockers]
      else:
        blk = [(delta * a - center, delta * b - center) for (a, b) in blockers]

      # place copies and blockers using computed offsets
      if schedule == 'before':
        S = list(blk) + place_copies(T, offs)
      elif schedule == 'split':
        h = len(offs) // 2
        S = place_copies(T, offs[:h]) + list(blk) + place_copies(T, offs[h:])
      else:  # 'after'
        S = place_copies(T, offs) + list(blk)
      T = S
    return T
>>>>>>> REPLACE
</DIFF>

<NAME>add_half_step_stagger</NAME>
<DESCRIPTION>
Augment the set of starting offsets with a half‐step stagger pattern `(1.5, 5.5, 9.5, 13.5)`. This can increase cross‐copy overlaps and potentially force FirstFit to use more colors without raising the clique size.
</DESCRIPTION>
<DIFF>
<<<<<<< SEARCH
  start_sets = [
    (2, 6, 10, 14),  # canonical
    (1, 5, 9, 13),
    (3, 7, 11, 15),
    (0, 4, 8, 12),
  ]
=======
  start_sets = [
    (2, 6, 10, 14),  # canonical
    (1, 5, 9, 13),
    (3, 7, 11, 15),
    (0, 4, 8, 12),
    (1.5, 5.5, 9.5, 13.5),  # half-step stagger
  ]
>>>>>>> REPLACE
</DIFF>