--- a/original.py
+++ b/original.py
@@ -1,163 +1,219 @@
 # EVOLVE-BLOCK-START
 
 def construct_intervals(iterations=4):
   """
   Construct a sequence of intervals of real line to maximize FirstFit/omega.
-  We explore small variations inspired by adversarial arrival-order engineering:
-  - schedule of blockers vs copies at each level (before/after/split)
-  - optional extra copy at the first iteration to couple layers
-  We evaluate candidates via an in-block FirstFit and omega computation, and return the best.
+  Enhancements:
+  - cycle offset patterns across levels (canonical vs shifted)
+  - zip interleaving of copies vs contiguous blocks
+  - optional reversal of every other copy
+  - optional “cap” blockers to couple towers
+  - schedule of blockers vs copies (before/after/split)
   """
 
   # --- Helper routines (kept lightweight and deterministic) ---
 
   def firstfit_colors(intervals):
     """Simulate FirstFit using per-color last end-point tracking."""
     last_end = []
     for (l, r) in intervals:
       placed = False
       for i, le in enumerate(last_end):
         if l >= le:
           last_end[i] = r
           placed = True
           break
       if not placed:
         last_end.append(r)
     return len(last_end)
 
   def clique_number(intervals):
     """Sweep for open intervals; process right endpoints before left at ties."""
     events = []
     for (l, r) in intervals:
       if l < r:
         events.append((l, +1))
         events.append((r, -1))
     events.sort(key=lambda e: (e[0], 0 if e[1] == -1 else 1))
     cur = best = 0
     for _, t in events:
       cur += t
       if cur > best:
         best = cur
     return best
 
-  def build_candidate(k, schedule='after', extra_first=False):
+  def _compose_copies(copy_lists, interleave):
+    """Compose per-copy lists either contiguously ('block') or round-robin ('zip')."""
+    if interleave == 'zip' and copy_lists:
+      m = len(copy_lists[0])
+      out = []
+      for j in range(m):
+        for lst in copy_lists:
+          out.append(lst[j])
+      return out
+    # default: concatenate
+    out = []
+    for lst in copy_lists:
+      out.extend(lst)
+    return out
+
+  def build_candidate(
+      k,
+      schedule='after',
+      extra_first=False,
+      offsets_seq=((2, 6, 10, 14),),
+      blockers_template=((1, 5), (12, 16), (4, 9), (8, 13)),
+      interleave='block',
+      reverse_alt=False):
     """
     Build k-level recursive pattern using four scaled copies per level,
-    with four long connectors ("blockers"), and schedule controlling
+    with long connectors ("blockers"), and schedule controlling
     the arrival order within each level.
-    schedule in {'after','before','split'}.
+    - offsets_seq: tuple/list of offset-tuples cycled over levels
+    - blockers_template: tuple of (a,b) scaled by delta each level
+    - interleave: 'block' or 'zip'
+    - reverse_alt: reverse every other copy's internal order
     """
     T = [(0.0, 1.0)]
     for i in range(k):
       lo = min(l for l, r in T)
       hi = max(r for l, r in T)
       delta = hi - lo
 
-      # Offsets for this level; optionally add a fifth copy on the first iteration
-      offs = (2, 6, 10, 14, 18) if (extra_first and i == 0) else (2, 6, 10, 14)
-
-      # Prepare copies
-      def make_copies(from_T, offsets):
-        S = []
-        for start in offsets:
-          offset = delta * start - lo  # left-anchored translation
-          for (l, r) in from_T:
-            S.append((l + offset, r + offset))
-        return S
-
-      # Blockers as in Figure 4
-      blockers = [
-        (delta * 1,  delta * 5),
-        (delta * 12, delta * 16),
-        (delta * 4,  delta * 9),
-        (delta * 8,  delta * 13),
-      ]
-
-      if schedule == 'after':
-        S = make_copies(T, offs) + blockers
-      elif schedule == 'before':
-        S = list(blockers) + make_copies(T, offs)
-      else:  # 'split': half the copies, then blockers, then remaining copies
-        h = len(offs) // 2
-        first = offs[:h]
-        second = offs[h:]
-        S = make_copies(T, first) + list(blockers) + make_copies(T, second)
+      # Offsets for this level (cycled)
+      offs_base = offsets_seq[i % len(offsets_seq)]
+      offs = tuple(list(offs_base) + [max(offs_base) + 4]) if (extra_first and i == 0) else offs_base
+
+      # Prepare per-copy lists (optionally reversed for alternating copies)
+      copy_lists = []
+      for idx, start in enumerate(offs):
+        offset = delta * start - lo  # left-anchored translation
+        seq = T if not (reverse_alt and (idx % 2 == 1)) else list(reversed(T))
+        copy_lists.append([(l + offset, r + offset) for (l, r) in seq])
+
+      S_copies = _compose_copies(copy_lists, interleave)
+
+      # Blockers scaled by delta
+      S_blockers = [(delta * a, delta * b) for (a, b) in blockers_template]
+
+      # Compose level by schedule
+      if schedule == 'before':
+        S = list(S_blockers) + S_copies
+      elif schedule == 'split':
+        h = max(1, len(copy_lists) // 2)
+        first_half = _compose_copies(copy_lists[:h], interleave)
+        second_half = _compose_copies(copy_lists[h:], interleave)
+        S = first_half + list(S_blockers) + second_half
+      else:
+        S = S_copies + list(S_blockers)
 
       T = S
     return T
 
   # --- Enumerate a modest set of candidates and select the best by ratio ---
-  configs = []
+
   depths = [max(2, iterations - 1), iterations]  # try one less and the given
   schedules = ['after', 'before', 'split']
   extras = [False, True]
+  interleaves = ['block', 'zip']
+  reverse_flags = [False, True]
+
+  # Offset cycles
+  canonical = (2, 6, 10, 14)
+  alt_a = (1, 5, 9, 13)
+  alt_b = (3, 7, 11, 15)
+  offsets_cycles = [
+    (canonical,),
+    (canonical, alt_a),
+    (canonical, alt_b),
+  ]
+
+  # Blocker templates: base 4 and a 6-blocker variant with caps
+  base4 = ((1, 5), (12, 16), (4, 9), (8, 13))
+  caps2 = ((2, 14), (6, 10))
+  blocker_templates = [
+    base4,
+    base4 + caps2,
+  ]
 
   best_T = None
   best_ratio = -1.0
   best_n = None
   best_cols = 0
   best_om = 0
 
   for k in depths:
     for sch in schedules:
       for ex in extras:
-        T = build_candidate(k, schedule=sch, extra_first=ex)
-        om = clique_number(T)
-        if om == 0:
-          continue
-        cols = firstfit_colors(T)
-        ratio = cols / om
-        n = len(T)
-        # Prefer higher ratio; tie-break by fewer intervals then more colors
-        better = False
-        if ratio > best_ratio + 1e-12:
-          better = True
-        elif abs(ratio - best_ratio) <= 1e-12:
-          if best_n is None or n < best_n:
-            better = True
-          elif n == best_n and cols > best_cols:
-            better = True
-        if better:
-          best_ratio = ratio
-          best_T = T
-          best_n = n
-          best_cols = cols
-          best_om = om
+        for off_seq in offsets_cycles:
+          for blks in blocker_templates:
+            for iv in interleaves:
+              for rev in reverse_flags:
+                T = build_candidate(
+                  k,
+                  schedule=sch,
+                  extra_first=ex,
+                  offsets_seq=off_seq,
+                  blockers_template=blks,
+                  interleave=iv,
+                  reverse_alt=rev,
+                )
+                om = clique_number(T)
+                if om == 0:
+                  continue
+                cols = firstfit_colors(T)
+                ratio = cols / om
+                n = len(T)
+                # Prefer higher ratio; tie-break by fewer intervals then more colors
+                better = False
+                if ratio > best_ratio + 1e-12:
+                  better = True
+                elif abs(ratio - best_ratio) <= 1e-12:
+                  if best_n is None or n < best_n:
+                    better = True
+                  elif n == best_n and cols > best_cols:
+                    better = True
+                if better:
+                  best_ratio = ratio
+                  best_T = T
+                  best_n = n
+                  best_cols = cols
+                  best_om = om
 
   # Fallback to baseline 4-iteration construction if search fails
   if best_T is None:
     T = [(0, 1)]
     for i in range(iterations):
       lo = min(l for l, r in T)
       hi = max(r for l, r in T)
       delta = hi - lo
       S = []
       for start in (2, 6, 10, 14):
         S += [(delta * start + l - lo, delta * start + r - lo) for l, r in T]
       S += [
         (delta * 1, delta * 5),
         (delta * 12, delta * 16),
         (delta * 4, delta * 9),
         (delta * 8, delta * 13)
       ]
       T = S
     return T
 
   return best_T
 
   # return [  # Figure 3, OPT=2, FF=4
   #   (2,3),
   #   (6,7),
   #   (10,11),
   #   (14,15),
   #   (1,5),
   #   (12,16),
   #   (4,9),
   #   (8,13),
   # ]
 
 # EVOLVE-BLOCK-END
 
 def run_experiment(**kwargs):
   """Main called by evaluator"""
   return construct_intervals()