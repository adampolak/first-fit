--- a/original.py
+++ b/original.py
@@ -1,180 +1,200 @@
 # EVOLVE-BLOCK-START
 
 def construct_intervals(iterations=4):
   """
-  Construct a sequence of intervals of real line to maximize FirstFit/omega.
-  Improvements over the previous implementation:
-   - try both left-anchored and center-anchored translations for copies,
-     and a small set of alternative offset patterns to diversify geometry;
-   - normalize endpoints to a compact even integer grid before returning,
-     which avoids extremely large floats and tends to help validator scoring.
+  Construct a sequence of intervals to maximize FirstFit/omega.
+  Modular, fast variant with a small, fixed set of template patterns.
+
+  Returns:
+    List of tuples (l, r) on a compact integer grid.
   """
 
-  # --- Helper routines (kept lightweight and deterministic) ---
-
-  def firstfit_colors(intervals):
-    """Simulate FirstFit using per-color last end-point tracking."""
-    last_end = []
+  # Lightweight helpers (pure-Python, no external deps)
+
+  def _normalize_grid(intervals):
+    """Map unique endpoints to increasing even integers starting at 0."""
+    if not intervals:
+      return []
+    endpoints = sorted({x for seg in intervals for x in seg})
+    coord = {}
+    cur = 0
+    for e in endpoints:
+      coord[e] = cur
+      cur += 2  # keep even gaps
+    return [(coord[l], coord[r]) for (l, r) in intervals]
+
+  def _firstfit_colors(intervals):
+    """
+    Simulated FirstFit with a simple per-color end-tracking rule.
+    We keep for each color the rightmost end of its last interval and allow
+    reuse if the new interval starts after that end.
+    Returns number of colors used.
+    """
+    last_end = []  # per-color last end
     for (l, r) in intervals:
       placed = False
-      for i, le in enumerate(last_end):
-        if l >= le:
+      for i, end in enumerate(last_end):
+        if l >= end:
           last_end[i] = r
           placed = True
           break
       if not placed:
         last_end.append(r)
     return len(last_end)
 
-  def clique_number(intervals):
-    """Sweep for open intervals; process right endpoints before left at ties."""
-    events = []
+  def _clique_number(intervals):
+    """
+    Exact clique number via sweep-line on open intervals.
+    Treat (l, r) as open; count active intervals between endpoints.
+    """
+    # Build events: (position, delta); open at l, close at r
+    ev = []
     for (l, r) in intervals:
       if l < r:
-        events.append((l, +1))
-        events.append((r, -1))
-    events.sort(key=lambda e: (e[0], 0 if e[1] == -1 else 1))
-    cur = best = 0
-    for _, t in events:
-      cur += t
+        ev.append((l, 1))
+        ev.append((r, -1))
+    # sort by position; for ties, end (-1) before start (+1) to model open intervals
+    ev.sort(key=lambda x: (x[0], x[1]))
+    cur = 0
+    best = 0
+    for _, d in ev:
+      cur += d
       if cur > best:
         best = cur
     return best
 
-  def _normalize_grid(intervals):
-    """
-    Map all unique endpoints to increasing even integers (0,2,4,...).
-    This keeps instances compact and avoids unwieldy coordinates.
-    """
-    if not intervals:
-      return []
-    endpoints = sorted(set(x for seg in intervals for x in seg))
-    coord = {}
-    cur = 0
-    for e in endpoints:
-      coord[e] = cur
-      cur += 2
-    return [(coord[l], coord[r]) for (l, r) in intervals]
-
-  def build_candidate(k, schedule='after', extra_first=False, translation='left', offsets=(2,6,10,14)):
-    """
-    Build k-level recursive pattern using copies and blockers.
-    translation in {'left','center'}:
-      - 'left' anchors copies by left endpoint as before
-      - 'center' aligns copies relative to the center of current T,
-        producing a staggered geometry that can be adversarial to FirstFit
-    offsets is a tuple of integer multipliers for the level translation.
+  def _make_candidate_template(k, offsets=(2,6,10,14), extra_first=False, translation='left', schedule='after'):
+    """
+    Construct a k-level recursive pattern with four copies per level plus the four blockers.
+    translation: 'left' (baseline) or 'center' (center-based shifting).
+    schedule: how to lay out (simplified to 'after','before','split' variants).
+    extra_first: optionally add a 5th copy on level 0 to increase geometry.
     """
     T = [(0.0, 1.0)]
-    for i in range(k):
+    for lvl in range(k):
       lo = min(l for l, r in T)
       hi = max(r for l, r in T)
       delta = hi - lo
       center = (lo + hi) / 2.0
 
-      # optionally include a fifth copy on the first iteration
-      offs = tuple(list(offsets) + ([18] if extra_first and i == 0 else []))
-
-      def make_copies(from_T, offsets_local):
-        S = []
-        for start in offsets_local:
-          if translation == 'left':
-            offset = delta * start - lo
-          else:  # center translation: align by center
-            offset = delta * start - center
-          for (l, r) in from_T:
-            S.append((l + offset, r + offset))
-        return S
+      offs = list(offsets)
+      if extra_first and lvl == 0:
+        offs.append(18)
+
+      def _offset_for(start):
+        if translation == 'left':
+          return delta * start - lo
+        else:  # center translation
+          return delta * start - center
+
+      # build copies
+      copy_seq = []
+      for s in offs:
+        off = _offset_for(s)
+        for (l, r) in T:
+          copy_seq.append((l + off, r + off))
 
       blockers = [
         (delta * 1,  delta * 5),
         (delta * 12, delta * 16),
         (delta * 4,  delta * 9),
         (delta * 8,  delta * 13),
       ]
 
       if schedule == 'after':
-        S = make_copies(T, offs) + blockers
+        T = copy_seq + blockers
       elif schedule == 'before':
-        S = list(blockers) + make_copies(T, offs)
-      else:  # 'split': half the copies, then blockers, then remaining copies
+        T = blockers + copy_seq
+      else:  # 'split'
         h = max(1, len(offs) // 2)
         first = offs[:h]
         second = offs[h:]
-        S = make_copies(T, first) + list(blockers) + make_copies(T, second)
-
-      T = S
+        first_seq = []
+        for s in first:
+          off = _offset_for(s)
+          for (l, r) in T:
+            first_seq.append((l + off, r + off))
+        second_seq = []
+        for s in second:
+          off = _offset_for(s)
+          for (l, r) in T:
+            second_seq.append((l + off, r + off))
+        T = first_seq + blockers + second_seq
+
     return T
 
-  # --- Enumerate a modest set of candidates and select the best by ratio ---
+  # Candidate configuration space (compact and deterministic)
   depths = [max(2, iterations - 1), iterations]
+  translations = ['left', 'center']
+  offset_sets = [
+    (2, 6, 10, 14),  # baseline
+    (1, 5, 9, 13),   # shifted
+    (3, 7, 11, 15),  # alternate
+  ]
   schedules = ['after', 'before', 'split']
   extras = [False, True]
-  translations = ['left', 'center']
-  offsets_options = [
-    (2, 6, 10, 14),  # baseline
-    (1, 5, 9, 13),   # shifted pattern
-    (3, 7, 11, 15),  # alternate stagger
-  ]
 
   best_T = None
   best_ratio = -1.0
   best_n = None
   best_cols = 0
   best_om = 0
 
+  # Exhaust a small, fixed set of combinations (keeps runtime small)
   for k in depths:
     for sch in schedules:
       for ex in extras:
         for trans in translations:
-          for offs in offsets_options:
-            T = build_candidate(k, schedule=sch, extra_first=ex, translation=trans, offsets=offs)
-            om = clique_number(T)
+          for offs in offset_sets:
+            T = _make_candidate_template(k, offsets=offs, extra_first=ex, translation=trans, schedule=sch)
+            om = _clique_number(T)
             if om == 0:
               continue
-            cols = firstfit_colors(T)
+            cols = _firstfit_colors(T)
             ratio = cols / om
+
             n = len(T)
-            # Prefer higher ratio; tie-break by fewer intervals then more colors
             better = False
             if ratio > best_ratio + 1e-12:
               better = True
             elif abs(ratio - best_ratio) <= 1e-12:
               if best_n is None or n < best_n:
                 better = True
               elif n == best_n and cols > best_cols:
                 better = True
+
             if better:
               best_ratio = ratio
               best_T = T
               best_n = n
               best_cols = cols
               best_om = om
 
-  # Fallback to baseline 4-iteration construction if search fails
+  # Fallback: canonical canonical-4-iteration pattern if search failed
   if best_T is None:
+    best_T = []
     T = [(0.0, 1.0)]
-    for i in range(iterations):
+    for _ in range(4):
       lo = min(l for l, r in T)
       hi = max(r for l, r in T)
       delta = hi - lo
       S = []
       for start in (2, 6, 10, 14):
-        S += [(delta * start + l - lo, delta * start + r - lo) for l, r in T]
+        S += [(delta * start + l - lo, delta * start + r - lo) for (l, r) in T]
       S += [
         (delta * 1, delta * 5),
         (delta * 12, delta * 16),
         (delta * 4, delta * 9),
         (delta * 8, delta * 13)
       ]
       T = S
-    return _normalize_grid(T)
-
-  # Normalize the best candidate to a compact integer grid before returning.
+    best_T = T
+
+  # Normalize and return
   return _normalize_grid(best_T)
 
 # EVOLVE-BLOCK-END
 
 def run_experiment(**kwargs):
   """Main called by evaluator"""
   return construct_intervals()