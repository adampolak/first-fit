<NAME>
scheduled_builder_and_wider_wave_search
</NAME>

<DESCRIPTION>
I introduce two complementary enhancements aimed at pushing FirstFit's color usage beyond the current plateau while keeping omega controlled:

1) Scheduled recursive builder with translation and extra-last copy:
   - Extend build_recursive_pattern to support schedule ∈ {after, before, split, interleaved}, translation ∈ {left, center}, and an extra_last option. This arrival-order engineering is known to affect FirstFit significantly. Interleaving and center anchoring tend to couple colors across tower layers, which may yield more colors without increasing the clique number.

2) Broadened deterministic wave augmentation:
   - Expand try_add_wave to explore a richer set of insertion positions (uniform samples across the entire sequence plus dense early/late windows) and a wider set of short lengths {2,3,4,5}. Also enrich candidate left endpoints. This aims to find “cap” intervals that overlap many active colors while avoiding increasing omega, in line with the “waves” heuristic.

3) Parameter sweep in construct_intervals:
   - Add a modest, deterministic search over schedules, translations, and extra_last options (along with existing base seed, depth, offsets, blockers, extra_first) to choose the best base before augmentation. This is lightweight (hundreds of candidates) but can exploit the improved builder’s degrees of freedom to find higher FF/omega configurations if they exist nearby.

These changes keep the instance sizes and runtime manageable while significantly diversifying the arrival order and augmentation geometry, aligning with known techniques (blockers, towers, interleaving, caps) used to stress FirstFit online.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
def build_recursive_pattern(base_seed, depth, offsets=(2,6,10,14), blockers=((1,5),(12,16),(4,9),(8,13)), extra_first=False):
    """
    Build the recursive four-copy + four-blocker pattern.
      - base_seed: list of (l,r) floats
      - depth: number of recursive levels
      - offsets: tuple of copy-start multipliers
      - blockers: list of (a,b) multipliers for long connectors
      - extra_first: if True, add one extra copy at level 0 (small variant)
    """
    T = [tuple(iv) for iv in base_seed]
    for lvl in range(depth):
        lo = min(l for l,r in T)
        hi = max(r for l,r in T)
        delta = hi - lo
        S = []
        offs = list(offsets)
        if extra_first:
            # add a further copy step (+4) at every level
            offs = offs + [offs[-1] + 4]
        for start in offs:
            off = delta * start - lo
            for (l,r) in T:
                S.append((l + off, r + off))
        for (a,b) in blockers:
            S.append((delta * a, delta * b))
        T = S
    return T
=======
def build_recursive_pattern(base_seed, depth, offsets=(2,6,10,14), blockers=((1,5),(12,16),(4,9),(8,13)),
                            extra_first=False, extra_last=False, schedule='after', translation='left'):
    """
    Build the recursive four-copy + four-blocker pattern with arrival-order control.
      - base_seed: list of (l,r) floats
      - depth: number of recursive levels
      - offsets: tuple of copy-start multipliers
      - blockers: list of (a,b) multipliers for long connectors
      - extra_first: if True, add one extra copy at every level (offset +4 from last)
      - extra_last: if True, add one extra copy only at the last level
      - schedule: 'after' | 'before' | 'split' | 'interleaved' controls how blockers are ordered
      - translation: 'left' | 'center' anchor for positioning copies/blockers
    """
    T = [tuple(iv) for iv in base_seed]
    for lvl in range(depth):
        lo = min(l for l, r in T)
        hi = max(r for l, r in T)
        delta = hi - lo
        center = (lo + hi) / 2.0

        offs = list(offsets)
        if extra_first:
            offs = offs + [offs[-1] + 4]
        if extra_last and lvl == depth - 1:
            if (offs[-1] + 4) not in offs:
                offs = offs + [offs[-1] + 4]

        def place_copies(from_T, offsets_seq):
            Slocal = []
            for start in offsets_seq:
                if translation == 'left':
                    off = delta * start - lo
                else:
                    off = delta * start - center
                for (l, r) in from_T:
                    Slocal.append((l + off, r + off))
            return Slocal

        # scale blockers according to translation
        if translation == 'left':
            blk = [(delta * a, delta * b) for (a, b) in blockers]
        else:
            blk = [(delta * a - center, delta * b - center) for (a, b) in blockers]

        if schedule == 'before':
            S = list(blk) + place_copies(T, offs)
        elif schedule == 'split':
            h = max(1, len(offs) // 2)
            S = place_copies(T, offs[:h]) + list(blk) + place_copies(T, offs[h:])
        elif schedule == 'interleaved':
            S = []
            for idx, start in enumerate(offs):
                # one copy
                if translation == 'left':
                    off = delta * start - lo
                else:
                    off = delta * start - center
                for (l, r) in T:
                    S.append((l + off, r + off))
                # interleave a blocker if available (cycle if more copies)
                if blk:
                    S.append(blk[idx % len(blk)])
        else:  # 'after'
            S = place_copies(T, offs) + list(blk)

        T = S
    return T
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
def try_add_wave(cur_intervals, target_omega, wave_length=2, candidates_limit=600):
    """
    Try to add short "wave" intervals to increase FirstFit colors without
    increasing clique number above target_omega.

    Improvements over simple append:
      - consider multiple insertion positions (not just append-at-end)
      - try small set of nearby wave lengths {L-1, L, L+1}
      - deterministic candidate sampling

    Returns:
      - (accepted_interval or None, new_intervals_with_insertion)
    """
    # Work on normalized integer intervals
    T = list(cur_intervals)
    if not T:
        return None, T

    coords = sorted(set(x for iv in T for x in iv))
    min_x = min(coords)
    max_x = max(coords)

    # base metrics
    base_cols = firstfit_colors(T)
    base_om = clique_number(T)
    if base_om > target_omega:
        target_omega = base_om

    # construct candidate left endpoints from gaps and coarse grid
    def candidate_lefts(wl):
        left_candidates = set()
        for a, b in zip(coords, coords[1:]):
            if b - a <= 0:
                continue
            if b - a >= wl + 1:
                left_candidates.add(a + 1)
                left_candidates.add((a + b) // 2)
                left_candidates.add(b - wl - 1)
            else:
                left_candidates.add(a)
        step = max(1, (max_x - min_x) // 30)
        for x in range(min_x, max_x - wl + 1, step):
            left_candidates.add(x)
        lefts = sorted(left_candidates)
        if len(lefts) > candidates_limit:
            stride = max(1, len(lefts) // candidates_limit)
            lefts = [lefts[i] for i in range(0, len(lefts), stride)]
        return lefts

    # insertion positions to probe: append and several strategic points near the tail and mid
    N = len(T)
    probe_positions = sorted(set(
        [N] +
        [max(0, N - k) for k in (2, 3, 4, 5, 6, 7, 8, 12, 16)] +
        [N // 2, N // 3, (2 * N) // 3]
    ))

    # try wave lengths: L-1, L, L+1 (clamped to >=1)
    wave_lengths = sorted(set([max(1, wave_length - 1), wave_length, wave_length + 1]))

    for wl in wave_lengths:
        for x in candidate_lefts(wl):
            cand = (x, x + wl)
            if cand[0] >= cand[1]:
                continue
            # quick omega check for append case (cheap filter)
            if clique_number(T + [cand]) > target_omega:
                continue
            # try multiple insertion positions
            for pos in probe_positions:
                pos = max(0, min(N, pos))
                new_seq = T[:pos] + [cand] + T[pos:]
                new_om = clique_number(new_seq)
                if new_om > target_omega:
                    continue
                new_cols = firstfit_colors(new_seq)
                if new_cols > base_cols:
                    return cand, new_seq
    return None, T
=======
def try_add_wave(cur_intervals, target_omega, wave_length=2, candidates_limit=600):
    """
    Try to add short "wave" intervals to increase FirstFit colors without
    increasing clique number above target_omega.

    Improvements:
      - explore a richer set of insertion positions (uniform samples over [0..N])
      - consider wave lengths in {max(1,L-1), L, L+1, L+2} intersected with [2..5]
      - diversify candidate left endpoints using all grid coords and midpoints
    """
    T = list(cur_intervals)
    if not T:
        return None, T

    coords = sorted(set(x for iv in T for x in iv))
    if not coords:
        return None, T
    min_x = min(coords)
    max_x = max(coords)

    # base metrics
    base_cols = firstfit_colors(T)
    base_om = clique_number(T)
    if base_om > target_omega:
        target_omega = base_om

    # construct candidate left endpoints from gaps and coarse grid
    def candidate_lefts(wl):
        left_candidates = set()
        # include raw coords and shifted-by-1 positions when feasible
        for x in coords:
            left_candidates.add(x)
            left_candidates.add(x + 1)
        # include midpoints and right-shifted starts within gaps
        for a, b in zip(coords, coords[1:]):
            gap = b - a
            if gap <= 0:
                continue
            mid = (a + b) // 2
            left_candidates.add(mid)
            if gap >= wl + 2:
                left_candidates.add(b - wl - 1)
                left_candidates.add(a + 1)
        # include a uniform coarse grid across the span
        span = max_x - min_x
        step = max(1, span // 40)
        for x in range(min_x, max_x - wl + 1, step):
            left_candidates.add(x)
        lefts = sorted(x for x in left_candidates if x + wl <= max_x + (wl // 2))
        if len(lefts) > candidates_limit:
            stride = max(1, len(lefts) // candidates_limit)
            lefts = [lefts[i] for i in range(0, len(lefts), stride)]
        return lefts

    # insertion positions to probe: dense near head/tail + uniform samples
    N = len(T)
    pos_set = set()
    # early and late windows
    for k in range(0, min(N + 1, 24)):
        pos_set.add(k)
        pos_set.add(max(0, N - k))
    # uniform across full sequence
    stepN = max(1, N // 25)
    for p in range(0, N + 1, stepN):
        pos_set.add(p)
    # include middle landmarks
    pos_set.update([N // 2, N // 3, (2 * N) // 3])
    probe_positions = sorted(p for p in pos_set if 0 <= p <= N)

    # try wave lengths: broaden slightly but keep short
    raw_wls = [max(1, wave_length - 1), wave_length, wave_length + 1, wave_length + 2, 2, 3, 4, 5]
    wave_lengths = sorted(set(w for w in raw_wls if 1 <= w <= 6))

    for wl in wave_lengths:
        for x in candidate_lefts(wl):
            cand = (x, x + wl)
            if cand[0] >= cand[1]:
                continue
            # quick omega check for append case (cheap filter)
            if clique_number(T + [cand]) > target_omega:
                continue
            # try multiple insertion positions
            for pos in probe_positions:
                new_seq = T[:pos] + [cand] + T[pos:]
                new_om = clique_number(new_seq)
                if new_om > target_omega:
                    continue
                new_cols = firstfit_colors(new_seq)
                if new_cols > base_cols:
                    return cand, new_seq
    return None, T
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
def construct_intervals():
    """
    Build intervals (in arrival order) and attempt to augment them with waves to
    increase FirstFit color usage while keeping omega controlled.

    Returns normalized integer intervals.
    """
    # base seeds and templates to try
    base_seeds = [
        [(0.0, 1.0)],                      # canonical single seed
        [(0.0, 1.0), (2.0, 3.0)],          # two disjoint seeds
    ]
    depths = [3, 4]  # try a couple of depths (keeps sizes manageable)
    offset_templates = [
        (2,6,10,14),    # canonical
        (1,5,9,13),     # alternative
    ]
    blocker_templates = [
        ((1,5),(12,16),(4,9),(8,13)),  # canonical
        ((0,4),(11,15),(3,8),(7,12)),  # variant
    ]
    extra_first_choices = [False, True]

    # Evaluate baseline candidates and pick the best one by FF/OPT ratio
    best = None  # tuple (ratio, cols, om, intervals_raw)
    for base in base_seeds:
        for depth in depths:
            for offs in offset_templates:
                for blks in blocker_templates:
                    for extra in extra_first_choices:
                        T = build_recursive_pattern(base_seed=base, depth=depth, offsets=offs, blockers=blks, extra_first=extra)
                        Tn = normalize_to_grid(T)
                        if not Tn:
                            continue
                        om = clique_number(Tn)
                        if om == 0:
                            continue
                        cols = firstfit_colors(Tn)
                        ratio = cols / om
                        cand = (ratio, cols, om, T)
                        if best is None or cand[0] > best[0] + 1e-12 or (abs(cand[0]-best[0])<=1e-12 and len(T) < len(best[3])):
                            best = cand

    if best is None:
        # fallback: simple canonical depth=4
        T = build_recursive_pattern([(0.0,1.0)], depth=4)
    else:
        T = best[3]

    # Normalize to integer grid for augmentation steps
    current = normalize_to_grid(T)
    current_om = clique_number(current)
    current_cols = firstfit_colors(current)
    best_ratio = current_cols / current_om if current_om > 0 else 0

    # Augmentation loop: try to add up to max_waves that improve colors while preserving omega
    max_waves = 60  # keep moderate
    wave_length = max(1, max(1, max((r-l) for l,r in current)) // 30)  # choose a small wave length relative to scale
    # ensure wave_length at least 2 for stability if space allows
    wave_length = max(1, min(3, wave_length))
    added_any = True
    waves_added = 0
    # We'll accept only additions that strictly increase FF colors and keep omega unchanged (or <= original)
    target_omega = current_om
    while waves_added < max_waves and added_any:
        added_any = False
        cand, newT = try_add_wave(current, target_omega, wave_length=wave_length, candidates_limit=800)
        if cand is not None:
            # Update current
            current = normalize_to_grid(newT)
            new_om = clique_number(current)
            new_cols = firstfit_colors(current)
            if new_om <= target_omega and new_cols > current_cols:
                current_cols = new_cols
                current_om = new_om
                best_ratio = current_cols / current_om if current_om > 0 else best_ratio
                waves_added += 1
                added_any = True
            else:
                # revert (shouldn't happen given try_add_wave guard) but keep safe
                # if candidate didn't help, stop to keep deterministic behavior
                break

    # After augmentation, perform conservative pruning while preserving observed ratio
    observed_ratio = current_cols / current_om if current_om > 0 else best_ratio
    pruned = conservative_prune(current, observed_ratio)
    final_norm = normalize_to_grid(pruned)
    # final sanity: ensure we didn't lose the ratio through pruning; if so, return pre-prune
    if final_norm:
        final_cols = firstfit_colors(final_norm)
        final_om = clique_number(final_norm) or 1
        if final_cols / final_om + 1e-12 < observed_ratio:
            return current  # return pre-prune normalized
        else:
            return final_norm
    else:
        return current
=======
def construct_intervals():
    """
    Build intervals (in arrival order) using a parameter sweep over recursive schedules,
    translations, and extra-copy options, then augment with waves to try to increase
    FirstFit colors while keeping omega controlled. Returns normalized integer intervals.
    """
    # base seeds and templates to try
    base_seeds = [
        [(0.0, 1.0)],                      # canonical single seed
        [(0.0, 1.0), (2.0, 3.0)],          # two disjoint seeds
    ]
    depths = [3, 4]  # try a couple of depths (keeps sizes manageable)
    offset_templates = [
        (2, 6, 10, 14),    # canonical
        (1, 5, 9, 13),     # alternative
    ]
    blocker_templates = [
        ((1, 5), (12, 16), (4, 9), (8, 13)),  # canonical
        ((0, 4), (11, 15), (3, 8), (7, 12)),  # variant
    ]
    schedules = ['after', 'split', 'interleaved']
    translations = ['left', 'center']
    extra_first_choices = [False, True]
    extra_last_choices = [False, True]

    # Evaluate baseline candidates and pick the best one by FF/OPT ratio
    best = None  # tuple (ratio, cols, om, intervals_raw)
    for base in base_seeds:
        for depth in depths:
            for offs in offset_templates:
                for blks in blocker_templates:
                    for sch in schedules:
                        for tr in translations:
                            for extra_f in extra_first_choices:
                                for extra_l in extra_last_choices:
                                    T = build_recursive_pattern(base_seed=base, depth=depth, offsets=offs, blockers=blks,
                                                                extra_first=extra_f, extra_last=extra_l,
                                                                schedule=sch, translation=tr)
                                    Tn = normalize_to_grid(T)
                                    if not Tn:
                                        continue
                                    om = clique_number(Tn)
                                    if om == 0:
                                        continue
                                    cols = firstfit_colors(Tn)
                                    ratio = cols / om
                                    cand = (ratio, cols, om, T)
                                    if best is None or cand[0] > best[0] + 1e-12 or (abs(cand[0]-best[0])<=1e-12 and len(T) < len(best[3])):
                                        best = cand

    if best is None:
        # fallback: simple canonical depth=4
        T = build_recursive_pattern([(0.0, 1.0)], depth=4)
    else:
        T = best[3]

    # Normalize to integer grid for augmentation steps
    current = normalize_to_grid(T)
    current_om = clique_number(current)
    current_cols = firstfit_colors(current)

    # Augmentation loop: try to add short waves that improve colors while preserving omega
    max_waves = 40  # keep moderate
    # choose a small base wave length relative to grid span; cap to 3 to keep "short"
    base_wl = max(1, max((r - l) for l, r in current) // 30)
    wave_length = max(1, min(3, base_wl))
    waves_added = 0
    target_omega = current_om
    improved = True
    while waves_added < max_waves and improved:
        improved = False
        cand, newT = try_add_wave(current, target_omega, wave_length=wave_length, candidates_limit=1000)
        if cand is None:
            break
        # apply and evaluate
        current = normalize_to_grid(newT)
        new_om = clique_number(current)
        new_cols = firstfit_colors(current)
        if new_om <= target_omega and new_cols > current_cols:
            current_cols = new_cols
            current_om = new_om
            waves_added += 1
            improved = True

    # After augmentation, perform conservative pruning while preserving observed ratio
    observed_ratio = current_cols / (current_om or 1)
    pruned = conservative_prune(current, observed_ratio)
    final_norm = normalize_to_grid(pruned)
    # final sanity: ensure we didn't lose the ratio through pruning; if so, return pre-prune
    if final_norm:
        final_cols = firstfit_colors(final_norm)
        final_om = clique_number(final_norm) or 1
        if final_cols / final_om + 1e-12 < observed_ratio:
            return current  # return pre-prune normalized
        else:
            return final_norm
    else:
        return current
>>>>>>> REPLACE
</DIFF>