# EVOLVE-BLOCK-START

def construct_intervals(iterations=4):
  """
  Build a sequence of open intervals (l, r) presented to FirstFit.
  This version explores multiple small variations around the canonical
  Figure-4 style construction and returns the best-based (normalized) set
  of intervals found by deterministic evaluation.

  Returns:
    intervals: list of (l, r) with integer endpoints (open intervals)
  """

  # Helpers: deterministic, lightweight utilities

  def _normalize_grid(intervals):
    """Map unique endpoints to increasing even integers for compactness."""
    if not intervals:
      return []
    endpoints = sorted(set(x for seg in intervals for x in seg))
    coord = {}
    cur = 0
    for e in endpoints:
      coord[e] = cur
      cur += 2
    return [(coord[l], coord[r]) for (l, r) in intervals]

  def firstfit_colors(intervals):
    """Fast FirstFit coloring using per-color last-end tracking."""
    last_end = []  # last end (r) for each color
    for (l, r) in intervals:
      placed = False
      for i, le in enumerate(last_end):
        if l >= le:
          last_end[i] = r
          placed = True
          break
      if not placed:
        last_end.append(r)
    return len(last_end)

  def clique_number(intervals):
    """Open-interval clique number via sweep; right endpoints before left on ties."""
    events = []
    for (l, r) in intervals:
      if l < r:
        events.append((l, +1))
        events.append((r, -1))
    # process -1 before +1 at same coordinate (open intervals)
    events.sort(key=lambda e: (e[0], 0 if e[1] == -1 else 1))
    cur = 0
    best = 0
    for _, t in events:
      cur += t
      if cur > best:
        best = cur
    return best

  # Build a single recursive pattern with given parameters (k levels)
  def build_pattern(k, offsets, translation, blockers, blocker_anchor, base_seed=[(0.0, 1.0)]):
    T = list(base_seed)
    for _ in range(k):
      lo = min(l for l, r in T)
      hi = max(r for l, r in T)
      delta = hi - lo
      center = (lo + hi) / 2.0

      # 4 copies (with a possible extra one via offsets)
      S = []
      for start in offsets:
        if translation == 'left':
          off = delta * start - lo
        else:
          off = delta * start - center
        for (l, r) in T:
          S.append((l + off, r + off))

      # 4 blockers
      for (a, b) in blockers:
        if blocker_anchor == 'left':
          S.append((delta * a, delta * b))
        else:
          S.append((delta * a - center, delta * b - center))

      T = S
    return T

  # Enumerate a modest, deterministic set of candidate patterns
  # Depths (k) tuned to be strong but manageable
  depths = []
  if iterations >= 3:
    depths.extend([iterations - 1, iterations])
  depths = sorted(set([d for d in depths if d >= 2]))
  if not depths:
    depths = [4]

  # Offsets/patterns to diversify beyond the canonical (2,6,10,14)
  offsets_options = [
    (2, 6, 10, 14),  # baseline
    (1, 5, 9, 13),   # shifted
    (3, 7, 11, 15),  # another stagger
  ]
  translations = ['left', 'center']     # how copies are positioned
  blocker_anchors = ['left', 'center']  # how blockers anchored
  blockers = ((1, 5), (12, 16), (4, 9), (8, 13))  # canonical blockers

  best_T = None
  best_ratio = -1.0
  best_n = None
  best_cols = 0
  best_om = 0

  # Try all combinations of a small, fixed set of patterns
  for k in depths:
    for offs in offsets_options:
      for trans in translations:
        for anchor in blocker_anchors:
          T = build_pattern(
            k=k,
            offsets=offs,
            translation=trans,
            blockers=blockers,
            blocker_anchor=anchor
          )
          # Quick guard to avoid blowups if pattern gets enormous
          if len(T) > 5000:
            continue
          T_norm = _normalize_grid(T)
          om = clique_number(T_norm)
          if om <= 0:
            continue
          cols = firstfit_colors(T_norm)
          ratio = cols / om
          n = len(T_norm)
          # Pick best by ratio; tie-break by smaller n, then more colors
          if ratio > best_ratio + 1e-12:
            best_ratio = ratio
            best_T = T_norm
            best_n = n
            best_cols = cols
            best_om = om
          elif abs(ratio - best_ratio) <= 1e-12:
            if best_n is None or n < best_n:
              best_ratio = ratio
              best_T = T_norm
              best_n = n
              best_cols = cols
              best_om = om
            elif n == best_n and cols > best_cols:
              best_ratio = ratio
              best_T = T_norm
              best_cols = cols
              best_om = om

  # Fallback: baseline canonical pattern if no candidate was better found
  if best_T is None:
    k = max(2, iterations)
    T = [(0.0, 1.0)]
    for _ in range(k):
      lo = min(l for l, r in T)
      hi = max(r for l, r in T)
      delta = hi - lo
      S = []
      for start in (2, 6, 10, 14):
        offset = delta * start - lo
        for (l, r) in T:
          S.append((l + offset, r + offset))
      S += [
        (delta * 1,  delta * 5),
        (delta * 12, delta * 16),
        (delta * 4,  delta * 9),
        (delta * 8,  delta * 13),
      ]
      T = S
    return _normalize_grid(T)

  return best_T

# EVOLVE-BLOCK-END