<NAME>
add_interleaved_schedule_and_halfstep_offsets</NAME>

<DESCRIPTION>
Introduce a new 'interleaved' scheduling option in build_candidate to interleave copies and blockers, and expand the search space with a half-step offsets pattern. This adds more geometric diversity, potentially raising FirstFit usage without increasing clique size.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
  schedules = ['after', 'before', 'split']
  extras = [False, True]
  translations = ['left', 'center']
  offsets_options = [
    (2, 6, 10, 14),  # baseline
    (1, 5, 9, 13),   # shifted pattern
    (3, 7, 11, 15),  # alternate stagger
  ]
=======
  schedules = ['after', 'before', 'split', 'interleaved']
  extras = [False, True]
  translations = ['left', 'center']
  offsets_options = [
    (2, 6, 10, 14),     # baseline
    (1, 5, 9, 13),      # shifted pattern
    (3, 7, 11, 15),     # alternate stagger
    (2.5, 6.5, 10.5, 14.5)  # half-step stagger
  ]
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
      if schedule == 'after':
        S = make_copies(T, offs) + blockers
      elif schedule == 'before':
        S = list(blockers) + make_copies(T, offs)
      else:  # 'split': half the copies, then blockers, then remaining copies
        h = max(1, len(offs) // 2)
        first = offs[:h]
        second = offs[h:]
        S = make_copies(T, first) + list(blockers) + make_copies(T, second)

      T = S
    return T
=======
      if schedule == 'after':
        S = make_copies(T, offs) + blockers
      elif schedule == 'before':
        S = list(blockers) + make_copies(T, offs)
      elif schedule == 'split':
        # half the copies, then blockers, then remaining copies
        h = max(1, len(offs) // 2)
        first = offs[:h]
        second = offs[h:]
        S = make_copies(T, first) + list(blockers) + make_copies(T, second)
      elif schedule == 'interleaved':
        # interleave each copy with a blocker to couple layers
        S = []
        for idx, start in enumerate(offs):
          if translation == 'left':
            offset = delta * start - lo
          else:
            offset = delta * start - center
          for (l0, r0) in T:
            S.append((l0 + offset, r0 + offset))
          if idx < len(blockers):
            S.append(blockers[idx])
      else:
        # fallback to simple after behavior
        S = make_copies(T, offs) + blockers

      T = S
    return T
>>>>>>> REPLACE
</DIFF>