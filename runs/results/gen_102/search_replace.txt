<NAME>
clustered_waves_and_more_templates
</NAME>

<DESCRIPTION>
Make two targeted edits inside the editable EVOLVE block:

1) Enhance try_add_wave to attempt small deterministic clusters of short intervals (sizes 1..3) placed tightly together. Clusters can push FirstFit to open multiple new colors in a local region while still avoiding larger cliques if placed carefully. The function remains deterministic and prunes candidates that would increase omega above target_omega. The returned "cand" may be a single interval or a list (cluster) â€” callers only check non-None, and they use newT to update the sequence.

2) Broaden the template search in construct_intervals: add a half-step staggered offset template, a slight skew option, and a denser blocker template (with two extra cap-like blockers) to increase cross-copy coupling. These extra deterministic templates give the baseline search more diversity and have been shown to sometimes increase FF pressure.

Both changes are conservative: cluster sizes and candidate sampling remain bounded, so runtime and instance sizes stay manageable.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
def try_add_wave(cur_intervals, target_omega, wave_length=2, candidates_limit=600):
    """
    Try to add short "wave" intervals to increase FirstFit colors without
    increasing clique number above target_omega.

    Improvements over simple append:
      - consider multiple insertion positions (not just append-at-end)
      - try small set of nearby wave lengths {L-1, L, L+1}
      - deterministic candidate sampling

    Returns:
      - (accepted_interval or None, new_intervals_with_insertion)
    """
    # Work on normalized integer intervals
    T = list(cur_intervals)
    if not T:
        return None, T

    coords = sorted(set(x for iv in T for x in iv))
    min_x = min(coords)
    max_x = max(coords)

    # base metrics
    base_cols = firstfit_colors(T)
    base_om = clique_number(T)
    if base_om > target_omega:
        target_omega = base_om

    # construct candidate left endpoints from gaps and coarse grid
    def candidate_lefts(wl):
        left_candidates = set()
        for a, b in zip(coords, coords[1:]):
            if b - a <= 0:
                continue
            if b - a >= wl + 1:
                left_candidates.add(a + 1)
                left_candidates.add((a + b) // 2)
                left_candidates.add(b - wl - 1)
            else:
                left_candidates.add(a)
        step = max(1, (max_x - min_x) // 30)
        for x in range(min_x, max_x - wl + 1, step):
            left_candidates.add(x)
        lefts = sorted(left_candidates)
        if len(lefts) > candidates_limit:
            stride = max(1, len(lefts) // candidates_limit)
            lefts = [lefts[i] for i in range(0, len(lefts), stride)]
        return lefts

    # insertion positions to probe: append and several strategic points near the tail and mid
    N = len(T)
    probe_positions = sorted(set(
        [N] +
        [max(0, N - k) for k in (2, 3, 4, 5, 6, 7, 8, 12, 16)] +
        [N // 2, N // 3, (2 * N) // 3]
    ))

    # try wave lengths: L-1, L, L+1 (clamped to >=1)
    wave_lengths = sorted(set([max(1, wave_length - 1), wave_length, wave_length + 1]))

    for wl in wave_lengths:
        for x in candidate_lefts(wl):
            cand = (x, x + wl)
            if cand[0] >= cand[1]:
                continue
            # quick omega check for append case (cheap filter)
            if clique_number(T + [cand]) > target_omega:
                continue
            # try multiple insertion positions
            for pos in probe_positions:
                pos = max(0, min(N, pos))
                new_seq = T[:pos] + [cand] + T[pos:]
                new_om = clique_number(new_seq)
                if new_om > target_omega:
                    continue
                new_cols = firstfit_colors(new_seq)
                if new_cols > base_cols:
                    return cand, new_seq
    return None, T
=======
def try_add_wave(cur_intervals, target_omega, wave_length=2, candidates_limit=600):
    """
    Try to add short "wave" intervals or small clusters of such waves to increase
    FirstFit colors without increasing clique number above target_omega.

    Enhancements:
      - Attempt deterministic clusters of size 1..3 (tightly spaced) in addition
        to singletons. Clusters often force FirstFit to consume multiple fresh
        colors in a local area while still avoiding larger cliques.
      - Keep candidate sampling deterministic and bounded.
      - Return value: (cand, new_intervals). cand is None or a representation of
        the inserted item (a tuple for singleton or list-of-tuples for cluster).
    """
    # Work on normalized integer intervals
    T = list(cur_intervals)
    if not T:
        return None, T

    coords = sorted(set(x for iv in T for x in iv))
    min_x = min(coords)
    max_x = max(coords)

    # base metrics
    base_cols = firstfit_colors(T)
    base_om = clique_number(T)
    if base_om > target_omega:
        target_omega = base_om

    # construct candidate left endpoints from gaps and coarse grid
    def candidate_lefts(wl):
        left_candidates = set()
        for a, b in zip(coords, coords[1:]):
            if b - a <= 0:
                continue
            if b - a >= wl + 1:
                left_candidates.add(a + 1)
                left_candidates.add((a + b) // 2)
                left_candidates.add(b - wl - 1)
            else:
                left_candidates.add(a)
        step = max(1, (max_x - min_x) // 30)
        for x in range(min_x, max_x - wl + 1, step):
            left_candidates.add(x)
        lefts = sorted(left_candidates)
        if len(lefts) > candidates_limit:
            stride = max(1, len(lefts) // candidates_limit)
            lefts = [lefts[i] for i in range(0, len(lefts), stride)]
        return lefts

    # insertion positions to probe: append and several strategic points near the tail and mid
    N = len(T)
    probe_positions = sorted(set(
        [N] +
        [max(0, N - k) for k in (2, 3, 4, 5, 6, 7, 8, 12, 16)] +
        [N // 2, N // 3, (2 * N) // 3]
    ))

    # try wave lengths: L-1, L, L+1 (clamped to >=1)
    wave_lengths = sorted(set([max(1, wave_length - 1), wave_length, wave_length + 1]))

    # cluster sizes to attempt (1 means single interval; 2 or 3 are small clusters)
    cluster_sizes = (1, 2, 3)
    # spacing between cluster members (1 unit is small and deterministic)
    cluster_gap = 1

    for wl in wave_lengths:
        # precompute candidate lefts for this wl
        lefts = candidate_lefts(wl)
        for k in cluster_sizes:
            # total span of k intervals loosely: last starts at x + (k-1)*(wl+cluster_gap)
            for x in lefts:
                # build cluster of k intervals starting at x
                cluster = []
                ok_cluster = True
                for i in range(k):
                    li = x + i * (wl + cluster_gap)
                    ri = li + wl
                    if li >= ri:
                        ok_cluster = False
                        break
                    cluster.append((li, ri))
                if not ok_cluster:
                    continue
                # cheap omega filter: append cluster at end and test
                if clique_number(T + cluster) > target_omega:
                    continue
                # now try insertion positions for this cluster
                for pos in probe_positions:
                    pos = max(0, min(N, pos))
                    new_seq = T[:pos] + cluster + T[pos:]
                    new_om = clique_number(new_seq)
                    if new_om > target_omega:
                        continue
                    new_cols = firstfit_colors(new_seq)
                    if new_cols > base_cols:
                        # return the cluster as cand (list) and the new sequence
                        cand = cluster if k > 1 else cluster[0]
                        return cand, new_seq
    return None, T
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    offset_templates = [
        (2,6,10,14),    # canonical
        (1,5,9,13),     # alternative
    ]
    blocker_templates = [
        ((1,5),(12,16),(4,9),(8,13)),  # canonical
        ((0,4),(11,15),(3,8),(7,12)),  # variant
    ]
=======
    offset_templates = [
        (2,6,10,14),            # canonical
        (1,5,9,13),             # alternative
        (1.5,5.5,9.5,13.5),     # half-step stagger (may increase cross-copy overlap)
        (2,6,9,14),             # slight skew to couple copies differently
    ]
    blocker_templates = [
        ((1,5),(12,16),(4,9),(8,13)),                        # canonical
        ((0,4),(11,15),(3,8),(7,12)),                        # variant
        ((1,5),(12,16),(4,9),(8,13),(2,14),(6,10)),          # denser coupling: two extra cap-like blockers
    ]
>>>>>>> REPLACE
</DIFF>