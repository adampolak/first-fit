--- a/original.py
+++ b/original.py
@@ -1,246 +1,301 @@
 # EVOLVE-BLOCK-START
 
+from math import gcd
+import random
+
 def construct_intervals(iterations=4):
-  """
-  Build a sequence of open intervals that aims to maximize FirstFit/OPT.
-  Strategy:
-    - 4-copy recursive expansion + 4 blockers per level (Figure-4 style)
-    - Parameter sweep over offsets, blocker templates, translation anchors, and depth
-    - Evaluate each candidate via an internal FirstFit simulation and clique sweep
-    - Normalize endpoints to a compact integer grid before returning
-
-  Arguments:
-    iterations: optional hint; included in the depth sweep if in {3,4,5}
-
-  Returns:
-    intervals: list[(l,r)] of open intervals with integer endpoints
-  """
-
-  # ------------ helpers ------------
-  def overlaps(a, b):
-    (l1, r1), (l2, r2) = a, b
-    # open-interval overlap:
-    return max(l1, l2) < min(r1, r2)
-
-  def firstfit_colors(intervals):
     """
-    Simulate FirstFit on the given arrival order.
-    Colors are independent sets w.r.t. open-interval overlap.
+    Build a sequence of open intervals (integer endpoints) aimed at maximizing
+    FirstFit/omega by order optimization (greedy adversarial sequencing).
+    Returns: list of (l, r) integer pairs (open intervals).
     """
-    colors = []  # list of color classes
-    for iv in intervals:
-      placed = False
-      for c in colors:
-        conflict = False
-        for u in c:
-          if overlaps(u, iv):
-            conflict = True
-            break
-        if not conflict:
-          c.append(iv)
-          placed = True
-          break
-      if not placed:
-        colors.append([iv])
-    return len(colors)
-
-  def clique_number(intervals):
-    """
-    Max number of intervals covering a single point (omega) using sweep.
-    For open intervals, at equal coordinates process right(-1) before left(+1).
-    """
-    events = []  # (x, type) type=-1 for right, +1 for left
-    for (l, r) in intervals:
-      if l < r:
-        events.append((l, +1))
-        events.append((r, -1))
-    events.sort(key=lambda e: (e[0], 0 if e[1] == -1 else 1))
-    cur = best = 0
-    for _, t in events:
-      cur += t
-      if cur > best:
-        best = cur
-    return best
-
-  def normalize_grid(intervals):
-    """
-    Map each unique endpoint to an increasing integer grid (even spacing).
-    Preserves open-interval overlap and arrival order.
-    """
-    if not intervals:
-      return []
-    pts = sorted(set([x for seg in intervals for x in seg]))
-    coord = {e: 2*i for i, e in enumerate(pts)}
-    return [(coord[l], coord[r]) for (l, r) in intervals]
-
-  def build_pattern(base_seed, k, offsets, blockers, translation='left', blocker_anchor='left',
-                    schedule='after', interleave='block', reverse_alt=False):
-    """
-    Recursively expand base_seed k times with multiple copies and blockers.
-    - translation in {'left','center'} controls copy offsets
-    - blocker_anchor in {'left','center'} controls blocker placement
-    - schedule in {'after','before','split'} decides the order of copies vs blockers per level
-    - interleave in {'block','zip'} controls how copies are interleaved
-    - reverse_alt: if True and interleave='block', every other copy is presented in reverse order
-    """
-    T = list(base_seed)
-    for _ in range(k):
-      lo = min(l for l, r in T)
-      hi = max(r for l, r in T)
-      delta = hi - lo
-      center = (lo + hi) / 2.0
-
-      # Build per-copy sequences
-      copy_lists = []
-      for idx, start in enumerate(offsets):
-        if translation == 'left':
-          off = delta * start - lo
-        else:  # center-based
-          off = delta * start - center
-        seq = T if not (reverse_alt and (idx % 2 == 1)) else list(reversed(T))
-        copy_lists.append([(l + off, r + off) for (l, r) in seq])
-
-      # Interleave copies
-      if interleave == 'block':
-        S_copies = []
-        for lst in copy_lists:
-          S_copies.extend(lst)
-      else:  # 'zip': emit one item from each copy in round-robin order
-        S_copies = []
-        if copy_lists:
-          m = len(copy_lists[0])
-          for j in range(m):
-            for lst in copy_lists:
-              S_copies.append(lst[j])
-
-      # Build blockers for this level
-      S_blockers = []
-      for (a, b) in blockers:
-        if blocker_anchor == 'left':
-          S_blockers.append((delta * a, delta * b))
-        else:
-          S_blockers.append((delta * a - center, delta * b - center))
-
-      # Compose level by schedule
-      if schedule == 'before':
-        S = S_blockers + S_copies
-      elif schedule == 'split' and interleave == 'block':
-        h = max(1, len(copy_lists) // 2)
-        first_half = []
-        for i in range(h):
-          first_half.extend(copy_lists[i])
-        second_half = []
-        for i in range(h, len(copy_lists)):
-          second_half.extend(copy_lists[i])
-        S = first_half + S_blockers + second_half
-      else:
-        # default 'after' or 'split' with interleave='zip'
-        S = S_copies + S_blockers
-
-      T = S
-    return T
-
-  def evaluate(intervals):
-    """Return (score, omega, colors, n)."""
-    if not intervals:
-      return (-1.0, 0, 0, 0)
-    om = clique_number(intervals)
-    if om <= 0:
-      return (-1.0, 0, 0, len(intervals))
-    cols = firstfit_colors(intervals)
-    # Slight penalty for larger instances to break ties
-    score = cols / om - 1e-6 * (len(intervals) / 10000.0)
-    return (score, om, cols, len(intervals))
-
-  # ------------ parameter sweep ------------
-  offsets_set = [
-    (2, 6, 10, 14),      # canonical
-    (1, 5, 9, 13),
-    (3, 7, 11, 15),
-    (0, 4, 8, 12),
-    (2, 6, 9, 14),       # slight skew to tighten mid overlap
-    (2, 7, 11, 14),      # shifted second copy
-    (1.5, 5.5, 9.5, 13.5)  # half-step stagger
-  ]
-  blockers_templates = [
-    # A: baseline as in Figure 4
-    ((1, 5), (12, 16), (4, 9), (8, 13)),
-    # B: variant geometry
-    ((0, 4), (6, 10), (8, 12), (14, 18)),
-    # C: tighter mid coupling
-    ((2, 6), (4, 8), (10, 14), (12, 16)),
-    # D: asymmetric early/late pushers
-    ((1, 5), (12, 16), (3, 7), (9, 13)),
-    # E: lengthened extremes
-    ((1, 6), (11, 16), (4, 8), (10, 14)),
-    # F: six-blocker couplers (two extra caps)
-    ((1, 5), (12, 16), (4, 9), (8, 13), (2, 14), (6, 10)),
-  ]
-  translations = ['left', 'center']
-  blocker_anchors = ['left', 'center']
-  depths = [d for d in {3, 4, 5, iterations} if d in (3, 4, 5)]
-  base_seeds = [
-    [(0.0, 1.0)],
-    [(0.0, 1.0), (2.0, 3.0)],
-  ]
-
-  best = None  # (score, om, cols, n, intervals)
-
-  schedules = ['after', 'before', 'split']
-  interleaves = ['block', 'zip']
-  rev_flags = [False, True]
-
-  for base in base_seeds:
-    for k in depths:
-      # avoid overly large instances (approx size ~ 4^k * |base| + O(4^k))
-      if (4 ** k) * (len(base) + 2) > 3000:
-        continue
-      for offsets in offsets_set:
-        for blockers in blockers_templates:
-          for tr in translations:
-            for ba in blocker_anchors:
-              for sch in schedules:
-                for inter in interleaves:
-                  for rev in rev_flags:
-                    T = build_pattern(base_seed=base, k=k, offsets=offsets,
-                                      blockers=blockers, translation=tr, blocker_anchor=ba,
-                                      schedule=sch, interleave=inter, reverse_alt=rev)
-                    score, om, cols, n = evaluate(T)
-                    cand = (score, om, cols, n, T)
-                    if best is None:
-                      best = cand
+    # ---------------------
+    # 1) Build base geometry (Figure-4 style)
+    # ---------------------
+    def build_figure4(k=4, base_seed=None, offsets=(2, 6, 10, 14),
+                      blockers=None, translation='left', blocker_anchor='left'):
+        if base_seed is None:
+            base_seed = [(0.0, 1.0)]
+        if blockers is None:
+            blockers = ((1, 5), (12, 16), (4, 9), (8, 13))
+        T = list(base_seed)
+        for _ in range(k):
+            lo = min(l for l, r in T)
+            hi = max(r for l, r in T)
+            delta = hi - lo
+            center = (lo + hi) / 2.0
+
+            S = []
+            for start in offsets:
+                if translation == 'left':
+                    off = delta * start - lo
+                else:
+                    off = delta * start - center
+                for (l, r) in T:
+                    S.append((l + off, r + off))
+
+            for (a, b) in blockers:
+                if blocker_anchor == 'left':
+                    S.append((delta * a, delta * b))
+                else:
+                    S.append((delta * a - center, delta * b - center))
+
+            T = S
+        return T
+
+    # ---------------------
+    # 2) Normalize endpoints to compact even integer grid
+    # ---------------------
+    def normalize_grid(intervals):
+        if not intervals:
+            return []
+        pts = sorted(set(x for seg in intervals for x in seg))
+        coord = {}
+        cur = 0
+        for p in pts:
+            coord[p] = cur
+            cur += 2
+        return [(coord[l], coord[r]) for (l, r) in intervals]
+
+    # ---------------------
+    # 3) Overlap/clique/FirstFit simulators (robust)
+    # ---------------------
+    def overlaps(a, b):
+        (l1, r1), (l2, r2) = a, b
+        return max(l1, l2) < min(r1, r2)
+
+    def clique_number(intervals):
+        events = []
+        for (l, r) in intervals:
+            if l < r:
+                events.append((l, +1))
+                events.append((r, -1))
+        # open intervals: handle right (-1) before left (+1) at same coordinate
+        events.sort(key=lambda e: (e[0], 0 if e[1] == -1 else 1))
+        cur = best = 0
+        for _, t in events:
+            cur += t
+            if cur > best:
+                best = cur
+        return best
+
+    def firstfit_colors(intervals):
+        """
+        Exact FirstFit: maintain color classes (lists of intervals).
+        This is O(n^2) but n is modest for our instances.
+        """
+        colors = []
+        for iv in intervals:
+            placed = False
+            for c in colors:
+                conflict = False
+                for u in c:
+                    if overlaps(u, iv):
+                        conflict = True
+                        break
+                if not conflict:
+                    c.append(iv)
+                    placed = True
+                    break
+            if not placed:
+                colors.append([iv])
+        return len(colors)
+
+    # ---------------------
+    # 4) Greedy reordering heuristics
+    #    At each step pick the remaining interval that would be assigned to the
+    #    largest color index under the current partial FirstFit state.
+    #    Use per-color 'last_end' fast test (valid because intervals in a color
+    #    are pairwise disjoint and appended in arrival order).
+    # ---------------------
+    def greedy_order(intervals, tie_break='longest', rng=None):
+        # intervals: list of (l, r) integer tuples (normalized)
+        remaining = list(intervals)
+        order = []
+        # color_last_end: current right endpoint for each color class
+        color_last_end = []
+
+        # helper to compute assigned color index quickly
+        def assigned_index(iv):
+            l, r = iv
+            for i, le in enumerate(color_last_end):
+                # open intervals: we can place in color i if iv.l >= last_end
+                if l >= le:
+                    return i
+            return len(color_last_end)
+
+        # pre-shuffle remaining deterministically for tie-breaking stability
+        if rng is not None:
+            rng.shuffle(remaining)
+
+        while remaining:
+            best_idx = -1
+            candidates = []
+            # scan remaining and compute assigned index under current last_end's
+            for iv in remaining:
+                idx = assigned_index(iv)
+                if idx > best_idx:
+                    best_idx = idx
+                    candidates = [iv]
+                elif idx == best_idx:
+                    candidates.append(iv)
+
+            # tie-breaking among candidates
+            if len(candidates) == 1:
+                pick = candidates[0]
+            else:
+                if tie_break == 'longest':
+                    pick = max(candidates, key=lambda x: (x[1] - x[0], -x[0]))
+                elif tie_break == 'shortest':
+                    pick = min(candidates, key=lambda x: (x[1] - x[0], x[0]))
+                elif tie_break == 'leftmost':
+                    pick = min(candidates, key=lambda x: (x[0], x[1]))
+                elif tie_break == 'rightmost':
+                    pick = max(candidates, key=lambda x: (x[1], -x[0]))
+                elif tie_break.startswith('random'):
+                    if rng is None:
+                        pick = candidates[0]
                     else:
-                      if cand[0] > best[0] + 1e-9:
-                        best = cand
-                      elif abs(cand[0] - best[0]) <= 1e-9:
-                        # tie-break by fewer intervals, then more colors
-                        if cand[3] < best[3] or (cand[3] == best[3] and cand[2] > best[2]):
-                          best = cand
-
-  # Fallback to the known-safe baseline if sweep failed (should not happen)
-  if best is None:
-    T = [(0.0, 1.0)]
-    for _ in range(4):
-      lo = min(l for l, r in T)
-      hi = max(r for l, r in T)
-      delta = hi - lo
-      S = []
-      for start in (2, 6, 10, 14):
-        S += [(delta * start + l - lo, delta * start + r - lo) for l, r in T]
-      S += [
-        (delta * 1,  delta * 5),
-        (delta * 12, delta * 16),
-        (delta * 4,  delta * 9),
-        (delta * 8,  delta * 13)
-      ]
-      T = S
-    return normalize_grid(T)
-
-  # Normalize endpoints to compact integer grid and return
-  return normalize_grid(best[4])
+                        pick = rng.choice(candidates)
+                else:
+                    pick = candidates[0]
+
+            # assign pick to color classes
+            assigned = None
+            l, r = pick
+            for i, le in enumerate(color_last_end):
+                if l >= le:
+                    assigned = i
+                    color_last_end[i] = r
+                    break
+            if assigned is None:
+                color_last_end.append(r)
+            order.append(pick)
+            remaining.remove(pick)
+        return order
+
+    # ---------------------
+    # 5) Conservative deterministic pruning pass
+    #    Remove intervals one-by-one (prefer long ones) only if the observed
+    #    FirstFit/omega ratio is preserved (no drop).
+    # ---------------------
+    def prune_preserve_ratio(intervals, target_ratio, max_removals=200):
+        cur = list(intervals)
+        if not cur:
+            return cur
+        base_om = clique_number(cur)
+        if base_om == 0:
+            return cur
+        base_cols = firstfit_colors(cur)
+        base_ratio = base_cols / base_om
+        # acceptance threshold
+        threshold = target_ratio if target_ratio is not None else base_ratio
+        # attempt removals sorted by descending length
+        def length(iv): return iv[1] - iv[0]
+        # deterministic ordering stable tie-break
+        idx_order = sorted(range(len(cur)), key=lambda i: (-length(cur[i]), cur[i][0], cur[i][1]))
+        removals = 0
+        changed = True
+        while changed and removals < max_removals:
+            changed = False
+            for i in list(idx_order):
+                if i >= len(cur):
+                    continue
+                cand = cur[:i] + cur[i+1:]
+                if not cand:
+                    continue
+                om = clique_number(cand)
+                if om == 0:
+                    continue
+                cols = firstfit_colors(cand)
+                ratio = cols / om
+                # accept only if ratio not dropping below threshold
+                if ratio >= threshold - 1e-12:
+                    cur = cand
+                    # recompute idx_order
+                    idx_order = sorted(range(len(cur)), key=lambda j: (-length(cur[j]), cur[j][0], cur[j][1]))
+                    changed = True
+                    removals += 1
+                    break
+        return cur
+
+    # ---------------------
+    # 6) Build, search heuristics, pick best ordering
+    # ---------------------
+    # Build the canonical figure-4 4-level geometry (this matches prior best
+    # geometry that produced 13 colors with omega 5). We keep k=4 by default
+    k = 4 if iterations <= 4 else iterations
+    raw = build_figure4(k=k, base_seed=[(0.0, 1.0)],
+                        offsets=(2, 6, 10, 14),
+                        blockers=((1, 5), (12, 16), (4, 9), (8, 13)),
+                        translation='left', blocker_anchor='left')
+
+    # normalize to integer grid first (this is the geometry that clique/FF will use)
+    base_norm = normalize_grid(raw)
+    if not base_norm:
+        return []
+
+    base_omega = clique_number(base_norm)
+    if base_omega <= 0:
+        return base_norm
+
+    # candidate heuristics to try (deterministic seeds)
+    heuristics = [
+        ('longest', None),
+        ('shortest', None),
+        ('leftmost', None),
+        ('rightmost', None),
+        ('random-42', random.Random(42)),
+        ('random-101', random.Random(101)),
+        ('random-7', random.Random(7)),
+    ]
+
+    best_order = None
+    best_cols = -1
+    best_ratio = -1.0
+    best_n = None
+
+    # Always include the original (baseline) order as a candidate
+    baseline_cols = firstfit_colors(base_norm)
+    baseline_ratio = baseline_cols / base_omega
+    best_order = list(base_norm)
+    best_cols = baseline_cols
+    best_ratio = baseline_ratio
+    best_n = len(base_norm)
+
+    # try each greedy heuristic
+    for (name, rng) in heuristics:
+        tb = name.split('-')[0]  # tie_break key
+        order = greedy_order(base_norm, tie_break=tb, rng=rng)
+        cols = firstfit_colors(order)
+        ratio = cols / base_omega
+        n = len(order)
+        # choose better by ratio; tie-break fewer intervals then more colors
+        if ratio > best_ratio + 1e-12 or (abs(ratio - best_ratio) <= 1e-12 and (n < best_n or (n == best_n and cols > best_cols))):
+            best_order = order
+            best_cols = cols
+            best_ratio = ratio
+            best_n = n
+
+    # Conservative pruning: only if it preserves ratio (do not drop)
+    pruned = prune_preserve_ratio(best_order, target_ratio=best_ratio, max_removals=200)
+    # re-evaluate after pruning
+    pruned_cols = firstfit_colors(pruned)
+    pruned_om = clique_number(pruned)
+    pruned_ratio = pruned_cols / pruned_om if pruned_om > 0 else -1.0
+
+    # Accept pruned if ratio not decreased (minor numeric tolerance)
+    if pruned_ratio >= best_ratio - 1e-12:
+        final = pruned
+    else:
+        final = best_order
+
+    # Final normalization (endpoints already integer grid); ensure tuple ints
+    final_int = [(int(l), int(r)) for (l, r) in final]
+    return final_int
 
 # EVOLVE-BLOCK-END
 
 def run_experiment(**kwargs):
   """Main called by evaluator"""
   return construct_intervals()