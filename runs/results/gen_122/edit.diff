--- a/original.py
+++ b/original.py
@@ -1,66 +1,178 @@
 # EVOLVE-BLOCK-START
 
-def construct_intervals(iterations=4):
-  """
-  Construct a sequence of open intervals (l, r) presented in order to FirstFit.
-  The construction is a recursive expansion inspired by Figure 4 of
-  https://arxiv.org/abs/1506.00192. Increasing 'iterations' strengthens the
-  adversary and typically increases the FirstFit/OPT ratio.
+from typing import List, Tuple, Sequence, Dict
+import math
+import itertools
+import copy
 
-  Arguments:
-    iterations: number of recursive expansion steps (default 4)
+Interval = Tuple[float, float]
 
-  Returns:
-    intervals: list of tuples (l, r) with integer endpoints (open intervals)
-  """
 
-  # Base gadget: two disjoint small intervals to enrich local overlap structure
-  T = [(0.0, 1.0), (3.0, 4.0)]
+def _normalize_grid(intervals: Sequence[Interval], spacing: int = 2) -> List[Tuple[int, int]]:
+    """
+    Map the unique endpoints of 'intervals' to an increasing integer grid
+    spaced by 'spacing' (default 2) and return a list of integer intervals.
+    This preserves order and relative adjacencies (and ensures integer output).
+    """
+    endpoints = sorted({x for seg in intervals for x in seg})
+    coord: Dict[float, int] = {}
+    cur = 0
+    for e in endpoints:
+        coord[e] = cur
+        cur += spacing
+    return [(coord[l], coord[r]) for (l, r) in intervals]
 
-  # For each iteration we replace T by four translated/scaled copies
-  # plus four long connector intervals (as in the Figure-4 construction).
-  # This preserves a small clique size while amplifying FirstFit colors.
-  for i in range(iterations):
+
+def _firstfit_colors(intervals: Sequence[Interval]) -> int:
+    """
+    Simulate FirstFit in the online order given by 'intervals'.
+    Uses the invariant: for each color remember the right endpoint of the
+    last interval assigned to that color. A color is available if last_r <= l.
+    (This respects open intervals: last_r == l => no overlap.)
+    """
+    last_r: List[float] = []
+    for (l, r) in intervals:
+        assigned = False
+        for i in range(len(last_r)):
+            if last_r[i] <= l:
+                last_r[i] = r
+                assigned = True
+                break
+        if not assigned:
+            last_r.append(r)
+    return len(last_r)
+
+
+def _clique_number(intervals: Sequence[Interval]) -> int:
+    """
+    Compute the clique number (maximum number of intervals covering any point).
+    For open intervals (l,r) we must treat an end at x before a start at x
+    so that (a,x) and (x,b) do not overlap; thus process 'end' events first.
+    """
+    events = []
+    for (l, r) in intervals:
+        events.append((l, "start"))
+        events.append((r, "end"))
+    # sort by coordinate, and process 'end' before 'start' at the same coordinate
+    events.sort(key=lambda e: (e[0], 0 if e[1] == "end" else 1))
+    cur = 0
+    best = 0
+    for _, typ in events:
+        if typ == "end":
+            cur -= 1
+        else:
+            cur += 1
+            if cur > best:
+                best = cur
+    return best
+
+
+def _expand_level(T: Sequence[Interval], starts: Sequence[int], blockers: Sequence[Tuple[int, int]]) -> List[Interval]:
+    """
+    Given current template T, create translated/scaled copies at offsets 'starts'
+    (these are integer multipliers) and append blockers specified as multipliers
+    relative to the current span (delta).
+    The pattern follows the Figure-4 style replacement.
+    """
     lo = min(l for l, r in T)
     hi = max(r for l, r in T)
     delta = hi - lo
-    S = []
-    # Alternate offset patterns to break regularity
-    starts = (2, 6, 10, 14) if i % 2 == 0 else (1, 5, 9, 13)
-    # Place four scaled/translated copies at staggered offsets
-    for start in starts:
-      offset = delta * start - lo
-      S.extend([(offset + l, offset + r) for l, r in T])
-    # Add the four connecting long intervals (these create the coupling
-    # between copies but are designed not to increase the clique beyond
-    # the intended constant)
-    S += [
-      (delta * 1,  delta * 5),
-      (delta * 12, delta * 16),
-      (delta * 4,  delta * 9),
-      (delta * 8,  delta * 13)
-    ]
-    T = S
+    S: List[Interval] = []
+    for s in starts:
+        offset = delta * s - lo
+        for (l, r) in T:
+            S.append((offset + l, offset + r))
+    for (a, b) in blockers:
+        S.append((delta * a, delta * b))
+    return S
 
-  # Normalize endpoints to a compact integer grid while preserving order.
-  # Map each unique endpoint to an increasing even integer (to ensure
-  # positive lengths and avoid degeneracy).
-  eps = 1e-9
-  endpoints = sorted(set([x for seg in T for x in seg]))
-  # Use a dictionary mapping each float endpoint to an integer coordinate.
-  coord = {}
-  cur = 0
-  for e in endpoints:
-    # assign increasing even integers (spacing by 2)
-    coord[e] = cur
-    cur += 2
 
-  normalized = [(coord[l], coord[r]) for (l, r) in T]
+# Pre-defined tiling offset sets (A–D) and blocker templates (A–C).
+TILING_SETS = {
+    "A": (2, 6, 10, 14),
+    "B": (1, 5, 9, 13),
+    "C": (3, 7, 11, 15),
+    "D": (0, 4, 8, 12),
+}
 
-  return normalized
+BLOCKER_TEMPLATES = {
+    # Template A: original Figure-4 style
+    "A": ((1, 5), (12, 16), (4, 9), (8, 13)),
+    # Template B: alternate blockers (deterministic variant)
+    "B": ((0, 4), (7, 11), (3, 7), (10, 14)),
+    # Template C: another deterministic alternate
+    "C": ((1, 5), (9, 13), (5, 9), (12, 16)),
+}
+
+
+def _build_recursive(base: Sequence[Interval],
+                     depth: int,
+                     starts: Sequence[int],
+                     blockers: Sequence[Tuple[int, int]],
+                     normalize_cadence: str = "final") -> List[Interval]:
+    """
+    Build recursively for 'depth' levels:
+      - starts: offsets used to replicate copies at each level
+      - blockers: list of (a,b) multiplier pairs appended each level
+      - normalize_cadence: "every", "two", or "final" determines whether
+        we compress endpoint coordinates periodically.
+    Returns a list of intervals (float endpoints) in online order.
+    """
+    T = [ (float(l), float(r)) for (l, r) in base ]  # copy as float intervals
+    for level in range(depth):
+        T = _expand_level(T, starts, blockers)
+        if normalize_cadence == "every":
+            # normalize and convert back to floats to keep coordinates compact
+            T = [(float(a), float(b)) for (a, b) in _normalize_grid(T)]
+        elif normalize_cadence == "two" and (level + 1) % 2 == 0:
+            T = [(float(a), float(b)) for (a, b) in _normalize_grid(T)]
+        # otherwise "final" -> do nothing until the end
+    if normalize_cadence == "final":
+        # compress to reduce numerical size
+        T = [(float(a), float(b)) for (a, b) in _normalize_grid(T)]
+    return T
+
+
+def _prune_frontier_preserving(intervals: List[Tuple[int, int]],
+                               max_attempts: int = 200) -> List[Tuple[int, int]]:
+    """
+    Deterministic earliest-added-first pruning:
+    Try removing intervals in arrival order; accept a removal only if both
+    FirstFit color count and clique number remain unchanged. Limit the
+    number of successful removals to 'max_attempts' to keep runtime bounded.
+    """
+    n = len(intervals)
+    orig_intervals = list(intervals)
+    orig_alg = _firstfit_colors(orig_intervals)
+    orig_opt = _clique_number(orig_intervals)
+    removed = [False] * n
+    attempts = 0
+    # iterate earliest-first; multiple sweeps until no removal or max_attempts reached
+    changed = True
+    while changed and attempts < max_attempts:
+        changed = False
+        for i in range(n):
+            if removed[i]:
+                continue
+            # build candidate skipping i and any already removed
+            candidate = [orig_intervals[j] for j in range(n) if j != i and not removed[j]]
+            c_alg = _firstfit_colors(candidate)
+            c_opt = _clique_number(candidate)
+            if c_alg == orig_alg and c_opt == orig_opt:
+                removed[i] = True
+                attempts += 1
+                changed = True
+                # update orig_intervals is unnecessary; we keep referencing original indices
+                if attempts >= max_attempts:
+                    break
+        # loop will stop when no removal in pass
+    # reconstruct final list
+    final = [orig_intervals[i] for i in range(n) if not removed[i]]
+    return final
+
 
 # EVOLVE-BLOCK-END
 
 def run_experiment(**kwargs):
   """Main called by evaluator"""
   return construct_intervals()