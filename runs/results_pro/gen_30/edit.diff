--- a/original.py
+++ b/original.py
@@ -1,77 +1,84 @@
 # EVOLVE-BLOCK-START
 
 def construct_intervals():
     """
     Construct an interval sequence that forces FirstFit to use many colors
     while keeping the clique number at 4.  We apply a 4‐layer recursive
     gadget expansion with alternating shift patterns and canonical bridge intervals.
     Returns:
       List of (l, r) open‐interval tuples.
     """
 
     def expand_layer(template, starts, bridges):
         """
         Given a list of intervals `template`, produce one expansion layer:
         - replicate `template` shifted by each factor in `starts`
         - add each bridge interval scaled by the current span
         """
         lo = min(l for l, r in template)
         hi = max(r for l, r in template)
         span = hi - lo
         result = []
         # replicate
         for s in starts:
             offset = span * s - lo
             for (l, r) in template:
                 result.append((l + offset, r + offset))
         # add bridges (each specified as (a,b) factors)
         for a, b in bridges:
             result.append((span * a, span * b))
         return result
 
     def build_multilayer(depth):
         """
-        Build the gadget by repeatedly expanding the template `depth` times.
-        We alternate two start‐shift patterns to induce asymmetry.
+        Build the gadget by repeatedly expanding the template depth times.
+        Cycle four start-patterns and four bridge-sets to increase asymmetry.
         """
-        # initial seed: single unit interval
         T = [(0.0, 1.0)]
-        # fixed bridge‐interval factors from Figure 4
-        bridge_factors = [(1,5), (12,16), (4,9), (8,13)]
-        # two alternating start‐factor patterns
+        # four-pattern cycle
         patterns = [
             (2,6,10,14),
             (3,7,11,15),
+            (4,8,12,16),
+            (5,9,13,17),
+        ]
+        # four bridge-set cycle
+        bridge_sets = [
+            [(1,5), (12,16), (4,9), (8,13)],
+            [(2,6), (11,15), (5,10), (9,14)],
+            [(3,7), (10,14), (6,11), (7,12)],
+            [(4,8), (13,17), (7,12), (8,13)]
         ]
         for i in range(depth):
-            starts = patterns[i % 2]
-            T = expand_layer(T, starts, bridge_factors)
+            starts = patterns[i % len(patterns)]
+            bridges = bridge_sets[i % len(bridge_sets)]
+            T = expand_layer(T, starts, bridges)
         return T
 
-    def normalize(intervals, scale=10):
+    def normalize(intervals, scale=12):
         """
         Shift all intervals to positive, multiply by `scale`, and
         round to integers so that open intervals remain valid.
         """
         # shift so all l > 0
         min_l = min(l for l, r in intervals)
         shift = (-min_l + 1.0) if min_l <= 0.0 else 0.0
         normalized = []
         for (l, r) in intervals:
             L = int((l + shift) * scale)
             R = int((r + shift) * scale + 0.9999)
             if R <= L:
                 R = L + 1
             normalized.append((float(L), float(R)))
         return normalized
 
     # Build with 4 recursive layers to push FF >> opt=4
     raw = build_multilayer(depth=4)
     # Map to integer grid and clean up
     return normalize(raw)
 
 # EVOLVE-BLOCK-END
 
 def run_experiment(**kwargs):
   """Main called by evaluator"""
   return construct_intervals()