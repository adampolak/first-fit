--- a/original.py
+++ b/original.py
@@ -1,77 +1,82 @@
 # EVOLVE-BLOCK-START
 
 def construct_intervals():
     """
     Construct an interval sequence that forces FirstFit to use many colors
     while keeping the clique number at 4.  We apply a 4‐layer recursive
     gadget expansion with alternating shift patterns and canonical bridge intervals.
     Returns:
       List of (l, r) open‐interval tuples.
     """
 
     def expand_layer(template, starts, bridges):
         """
         Given a list of intervals `template`, produce one expansion layer:
         - replicate `template` shifted by each factor in `starts`
         - add each bridge interval scaled by the current span
         """
         lo = min(l for l, r in template)
         hi = max(r for l, r in template)
         span = hi - lo
         result = []
         # replicate
         for s in starts:
             offset = span * s - lo
             for (l, r) in template:
                 result.append((l + offset, r + offset))
         # add bridges (each specified as (a,b) factors)
         for a, b in bridges:
             result.append((span * a, span * b))
         return result
 
     def build_multilayer(depth):
         """
         Build the gadget by repeatedly expanding the template `depth` times.
         We alternate two start‐shift patterns to induce asymmetry.
         """
         # initial seed: single unit interval
         T = [(0.0, 1.0)]
         # fixed bridge‐interval factors from Figure 4
         bridge_factors = [(1,5), (12,16), (4,9), (8,13)]
         # two alternating start‐factor patterns
         patterns = [
             (2,6,10,14),
             (3,7,11,15),
         ]
         for i in range(depth):
             starts = patterns[i % 2]
             T = expand_layer(T, starts, bridge_factors)
         return T
 
     def normalize(intervals, scale=10):
         """
         Shift all intervals to positive, multiply by `scale`, and
         round to integers so that open intervals remain valid.
+        Then, adversarially reorder by increasing length to push long
+        caps later, which tends to increase FirstFit's color usage
+        without changing the clique number.
         """
         # shift so all l > 0
         min_l = min(l for l, r in intervals)
         shift = (-min_l + 1.0) if min_l <= 0.0 else 0.0
         normalized = []
         for (l, r) in intervals:
             L = int((l + shift) * scale)
             R = int((r + shift) * scale + 0.9999)
             if R <= L:
                 R = L + 1
             normalized.append((float(L), float(R)))
+        # Adversarial arrival order: short-first, long-later
+        normalized.sort(key=lambda iv: (iv[1] - iv[0], iv[0], iv[1]))
         return normalized
 
     # Build with 4 recursive layers to push FF >> opt=4
     raw = build_multilayer(depth=4)
     # Map to integer grid and clean up
     return normalize(raw)
 
 # EVOLVE-BLOCK-END
 
 def run_experiment(**kwargs):
   """Main called by evaluator"""
   return construct_intervals()