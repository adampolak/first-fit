--- a/original.py
+++ b/original.py
@@ -1,71 +1,75 @@
 # EVOLVE-BLOCK-START
 
 def construct_intervals(depth=None):
-  """
-  Construct a sequence of intervals of real line,
-  in the order in which they are presented to FirstFit,
-  so that it maximizes the number of colors used by FirstFit
-  divided by the maximum number of intervals that cover a single point
+    """
+    Build an interval arrival sequence that maximizes FirstFit/omega.
+    We recursively expand a seed gadget with rotated start‐shifts,
+    bridge intervals, and varying scale factors.
+    Returns a list of (l, r) tuples on an integer grid.
+    """
+    # allow overriding recursion depth
+    if depth is None:
+        depth = 5
 
-  This implementation follows the recursive "cap" construction
-  inspired by Figure 4 in https://arxiv.org/abs/1506.00192 and
-  increases the recursion depth to amplify the FF/omega ratio.
+    # four rotated copy‐shifts
+    START_SETS = [
+        [2, 6, 10, 14],
+        [3, 7, 11, 15],
+        [4, 8, 12, 16],
+        [5, 9, 13, 17],
+    ]
+    # four rotated bridge‐link patterns
+    BRIDGE_SETS = [
+        [(1, 5),  (12, 16), (4, 9),  (8, 13)],
+        [(2, 6),  (13, 17), (5, 10), (9, 14)],
+        [(3, 7),  (14, 18), (6, 11), (10, 15)],
+        [(4, 8),  (15, 19), (7, 12), (11, 16)],
+    ]
+    # small variety of scale multipliers
+    SCALING_LIST = [1.0, 1.2, 0.8, 1.15, 1.05]
 
-  Returns:
-    intervals: list of tuples, each tuple (l, r) represents an open interval from l to r
-  """
+    # initial dual‐spine seed intervals
+    T = [(0.0, 1.0), (5.0, 6.0)]
 
-  # Allow explicit depth control to explore smarter configurations.
-  # If depth is not provided, fall back to the traditional depth=4.
-  if depth is None:
-    depth = 4
+    def expand_layer(template, starts, bridges, gamma):
+        lo = min(l for l, r in template)
+        hi = max(r for l, r in template)
+        span = (hi - lo) * gamma
+        out = []
+        # replicate template at each start‐shift
+        for s in starts:
+            offset = span * s - lo
+            for l, r in template:
+                out.append((l + offset, r + offset))
+        # add bridge intervals
+        for a, b in bridges:
+            out.append((span * a, span * b))
+        return out
 
-  # Pattern banks to introduce variety across recursion levels.
-  START_SETS = [
-    [2, 6, 10, 14],
-    [3, 7, 11, 15],
-    [4, 8, 12, 16],
-    [5, 9, 13, 17],
-  ]
-  BRIDGE_SETS = [
-    [(1, 5), (12, 16), (4, 9), (8, 13)],
-    [(2, 6), (13, 17), (5, 10), (9, 14)],
-    [(3, 7), (14, 18), (6, 11), (10, 15)],
-    [(4, 8), (15, 19), (7, 12), (11, 16)],
-  ]
+    # recursive expansion
+    for i in range(depth):
+        S = expand_layer(
+            T,
+            START_SETS[i % len(START_SETS)],
+            BRIDGE_SETS[i % len(BRIDGE_SETS)],
+            SCALING_LIST[i % len(SCALING_LIST)]
+        )
+        T = S
 
-  SCALING_LIST = [1.0, 1.2, 0.8, 1.15, 1.05]
-  # initial seeds: two disjoint spine intervals to diversify recursive growth
-  T = [(0, 1), (2, 3)]
-  for k in range(depth):
-    lo = min(l for l, r in T)
-    hi = max(r for l, r in T)
-    gamma = SCALING_LIST[k % len(SCALING_LIST)]
-    delta = (hi - lo) * gamma
-    S = []
-    # Use a rotating start set to diversify the expanded copies of T
-    start_list = START_SETS[k % len(START_SETS)]
-    for start in start_list:
-      S += [(delta * start + l - lo, delta * start + r - lo) for l, r in T]
-    # Use a rotating bridge pattern to insert cross-links without inflating omega
-    bridge_set = BRIDGE_SETS[k % len(BRIDGE_SETS)]
-    S += [ (delta * a, delta * b) for (a, b) in bridge_set ]
-    T = S
-  return T
-
-  # return [  # Figure 3, OPT=2, FF=4
-  #   (2,3),
-  #   (6,7),
-  #   (10,11),
-  #   (14,15),
-  #   (1,5),
-  #   (12,16),
-  #   (4,9),
-  #   (8,13),
-  # ]
+    # normalize to positive integer grid (scale×10)
+    min_l = min(l for l, r in T)
+    shift = -min_l + 1.0 if min_l < 1.0 else 0.0
+    normalized = []
+    for l, r in T:
+        L = int((l + shift) * 10)
+        R = int((r + shift) * 10 + 0.9999)
+        if R <= L:
+            R = L + 1
+        normalized.append((L, R))
+    return normalized
 
 # EVOLVE-BLOCK-END
 
 def run_experiment(**kwargs):
   """Main called by evaluator"""
   return construct_intervals()