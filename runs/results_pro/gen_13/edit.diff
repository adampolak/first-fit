--- a/original.py
+++ b/original.py
@@ -1,53 +1,136 @@
 # EVOLVE-BLOCK-START
 
 def construct_intervals():
-  """
-  Construct a sequence of intervals of real line,
-  in the order in which they are presented to FirstFit,
-  so that it maximizes the number of colors used by FirstFit
-  divided by the maximum number of intervals that cover a single point
+    """
+    Construct a sequence of intervals of the real line, in the order presented to FirstFit,
+    aiming to maximize FirstFit colors divided by the clique number (offline optimum).
+    This version uses a modular "cap engine" with deterministic pattern cycling and
+    endpoint compression to keep the span small while preserving interval intersections.
 
-  This implementation follows the recursive "cap" construction
-  inspired by Figure 4 in https://arxiv.org/abs/1506.00192 and
-  increases the recursion depth to amplify the FF/omega ratio.
+    Returns:
+      intervals: list of tuples (l, r) representing open intervals with integer endpoints.
+    """
 
-  Returns:
-    intervals: list of tuples, each tuple (l, r) represents an open interval from l to r
-  """
+    # ------------------------
+    # Internal utilities
+    # ------------------------
 
-  # Increase recursion depth to grow FF faster than omega (empirically).
-  depth = 4
+    def compress_endpoints(intervals):
+        """
+        Order-preserving compression of endpoints to small integers.
+        Applies a strictly increasing mapping to all distinct endpoints and reassigns
+        them to consecutive integers, preserving all intersection relations.
+        """
+        if not intervals:
+            return []
+        # Collect and sort distinct endpoints
+        pts = sorted({p for iv in intervals for p in iv})
+        idx = {p: i for i, p in enumerate(pts)}
+        # Map each interval using the order-preserving mapping
+        comp = []
+        for l, r in intervals:
+            L = idx[l]
+            R = idx[r]
+            # Ensure open interval with positive length is preserved
+            if R <= L:
+                R = L + 1
+            comp.append((L, R))
+        return comp
 
-  T = [(0, 1)]
-  for _ in range(depth):
-    lo = min(l for l, r in T)
-    hi = max(r for l, r in T)
-    delta = hi - lo
-    S = []
-    for start in (2, 6, 10, 14):
-      S += [(delta * start + l - lo, delta * start + r - lo) for l, r in T]
-    S += [
-      (delta * 1, delta * 5),
-      (delta * 12, delta * 16),
-      (delta * 4, delta * 9),
-      (delta * 8, delta * 13)
+    def replicate_copies(T, delta, lo, starts):
+        """
+        Replicate the current set of intervals T four times, placing copies at
+        scaled offsets determined by 'starts'. The copy placed for offset s is
+        shifted by delta*s, preserving the relative positions within T by (l - lo).
+        """
+        copies = []
+        for s in starts:
+            shift = delta * s
+            for (l, r) in T:
+                copies.append((shift + (l - lo), shift + (r - lo)))
+        return copies
+
+    def add_bridges(delta, bridge_pairs):
+        """
+        Add long intervals ("bridges") that cross between the replicated blocks to force
+        FirstFit to use new colors. bridge_pairs contains integer pairs (a, b) that denote
+        interval (delta*a, delta*b).
+        """
+        return [(delta * a, delta * b) for (a, b) in bridge_pairs]
+
+    def apply_step(T, starts, bridges):
+        """
+        One cap-construction step: from current T, replicate to four blocks (starts), then
+        add four bridge intervals (bridges). The result is endpoint-compressed.
+        """
+        lo = min(l for l, _ in T)
+        hi = max(r for _, r in T)
+        delta = hi - lo
+        # Replicate the four translated copies and add the four bridges
+        S = []
+        S.extend(replicate_copies(T, delta, lo, starts))
+        S.extend(add_bridges(delta, bridges))
+        # Compress endpoints to keep span small and maintain determinism
+        return compress_endpoints(S)
+
+    # ------------------------
+    # Pattern families (deterministic cycles)
+    # ------------------------
+    # Cycle translation-start patterns to diversify placements while preserving the cap structure.
+    start_patterns = [
+        (2, 6, 10, 14),
+        (3, 7, 11, 15),
+        (4, 8, 12, 16),
+        (5, 9, 13, 17),
     ]
-    T = S
-  return T
+    # Matched bridge-block patterns for the corresponding start patterns.
+    # Each choice creates two "outer" bridges and two "middle" bridges, coupling adjacent blocks.
+    bridge_patterns = [
+        # For (2,6,10,14)
+        [(1, 5), (12, 16), (4, 9), (8, 13)],
+        # For (3,7,11,15)
+        [(2, 6), (11, 15), (5, 10), (9, 14)],
+        # For (4,8,12,16)
+        [(3, 7), (10, 14), (6, 11), (7, 12)],
+        # For (5,9,13,17)
+        [(4, 8), (13, 17), (7, 12), (8, 13)],
+    ]
 
-  # return [  # Figure 3, OPT=2, FF=4
-  #   (2,3),
-  #   (6,7),
-  #   (10,11),
-  #   (14,15),
-  #   (1,5),
-  #   (12,16),
-  #   (4,9),
-  #   (8,13),
-  # ]
+    # ------------------------
+    # Cap Engine: orchestrate iterative construction
+    # ------------------------
+    class CapEngine:
+        def __init__(self, depth, cycle_patterns=True):
+            self.depth = depth
+            self.cycle_patterns = cycle_patterns
+
+        def build(self):
+            # Single-seed start keeps omega low while enabling growth in FirstFit.
+            T = [(0, 1)]
+            if self.depth <= 0:
+                return T
+            for i in range(self.depth):
+                if self.cycle_patterns:
+                    pat_idx = i % 4
+                else:
+                    pat_idx = 0
+                starts = start_patterns[pat_idx]
+                bridges = bridge_patterns[pat_idx]
+                T = apply_step(T, starts, bridges)
+            return T
+
+    # ------------------------
+    # Choose construction parameters
+    # ------------------------
+    # Depth is the main lever affecting FF/omega; with this cap the ratio trends toward ~3.
+    # depth=5 yields a substantial improvement over depth=4 in practice while keeping n moderate.
+    depth = 5
+    engine = CapEngine(depth=depth, cycle_patterns=True)
+    intervals = engine.build()
+    return intervals
 
 # EVOLVE-BLOCK-END
 
 def run_experiment(**kwargs):
   """Main called by evaluator"""
   return construct_intervals()