# EVOLVE-BLOCK-START

def construct_intervals():
    """
    Construct a sequence of intervals of the real line, in the order presented to FirstFit,
    aiming to maximize FirstFit colors divided by the clique number (offline optimum).
    This version uses a modular "cap engine" with deterministic pattern cycling and
    endpoint compression to keep the span small while preserving interval intersections.

    Returns:
      intervals: list of tuples (l, r) representing open intervals with integer endpoints.
    """

    # ------------------------
    # Internal utilities
    # ------------------------

    def compress_endpoints(intervals):
        """
        Order-preserving compression of endpoints to small integers.
        Applies a strictly increasing mapping to all distinct endpoints and reassigns
        them to consecutive integers, preserving all intersection relations.
        """
        if not intervals:
            return []
        # Collect and sort distinct endpoints
        pts = sorted({p for iv in intervals for p in iv})
        idx = {p: i for i, p in enumerate(pts)}
        # Map each interval using the order-preserving mapping
        comp = []
        for l, r in intervals:
            L = idx[l]
            R = idx[r]
            # Ensure open interval with positive length is preserved
            if R <= L:
                R = L + 1
            comp.append((L, R))
        return comp

    def replicate_copies(T, delta, lo, starts):
        """
        Replicate the current set of intervals T four times, placing copies at
        scaled offsets determined by 'starts'. The copy placed for offset s is
        shifted by delta*s, preserving the relative positions within T by (l - lo).
        """
        copies = []
        for s in starts:
            shift = delta * s
            for (l, r) in T:
                copies.append((shift + (l - lo), shift + (r - lo)))
        return copies

    def add_bridges(delta, bridge_pairs):
        """
        Add long intervals ("bridges") that cross between the replicated blocks to force
        FirstFit to use new colors. bridge_pairs contains integer pairs (a, b) that denote
        interval (delta*a, delta*b).
        """
        return [(delta * a, delta * b) for (a, b) in bridge_pairs]

    def apply_step(T, starts, bridges):
        """
        One cap-construction step: from current T, replicate to four blocks (starts), then
        add four bridge intervals (bridges). The result is endpoint-compressed.
        """
        lo = min(l for l, _ in T)
        hi = max(r for _, r in T)
        delta = hi - lo
        # Replicate the four translated copies and add the four bridges
        S = []
        S.extend(replicate_copies(T, delta, lo, starts))
        S.extend(add_bridges(delta, bridges))
        # Compress endpoints to keep span small and maintain determinism
        return compress_endpoints(S)

    # ------------------------
    # Pattern families (deterministic cycles)
    # ------------------------
    # Cycle translation-start patterns to diversify placements while preserving the cap structure.
    start_patterns = [
        (2, 6, 10, 14),
        (3, 7, 11, 15),
        (4, 8, 12, 16),
        (5, 9, 13, 17),
    ]
    # Matched bridge-block patterns for the corresponding start patterns.
    # Each choice creates two "outer" bridges and two "middle" bridges, coupling adjacent blocks.
    bridge_patterns = [
        # For (2,6,10,14)
        [(1, 5), (12, 16), (4, 9), (8, 13)],
        # For (3,7,11,15)
        [(2, 6), (11, 15), (5, 10), (9, 14)],
        # For (4,8,12,16)
        [(3, 7), (10, 14), (6, 11), (7, 12)],
        # For (5,9,13,17)
        [(4, 8), (13, 17), (7, 12), (8, 13)],
    ]

    # ------------------------
    # Cap Engine: orchestrate iterative construction
    # ------------------------
    class CapEngine:
        def __init__(self, depth, cycle_patterns=True):
            self.depth = depth
            self.cycle_patterns = cycle_patterns

        def build(self):
            # Single-seed start keeps omega low while enabling growth in FirstFit.
            T = [(0, 1)]
            if self.depth <= 0:
                return T
            for i in range(self.depth):
                if self.cycle_patterns:
                    pat_idx = i % 4
                else:
                    pat_idx = 0
                starts = start_patterns[pat_idx]
                bridges = bridge_patterns[pat_idx]
                T = apply_step(T, starts, bridges)
            return T

    # ------------------------
    # Choose construction parameters
    # ------------------------
    # Depth is the main lever affecting FF/omega; with this cap the ratio trends toward ~3.
    # depth=5 yields a substantial improvement over depth=4 in practice while keeping n moderate.
    depth = 5
    engine = CapEngine(depth=depth, cycle_patterns=True)
    intervals = engine.build()
    return intervals

# EVOLVE-BLOCK-END

def run_experiment(**kwargs):
    """Main called by evaluator"""
    return construct_intervals()